<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Reorx’s Forge</title><link>https://reorx.com/</link><description>Recent content on Reorx’s Forge</description><image><url>https://reorx.com/forge.png</url><link>https://reorx.com/forge.png</link></image><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://reorx.com/feed.xml" rel="self" type="application/rss+xml"/><item><title>搭建 umami 收集个人网站统计数据</title><link>https://reorx.com/blog/deploy-umami-for-personal-website/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/deploy-umami-for-personal-website/</guid><description>教你如何免费搭建和使用美丽的 umami 网站统计服务，和 Google Analytics 说再见。</description><content:encoded><![CDATA[<p>距离博客第一篇文章发布正好一个月，我想查看一下网站的统计数据，在 Google Analytics 上操作了一番，发觉自己已无法忍受这个复杂且迟缓的老旧产品，这让我开始思考有没有更好的解决方案。</p>
<p>我首先想到的是切换到另一家 hosting 的网站统计服务，如果可以的话，最好能有免费额度。然而开公司并不是做慈善，Google 之所以开放 Analytics 免费使用，除了本身体量足够大、边际成本够低之外，也因为网站统计与其核心的广告业务是密不可分的，Google 乐于让尽可能多的网站使用 Analytics，以得到可以推动广告和搜索业务发展的数据。果不其然，目前风评比较好的服务如 <a href="https://usefathom.com/pricing">fathom</a> 都没有免费套餐，价格也不便宜；<a href="https://plausible.io/#pricing">plausible</a> 价格较低，并且提供开源可部署的版本，这让我开始考虑自建统计服务的可行性。</p>
<p>要选择一个 self-hosted 网站统计服务，我有以下几个考量：</p>
<ul>
<li><strong>实现语言</strong>：我非常倾向于 JavaScript 的实现，这并非出于我对它更加熟悉或者偏爱，而是因为近年来 Cloudflare 在 serverless 和 edge computing 领域不断深耕，推动了一系列基于 JavaScript 的运行环境和基础设施的发展，最近还联合 Vercel 等友商成立了 <a href="https://blog.cloudflare.com/introducing-the-wintercg/">WinterCG</a> 社区组织，让我看到了 JavaScript 一站式云端开发部署的未来。我自己也尝试过 Workers 开发，体验很好，免费额度充裕。如果一个服务是 JavaScript 实现，就有在 Workers 上部署的可能性。</li>
<li><strong>数据库</strong>：最好是 SQLite。SQLite 的存储基于单文件，非常适合小型服务的开发部署。<a href="https://litestream.io/">Litestream</a> 的存在让基于 S3 等对象存储的低成本数据库维护成为可能。</li>
<li><strong>便于部署</strong>：有官方维护的 docker image，或提供 PaaS/Serverless 平台的一键部署模板</li>
<li><strong>尊重数据隐私</strong>：其实 self-hosted 统计服务产生的目的之一就是为了抵制商业服务滥用用户数据，因此这一点大部分项目都可以满足，稍加注意即可。</li>
<li><strong>ublock</strong>：作为一个 webmaster，肯定希望统计数据越精确越好，因此这个服务得有绕过 ublock 拦截的能力。虽然我个人也会使用 ublock 拦截各种 tracker，但 self-hosted 统计服务本身不会过度收集用户数据，更不会将其用于商业目的，可以理直气壮地想办法确保其正常加载。</li>
</ul>
<p>经过一番调查，我选择了 umami，它基本满足以上所有需求：</p>
<ul>
<li>前后端全部使用 TypeScript 和 Next.js 开发</li>
<li>数据库是 PostgreSQL，我比较喜欢，可以接受</li>
<li>项目页面有个大大的 “Deploy on Railway”，也有 docker image</li>
<li>项目 Slogan 就是 “privacy focused”
<blockquote>
<p>Umami does not collect any personally identifiable information and anonymizes all data collected.</p>
</blockquote>
</li>
<li>提供 <code>TRACKER_SCRIPT_NAME</code> 环境变量用于自定义 script 名称，可以绕过 ublock 的默认规则</li>
</ul>
<p>择日不如撞日，选定工具后我立刻开始尝试部署。umami 的部署流程是如此顺滑，只花了大概 15 分钟，我就确信自己做了一个十分正确的选择。</p>
<h2 id="部署说明">部署说明</h2>
<p>我之前就对 Railway 有所了解，所以直接点击 “Deploy on Railway” 按钮开始部署流程。</p>
<p><a href="https://railway.app">Railway</a> 是一个 PaaS 平台，可运行 JavaScript, Python, Go 等多种语言，提供 Redis, MySQL, MongoDB 等主流数据库存储。由于支持全面、界面友好，加上和 Cloudflare 一样有充裕的<a href="https://railway.app/pricing">免费额度</a>，足够个人项目免费使用，Railway 一直是我心中最好的 PaaS 之一。如果你有兴趣，欢迎通过我的 <a href="https://railway.app?referralCode=XkWaVV">referral link</a> 注册。</p>
<p>umani 有一篇 <a href="https://umami.is/docs/running-on-railway">Running on Railway</a> 文档，我遵照这个流程很快就完成了初步部署。其实只有一个 <code>HASH_SALT</code> 需要输入，其他只需点点点即可。</p>
<p>Railway Project 创建后，在管理界面可以看到两个 block，左边是数据库实例，右边是 umami 的后端服务。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway.png" alt=""  /></p>
<h3 id="安装依赖">安装依赖</h3>
<p>在等待 umami 的镜像构建和部署的过程中，我们可以在命令行进行一些其他工作。</p>
<p>打开命令行，使用以下命令安装 Railway CLI 和 pgsql 两个软件依赖。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">brew install railwayapp/railway/railway
brew install libpg
</code></pre></div><p>完成后，将 libpg 的 bin 路径添加到 PATH 中，在 <code>.zshrc</code> 或 <code>.bashrc</code> 中添加一行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$PATH</span><span class="s2">:/opt/homebrew/opt/libpq/bin&#34;</span>
</code></pre></div><p>你可以通过执行 <code>type pgsql</code> 确认 <code>pgsql</code> 是否存在。</p>
<h3 id="更新数据库">更新数据库</h3>
<p>Railway 在创建 Project 时，会将 umami 的代码复制到在你的 GitHub 账户所创建的名为 <code>umami</code> 的仓库中，我们需要先将此仓库 clone 下来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">git clone git@github.com:username/umami.git
</code></pre></div><p>进入 umami 目录，执行以下命令，登录 Railway CLI 并完成链接:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> umami
railway login
railway link
</code></pre></div><p>这一步完成后，可以通过 <code>railway variables</code> 看到 umami 服务的环境变量，确认 CLI 可以访问到线上数据。</p>
<pre tabindex="0"><code>DATABASE_URL:        postgresql://postgres:xxxxxxxxx@containers-us-west.railway.app:6595/railway
DISABLE_TELEMETRY:   1
HASH_SALT:           xxXXxxXXxxXXxx
HOSTNAME:
PGDATABASE:          railway
PGHOST:              containers-us-west.railway.app
PGPASSWORD:          xxXXxxXXxxXXxx
PGPORT:              6595
PGUSER:              postgres
PORT:                3000
</code></pre><p>执行以下命令，为 umami 创建表格、添加初始数据。注意要将 bash variable 替换为上文中的数据:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">railway run psql -h <span class="nv">$PGHOST</span> -U <span class="nv">$PGUSER</span> -d <span class="nv">$PGDATABASE</span> -f sql/schema.postgresql.sql
</code></pre></div><h3 id="配置服务">配置服务</h3>
<p>数据库初始化完毕后，回到 Project 管理界面，确认 umami 部署完毕，即可打开服务的主页。</p>
<h4 id="更换密码">更换密码</h4>
<p>使用初始用户名密码 <code>admin:umami</code> 登录进去，然后立刻到 Settings &gt; Accounts 界面更换一个强密码。</p>
<h4 id="绑定个人域名">绑定个人域名</h4>
<p>在 Project 管理界面点击 umami，选择 Settings，在 Service Domains 下添加个人域名。比如我使用的是 <code>oishii.reorx.com</code>。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway-1.png" alt=""  /></p>
<p>打开域名的 DNS 服务商，根据 Railway 中的提示，为自定义域名添加 CNAME 记录。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/cloudflare.png" alt=""  /></p>
<p>等待几分钟，生效后 Railway 中会显示上图所示的 ✅ 符号。</p>
<h4 id="修改脚本名称">修改脚本名称</h4>
<p>为了避免 umami 被 ublock 误杀（有的规则集中有匹配 umami 的正则），还需要为它的统计脚本更换一个名称。<a href="https://umami.is/docs/environment-variables">Environment variables</a> 文档中的 <code>TRACKER_SCRIPT_NAME</code> 提供了这一功能。</p>
<p>再次进入 Railway，打开 umami 的 Variables 选项卡，按下图所示添加环境变量，我使用的名称为 <code>oishii</code>，可以更换为任意非 tracker 特征词汇。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway-2.png" alt=""  /></p>
<p>完成这一步后，需要重新构建 umami 的镜像，目前我还没有找到触发 rebuild 的简单方法，只能通过修改 Dockerfile 实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff">RUN yarn next telemetry disable
<span class="gi">+# Ensures `yarn build` will always run when BUILD_TIME is different
</span><span class="gi">+ARG BUILD_TIME
</span><span class="gi"></span>RUN yarn build
</code></pre></div><p>在 <code>yarn build</code> 之前增加一行 <code>ARG BUILD_TIME</code>，这样当此参数不同时，就会触发 <code>yarn build</code> 及之后的命令重新执行。</p>
<p>保存修改，然后执行 <code>railway up</code>，等待镜像构建和部署完成。</p>
<h2 id="接入个人网站">接入个人网站</h2>
<p>一切准备就绪，我们重新使用自定义域名和修改后的密码登录 umami。</p>
<p>要进行统计，第一件事情是添加一个 Website。操作非常简单，读者可以参考 <a href="https://umami.is/docs/add-a-website">Add a website</a> 文档来进行。唯一需要注意的是 Enable share URL 选项，如果你想将自己网站的统计数据分享出去，则需要勾选之。你可以在 <a href="https://oishii.reorx.com/share/jKljpE4T/reorx.com">https://oishii.reorx.com/share/jKljpE4T/reorx.com</a> 访问本站的统计信息。</p>
<p>添加完成后，点击网站列表中对应网站的 Get tracking code 按钮，在浮窗中获得需要加入到网站 HTML 中的代码。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/umami.png" alt=""  /></p>
<p>需要注意将 <code>src</code> 结尾的 <code>umami.js</code> 替换为 <code>$TRACKER_SCRIPT_NAME.js</code>。</p>
<p>复制代码并添加到自己个人网站的 <code>&lt;head&gt;</code> 标签下的任意位置，由于使用了 <code>defer</code> 属性，这个 script 不会对网页加载造成阻塞。</p>
<p>网站更新完成后，呼朋唤友点击访问一番，就可以看到 umami 清晰、美观的统计数据了。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/umami-1.png" alt=""  /></p>
]]></content:encoded></item><item><title>Frontend Guide 01: Webpack babel-loader 使用指南</title><link>https://reorx.com/blog/migrate-from-ts-loader-to-babel-loader/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/migrate-from-ts-loader-to-babel-loader/</guid><description>Frontend Guide 系列的第一篇文章，讲述我为何从 ts-loader 迁移到 babel-loader，以及我的 babel-loader 详细配置方案说明。</description><content:encoded><![CDATA[<h2 id="引子">引子</h2>
<p>大约在两个月前，为了做出一款属于自己的产品，我正式开始学习 TypeScript 和 React 开发<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。虽然接触 JavaScript 时间不短了，但一直热衷于使用 Vanilla JS，也没有正式做过比较严肃的项目。因此，我把自己定位为一个前端新手，决定从 0 开始学习现代化前端开发。</p>
<p>这两个月来，我在学习实践过程中累计了一些自己的心得和体会，算不上高深，但应该可以为同样在学习中的新手起到参考作用。从这篇文章开始，我会逐一将我认为有价值的部分写成博客，归类于 #frontend-guide 标签下，并在未来的学习中持续更新。作为一个非专业的前端学习者，这些文章中一定会出现错误和疏漏，请读者朋友们不吝指正，如果能从批评中学到什么，将会是我写作的最大收获。</p>
<p>先大致列举一些可写的话题，以作备忘：</p>
<ul>
<li>如何构建一个最基本的 TypeScript 项目
<ul>
<li>介绍 package.json 和基本的 devDependencies</li>
<li>介绍 tsconfig.json 中必须了解的选项</li>
<li>tsc 和 esbuild</li>
</ul>
</li>
<li>如何使用 jest 进行细粒度的 TDD</li>
<li>从零开始构建自己的 React project template
<ul>
<li>不使用 create-react-app 有哪些好处</li>
<li>webpack</li>
<li>babel: modular import and hot reload</li>
<li>config and APP_ENV</li>
</ul>
</li>
<li>如何构建一个最基本的 monorepo
<ul>
<li>npm workspace</li>
<li>tsconfig reference</li>
<li>webpack: resolve alias and tsconfig paths plugin</li>
</ul>
</li>
<li>TypeScript caveats and cheatsheet</li>
<li>如何使用 TypeScript 和 React 开发 Chrome Extension</li>
<li>Mobx 使用指南</li>
<li>实现一个简单的 useFetch Hook</li>
<li>如何使用 swr 调用 HTTP API</li>
<li>如何使用 Protobuf 和 TypeScript 封装 HTTP API</li>
</ul>
<h2 id="ts-loader">ts-loader</h2>
<p>在现代化前端项目中，TypeScript 因其静态类型的特性，为代码的可维护性、健壮性带来了极大的提升，已逐渐成为前端开发的标准语言。但 TypeScript 不能直接在浏览器中运行，因此在项目构建流程中需要引入 <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a> 来将其编译为浏览器可用的 JavaScript。<a href="https://github.com/TypeStrong/ts-loader">ts-loader</a> 就是为 Webpack 设计的 transpiler 之一。</p>
<p>过去的开发生涯中，我虽然不是专业的前端，也对 JavaScript 世界中的基石 babel 有所耳闻目见。但在这次从零开始学习 TypeScript 开发时，因为对 babel 有种过于复杂的印象，我选择了 ts-loader 作为第一个学习和上手的插件。</p>
<p>ts-loader 的使用非常简单，文档也足够清晰，如果你的项目本身有正确配置 <code>tsconfig.json</code> 并可以使用 <code>tsc -b</code> 完成编译，那么在 webpack 中引入 ts-loader 后不需要额外的配置即可工作。</p>
<p>下面是一份使用 ts-loader 的 <code>webpack.config.js</code> 示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">entry</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">index</span><span class="o">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">srcDir</span><span class="p">,</span> <span class="s1">&#39;index.tsx&#39;</span><span class="p">),</span>
  <span class="p">},</span>
  <span class="nx">output</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">path</span><span class="o">:</span> <span class="nx">destDir</span><span class="p">,</span>
    <span class="nx">filename</span><span class="o">:</span> <span class="s1">&#39;[name].bundle.js&#39;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;ts-loader&#39;</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>经过一段时间的使用，我发现了对 ts-loader 不太满意的几个地方：</p>
<ul>
<li>
<p>偶尔出现莫名的错误</p>
<p>有的时候，当对 TypeScript 源文件进行了某种变更，或许是大量的类型变化，或许是文件重命名和移动目录，可能会触发 ts-loader 报错，但此时 VSCode 的静态检查器却没有显示出任何问题（所有源文件），重启 webpack serve 也无济于事。这时只能通过删除所有与构建过程和结果有关的文件，如 <code>build</code>, <code>dist</code>, <code>**/*.d.ts</code>, <code>*.tsbuildinfo</code>，重新运行才可以消除这个不存在的错误。</p>
</li>
<li>
<p>难以 Debug 某些 transpiling 过程中的错误</p>
<p>如果你的 <code>tsconfig.json</code> 中设置了 <code>noEmit: true</code> 或 <code>noEmitOnError: true</code>, 那你很有可能会看到 <code>Error: TypeScript emitted no output for…</code> 这样的报错，这是因为 ts-loader 在将 TypeScript 转换成 JavaScript 时无法成功，于是没有输出 js 文件。但具体是什么错误，完全无法搞清楚。我在 GitHub 上跟踪了一个 <a href="https://github.com/TypeStrong/ts-loader/issues/1257">issue</a>, 目前仍然没有收获。</p>
</li>
<li>
<p>项目内多个 package 引用必须生成描述文件</p>
<p>如果想在项目内想要拆分多个 package 并互相引用，需要使用 TypeScript 的 <a href="https://www.typescriptlang.org/docs/handbook/project-references.html">Project References</a> 功能，而 <code>declaration</code>  必须设置为 true，此时 ts-loader 会为被引用的包生成 <code>.d.ts</code> 的描述文件，使文件浏览器变得混乱。</p>
</li>
<li>
<p>在插件生态中不是一等公民</p>
<p>一些优化项目开发流程的插件，如 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">react-refresh-webpack-plugin</a>, 优先支持 babel 而非 ts-loader；<a href="https://github.com/umijs/babel-plugin-import">babel-plugin-import</a> 的 ts-loader 实现 <a href="https://github.com/Brooooooklyn/ts-import-plugin">ts-import-plugin</a> 远不如其本身流行。</p>
</li>
</ul>
<p>于是我决定对 babel-loader 进行一次尝试。</p>
<h2 id="babel-loader">babel-loader</h2>
<p><a href="https://github.com/babel/babel-loader">babel-loader</a> 的项目页面有详细的安装配置说明，在此不做赘述。下面是一个在 TypeScript + React 项目中工作的最小化配置示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
            <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
              <span class="nx">presets</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-env&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">targets</span><span class="o">:</span> <span class="s2">&#34;defaults&#34;</span> <span class="p">}],</span>
                <span class="s1">&#39;@babel/preset-typescript&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-react&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;runtime&#39;</span><span class="o">:</span> <span class="s1">&#39;automatic&#39;</span><span class="p">}]</span>
              <span class="p">],</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>配置完成后，代码顺利编译，随后我开始了对构建配置优化的探索。</p>
<h3 id="webpack-bundle-analyzer">webpack-bundle-analyzer</h3>
<p>我首先想到的是对构建出的 bundle 的大小进行检查，一看竟然有 7MB 之大，于是安装了 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>, 对 bundle 中所包含的依赖进行分析。</p>
<p>下面是引入 webpack-bundle-analyzer 之后的 <code>webpack.config.js</code> 文件，通过环境变量 <code>WEBPACK_USE_ANALYZE</code> 判断是否进入分析模式并修改 webpack 配置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">useAnalyze</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">WEBPACK_USE_ANALYZE</span>

<span class="kr">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{...}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">useAnalyze</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">BundleAnalyzerPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;webpack-bundle-analyzer&#39;</span><span class="p">).</span><span class="nx">BundleAnalyzerPlugin</span><span class="p">;</span>

  <span class="nx">config</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="s1">&#39;development&#39;</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">plugins</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">BundleAnalyzerPlugin</span><span class="p">({</span>
      <span class="nx">analyzerPort</span><span class="o">:</span> <span class="mi">18888</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">config</span>
</code></pre></div><p>运行 <code>WEBPACK_USE_ANALYZE=1 webpack</code> 在浏览器中查看分析结果。</p>
<p><img loading="lazy" src="/blog/migrate-from-ts-loader-to-babel-loader/images/webpack-analyze.png" alt=""  /></p>
<p>原来 tabler-icons-react 一个库就占了 5.28MB，其他库中 lodash 也不算正常，似乎和 tabler-icons-react 一样被完整包含进来了。</p>
<h3 id="babel-plugin-import">babel-plugin-import</h3>
<p><a href="https://github.com/konradkalemba/tabler-icons-react">tabler-icons-react</a> 是一个 SVG 图标库，我只是使用了其中一部分图标。lodash 是非常通用的工具函数库，同样的，我只对其中一部分函数进行了引用。那么有没有办法按需加载依赖中的模块，只输出被 import 到的部分呢？答案就是 <a href="https://github.com/umijs/babel-plugin-import">babel-plugin-import</a>。</p>
<p>继续修改 <code>webpack.config.js</code>，为 babel-loader 增加 plugins:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
    <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;tabler-icons-react&#39;</span><span class="p">,</span>
        <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;dist/icons&#39;</span><span class="p">,</span>
      <span class="p">}],</span>
      <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;lodash&#39;</span><span class="p">,</span>
        <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">camel2DashComponentName</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="p">}],</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>再次运行 <code>WEBPACK_USE_ANALYZE=1 webpack</code> ，可以看出 bundle 结构有了显著的改进（红色的部分是 tabler-icons-react 和 lodash）:</p>
<p><img loading="lazy" src="/blog/migrate-from-ts-loader-to-babel-loader/images/webpack-analyze-2.png" alt=""  /></p>
<blockquote>
<p><a href="https://github.com/lodash/babel-plugin-lodash">babel-plugin-lodash</a> 也可以实现 lodash 的按需加载，但它是专为 lodash 开发的，不具备 babel-plugin-import 的通用性。</p>
</blockquote>
<h3 id="babelpreset-env">@babel/preset-env</h3>
<p><a href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a> 是 babel 中最重要的一个 preset。所谓 preset，即预设配置的封装，让需求相近的用户可以不用关注细节直接使用，preset-env 提供了非常丰富的选项，让使用者可以快速定制出符合目标需求的编译结果。</p>
<p>首先要关注的是 <a href="https://babeljs.io/docs/en/options#targets">targets</a> 选项，它决定了 babel 所编译出的 JavaScript 能否在特定平台上运行。<code>targets</code> 支持 <a href="https://github.com/ai/browserslist">browserslist</a> 语法，上文中我们的初始配置 <code>['@babel/preset-env', { targets: &quot;defaults&quot; }],</code> 代表使用 browserslist 的 defaults 查询<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，虽然可以编译，但在浏览器中是无法运行的，会产生
<code>Uncaught ReferenceError: regeneratorRuntime is not defined</code> 错误，这是为什么呢？</p>
<p>为了统一不同浏览器的 JavaScript 实现差异，使 ES2015+ 代码可以正确运行，babel 会根据 targets 决定是否需要在编译结果中注入 polyfill。
最早这一功能由 <a href="https://babeljs.io/docs/en/babel-polyfill">@babel/polyfill</a> 实现，但它在 babel 7.4.0 之后被废弃，由 <a href="https://github.com/zloirock/core-js">core-js </a> 接替。我们的代码之所以运行报错，就是因为没有指定 preset-env 使用 core-js，导致用于模拟 ES2015+ 运行环境的 <code>regeneratorRuntime</code> 缺失。</p>
<p>修改后的 preset-env 配置如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">[</span><span class="s2">&#34;@babel/preset-env&#34;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">targets</span><span class="o">:</span> <span class="s2">&#34;defaults&#34;</span><span class="p">,</span>
  <span class="nx">corejs</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="nx">useBuiltIns</span><span class="o">:</span> <span class="s1">&#39;usage&#39;</span><span class="p">,</span>
<span class="p">}]</span>
</code></pre></div><p>重新编译，代码即可成功运行。并且通过 webpack-bundle-analyzer 可以发现 bundle 中多出了 core-js 的部分。</p>
<p>如果想在对浏览器的支持上激进一些，可以尝试将 targets 设为 <code>{browsers: '&gt; 5%'}</code>，即仅支持占有率超过 5% 的浏览器，你会发现 bundle 中 core-js 的部分会再次消失，因为这些浏览器不需要 core-js 就有完整的 ES2015 支持。</p>
<h3 id="react-refresh-webpack-plugin">react-refresh-webpack-plugin</h3>
<p>webpack 提供 <a href="https://webpack.js.org/concepts/hot-module-replacement/">HMR</a> 热更新功能，不需要刷新页面即可将改动反映到页面中。在 babel-loader 中，需要通过 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">react-refresh-webpack-plugin</a> 插件来实现 React JSX 的热更新。</p>
<p>首先要在 devServer 中开启 <code>hot</code> 选项:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">devServer</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// Enable hot reloading
</span><span class="c1"></span>    <span class="nx">hot</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后为 webpack 添加 <code>ReactRefreshWebpackPlugin</code> 插件:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">ReactRefreshWebpackPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;@pmmmwh/react-refresh-webpack-plugin&#39;</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nx">ReactRefreshWebpackPlugin</span><span class="p">(),</span>
  <span class="p">],</span>
<span class="p">}</span>
</code></pre></div><p>最后为 babel-loader 添加 <code>react-refresh/babel</code> 插件，通过 <code>isDevelopment</code> 决定是否存在:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
  <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
      <span class="nx">isDevelopment</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;react-refresh/babel&#39;</span>
    <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="summary">Summary</h3>
<p>将以上插件和技巧综合起来，最终我的 babel-loader 配置如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
            <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
              <span class="nx">presets</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-env&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">targets</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">browsers</span><span class="o">:</span> <span class="s1">&#39;&gt; 5%&#39;</span><span class="p">,</span>
                  <span class="p">},</span>
                  <span class="nx">corejs</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
                  <span class="nx">useBuiltIns</span><span class="o">:</span> <span class="s1">&#39;usage&#39;</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="s1">&#39;@babel/preset-typescript&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-react&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;runtime&#39;</span><span class="o">:</span> <span class="s1">&#39;automatic&#39;</span><span class="p">}]</span>
              <span class="p">],</span>
              <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;tabler-icons-react&#39;</span><span class="p">,</span>
                  <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;dist/icons&#39;</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;lodash&#39;</span><span class="p">,</span>
                  <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                  <span class="nx">camel2DashComponentName</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="nx">isDevelopment</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;react-refresh/babel&#39;</span>
              <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">),</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>它实现了：</p>
<ul>
<li>输出支持现代主流浏览器的 JavaScript</li>
<li>按需加载 tabler-icons-react 和 lodash 模块</li>
<li>React JSX 开发热更新</li>
</ul>
<p>如果你想看到一个可运行的例子，请参考我的最小化 React 项目模板 <a href="https://github.com/reorx/minireact">reorx/minireact</a>，其中有完整的 <a href="https://github.com/reorx/minireact/blob/6e5b086e309cdbe7132c268ba8cf1e6e5d5ab32e/webpack.config.js">webpack.config.js</a> 文件。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-05-18: created</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>开始学习时的推文: <a href="https://twitter.com/novoreorx/status/1500385952942157828">学习了俩小时如何开始一个 TypeScript 项目，现在已经不省人事了</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>根据 browerslist 文档，<code>defaults</code> 代表 <code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>，是一个非常宽泛的规则，可覆盖全世界所有浏览器中的 <a href="https://browserslist.dev/?q=ZGVmYXVsdHM%3D">90%</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>Google I/O 2022 Web Platform 新特性展示观看笔记</title><link>https://reorx.com/blog/notes-on-google-io-2022-web-platform-presentation/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/notes-on-google-io-2022-web-platform-presentation/</guid><description>了解 Web 新技术从未如此充满乐趣。</description><content:encoded><![CDATA[<p>几天前临睡时看了 2022 Google IO 的一个 presentation: <a href="https://www.youtube.com/watch?v=5b4YcLB4DVI">What&rsquo;s new for the web platform</a>, 两位 Google 员工的解说让了解 Web 新技术的过程变得充满乐趣，于是做了些笔记在 <a href="https://threadreaderapp.com/thread/1525875286096904192.html">Twitter thread</a> 中。这篇文章对笔记进行了整理，并为每个特性附加详细说明的链接。</p>
<div class="tweet social-quote">
  <div class="title">
    <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>

    
  </div>

  <blockquote class="twitter-tweet" data-dnt="true"><p lang="zh" dir="ltr">开个串记录下观看 Google IO What&#39;s new for the web platform 中发现的有趣的 feature<a href="https://t.co/LZPGGn7NHZ">https://t.co/LZPGGn7NHZ</a></p>&mdash; Reorx (@novoreorx) <a href="https://twitter.com/novoreorx/status/1525875286096904192?ref_src=twsrc%5Etfw">May 15, 2022</a></blockquote>

</div>


<h2 id="html">HTML</h2>
<h3 id="dialog"><code>&lt;dialog&gt;</code></h3>
<p><a href="https://web.dev/building-a-dialog-component/">https://web.dev/building-a-dialog-component/</a></p>
<p><code>&lt;dialog&gt;</code> 和 <code>&lt;selectmenu&gt;</code>，基本上所有 UI Kit 都会在组件库里实现的功能，终于被 HTML 原生实现了。如果 HTML 能多一些这种常用的交互组件，我会很乐意手写 Vanilla JS 来使用它们。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-dialog.png" alt=""  /></p>
<h3 id="selectmenu"><code>&lt;selectmenu&gt;</code></h3>
<p><a href="https://open-ui.org/prototypes/selectmenu">https://open-ui.org/prototypes/selectmenu</a></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-selectmenu.png" alt=""  /></p>
<h3 id="input-typedatetile-local"><code>&lt;input type=datetile-local&gt;</code></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local</a></p>
<p>记得 7 年前在豌豆荚工作时，因为这个标签不被 Firefox 支持，被迫找了一个 JavaScript 库来代替 (Pikaday, I still remember)。如今终于可以在主流浏览器上全面通用，太不容易了😭。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-datetime-local.png" alt=""  /></p>
<h2 id="css">CSS</h2>
<h3 id="has-selector"><code>:has</code> selector</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has">https://developer.mozilla.org/en-US/docs/Web/CSS/:has</a></p>
<p>用于声明父子元素关系的 :has 选择器！这个功能前阵子正好搜索过，现在只能用 JavaScript 实现。</p>
<p>图中的代码可以解释为，在包含 <code>&lt;figcaption&gt;</code> 的 <code>&lt;figure&gt;</code> 元素中，将其 children 中的 <code>&lt;img&gt;</code> 增加 1rem 的 bottom margin。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-has.png" alt=""  /></p>
<h3 id="aspect-ratio">Aspect ratio</h3>
<p><a href="https://web.dev/aspect-ratio/">https://web.dev/aspect-ratio/</a></p>
<p>CSS aspect-radio，使元素保持固定的宽高比。这是曾经在 <code>&lt;img&gt;</code> 标签上的实验特性，如今终于被所有元素支持了。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-aspect-ratio.png" alt=""  /></p>
<h3 id="cascade-layer">Cascade Layer</h3>
<p><a href="https://developer.chrome.com/blog/cascade-layers/">https://developer.chrome.com/blog/cascade-layers/</a></p>
<p>Cascade Layers, 给 CSS 加上了层级的概念，layer 可以自由排列顺序，后面的比前面的有更高的优先级 (specificity)；还展示了下越来越复杂的 CSS 优先级关系图，其实也可以把每一级都当做一个 layer。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-cascade-layer.png" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-cascade-layer-1.png" alt=""  /></p>
<h3 id="container-queries">Container queries</h3>
<p>Container queries，在响应式中能够发挥重要作用，但我基本没听懂，未来应该会影响一些 CSS 框架的 API，到时候再来学习吧。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-container-queries.png" alt=""  /></p>
<h3 id="accent-color">Accent color</h3>
<p><a href="https://web.dev/accent-color/">https://web.dev/accent-color/</a></p>
<p>CSS accent-color，为 HTML 基本元素设定一个统一的色调，主流浏览器在一年内都争先恐后地实现了😂，毕竟这是最能体现自己颜值的功能。不知道能不能和操作系统的 accent-color 互通，这样体验就更一致了。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-accent-color.png" alt=""  /></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="arrayprototypeat">Array.prototype.at</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at</a></p>
<p>Array 增加了 at 方法，JavaScript 终于可以用类似 Python <code>list[-1]</code> 的写法了。这曾经是我刚学习 JavaScript 时觉得它不如 Python 最主要的原因。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-array-at.png" alt=""  /></p>
<h3 id="urlpattern">URLPattern</h3>
<p><a href="https://web.dev/urlpattern/">https://web.dev/urlpattern/</a></p>
<p>新类型 URLPattern，定义 URL 路径中的参数并解析出对应的 object。routing library 不用再写麻烦的正则了</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-urlpattern.png" alt=""  /></p>
<h3 id="structuredclone">structuredClone</h3>
<p><a href="https://web.dev/structured-clone/">https://web.dev/structured-clone/</a></p>
<p>有了 structuredClone, 再也不用写 JSON.parse JSON.stringify 这种扭曲心智的代码了，非常适合在面试官问到 deep clone 的问题时反将一军。还可以用来 clone 其他数据结构如 blobs, bitmaps, typed arrays。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-structuredclone.png" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-structuredclone-1.png" alt=""  /></p>
<h3 id="createimagebitmap">createImageBitmap</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap">https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap</a></p>
<p>createImageBitmap, 把 blob 直接转化成 Image 对象，改善了一直以来复杂而脆弱的写法。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-blob.png" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-blob-1.png" alt=""  /></p>
<h2 id="miscellaneous">Miscellaneous</h2>
<h3 id="chips">CHIPS</h3>
<p><a href="https://developer.chrome.com/docs/privacy-sandbox/chips/">https://developer.chrome.com/docs/privacy-sandbox/chips/</a></p>
<p>CHIPS 全称 Cookies Having Independent Partitioned State, 是 Cookie 在安全策略上的新特性，为 Set-Cookie 增加了 <code>Partitioned</code> 关键词。可以使特定 cookie 在 iframe 中只用于当前站点。自两年前 <code>SameSite</code> 关键词推广后，third-party cookie 只能选择全有或者全无，这次终于有了一个折中的选择。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-chips.png" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-chips-1.png" alt=""  /></p>
<h3 id="window-controls-overlay">Window controls overlay</h3>
<p><a href="https://web.dev/window-controls-overlay/">https://web.dev/window-controls-overlay/</a></p>
<p>Window controls overlay 是一组 <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web app manifests</a>, CSS, JavaScript API 的集合，实现了定制 PWA 窗口在 window bar 部分区域的显示效果，用于获得更有沉浸感的使用体验。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-wco.png" alt=""  /></p>
]]></content:encoded></item><item><title>PyYAML 使用技巧</title><link>https://reorx.com/blog/python-yaml-tips-zh/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/python-yaml-tips-zh/</guid><description>分享我在 Python 下使用 PyYAML 的技巧和代码片段，并介绍几个相关的库。</description><content:encoded><![CDATA[<blockquote>
<p>英文版: <a href="https://reorx.com/blog/python-yaml-tips/">Tips that may save you from the hell of PyYAML</a>
</p>
</blockquote>
<p>YAML 是一个被广泛使用的数据序列化和配置语言，作为一个开发者，总是不免和它打交道。
但处理 YAML 文档，尤其是使用 PyYAML 的过程总是非常痛苦。</p>
<p>这篇文章分享我在 Python 下使用 PyYAML 的技巧和代码片段，并介绍几个相关的库。</p>
<blockquote>
<p>注意：本文中的代码仅保证在 Python 3 下正常工作</p>
</blockquote>
<h2 id="总是使用-safe_loadsafe_dump">总是使用 <code>safe_load/safe_dump</code></h2>
<p>PyYAML 的 <code>load</code> 函数可以构造任意 Python 对象（Pickle 协议），这意味着一次 <code>load</code> 可能导致任意 Python 函数被执行。</p>
<p>为了确保应用程序的安全性，尽量在任何情况下使用 <code>yaml.safe_load</code> 和 <code>yaml.safe_dump</code>。</p>
<h2 id="保留字段顺序">保留字段顺序</h2>
<p>Python 3.7+ 中，<code>dict</code> keys 具备保留插入顺序的特性，所以通过 <code>yaml.safe_load</code> 得到的 <code>dict</code>，其 keys 顺序会与原始文件保持一致。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;---
</span><span class="s2">... c: 1
</span><span class="s2">... b: 1
</span><span class="s2">... d: 1
</span><span class="s2">... a: 1
</span><span class="s2">... &#34;&#34;&#34;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
</code></pre></div><p>当把 <code>dict</code> 导出为 YAML 字符串时，为 <code>yaml.safe_dump</code> 传递 <code>sort_keys=False</code> 来保留 keys 的顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>如果 Python 版本较低，或者你想确保代码能在更广泛的环境下工作，你可以使用 <a href="https://github.com/wimglenn/oyaml">oyaml</a> 库来代替 PyYAML 的 <code>yaml</code> 包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">oyaml</span> <span class="k">as</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><h2 id="优化列表项的缩进">优化列表项的缩进</h2>
<p>默认情况下，PyYAML 输出的列表缩进与其父元素一致。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
<span class="o">-</span> <span class="mi">1</span>
<span class="o">-</span> <span class="mi">2</span>
<span class="o">-</span> <span class="mi">3</span>
</code></pre></div><p>这并不是很好的格式，根据
<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">Ansible</a>
和 <a href="https://developers.home-assistant.io/docs/documenting/yaml-style-guide/#block-style-sequences">HomeAssistant</a>
等 YAML 书写规范，列表项应该缩进 2 空格。</p>
<p>这种格式也会对导致列表项不会被如 VSCode 等编辑器识别，进而无法使用编辑器的折叠功能。</p>
<p>要解决这个问题，使用如下代码片段，在代码中定义 <code>IndentDumper</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">IndentDumper</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">Dumper</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">increase_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indentless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndentDumper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">increase_indent</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>然后将它传递给 <code>yaml.dump</code> 的 <code>Dumper</code> 关键字参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dumper</span><span class="o">=</span><span class="n">IndentDumper</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
  <span class="o">-</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="mi">2</span>
  <span class="o">-</span> <span class="mi">3</span>
</code></pre></div><blockquote>
<p>注意，<code>yaml.safe_dump</code> 由于有自己的 Dumper class，传递此参数会造成冲突。</p>
</blockquote>
<h2 id="输出可读的-utf-8-字符">输出可读的 UTF-8 字符</h2>
<p>默认情况下，PyYAML 假设你希望输出的结果里只有 ASCII 字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;你好&#39;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="s2">&#34;</span><span class="se">\u4F60\u597D</span><span class="s2">&#34;</span>
</code></pre></div><p>这会让输出结果非常难以阅读。</p>
<p>在 UTF-8 足够普及的今天，直接输出 UTF-8 字符是非常安全的。
因此我们可以将 <code>allow_unicode=True</code> 传入 <code>yaml.safe_dump</code> 使 PyYAML 将 Unicode 转换成 UTF-8 字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">allow_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="n">你好</span>
</code></pre></div><h2 id="一些-yaml-相关的库">一些 YAML 相关的库</h2>
<h3 id="oyaml">oyaml</h3>
<p>Link: <a href="https://github.com/wimglenn/oyaml">https://github.com/wimglenn/oyaml</a></p>
<p>正如上文中提到的，oyaml 是 <code>yaml</code> 包的替换品，使 <code>dict</code> keys 的顺序在 dump/load 的时候得以保留。</p>
<p>oyaml 是一个单文件库，只有 <a href="https://github.com/wimglenn/oyaml/blob/d0195070d26bd982f1e4e604bded5510dd035cd7/oyaml.py">53 行代码</a>，因此使用起来非常灵活，你可以直接把它的代码复制到自己的项目中，然后根据自己的需求进行修改。</p>
<h3 id="strictyaml">strictyaml</h3>
<p>Link: <a href="https://github.com/crdoconnor/strictyaml">https://github.com/crdoconnor/strictyaml</a></p>
<p>有的人说 YAML 过于复杂和灵活，不是一个好的配置语言。但我认为这不是 YAML 的问题，而是使用方式的问题。如果我们限制程序只使用 YAML 的部分功能，YAML 其实可以变得像它设计的那般好用。</p>
<p>这就是 StrictYAML 的设计意图，它是一个类型安全的 YAML 解析器，实现了 YAML 规范说明中的一个<a href="https:c//hitchdev.com/strictyaml/features-removed">子集</a> 。</p>
<p>如果你对 YAML 的输入输出有较强的安全考虑，建议使用 StrictYAML 代替 PyYAML。</p>
<p>顺带一提的是，StrictYAML 的<a href="https://hitchdev.com/strictyaml/">文档站</a>有很多关于设计细节和配置语言思考的文章，非常值得一看。</p>
<h3 id="ruamelyaml">ruamel.yaml</h3>
<p>Link: <a href="https://yaml.readthedocs.io/en/latest/overview.html">https://yaml.readthedocs.io/en/latest/overview.html</a></p>
<p>ruamel.yaml 是 PyYAML 的一个分叉，于 2009 年发布并持续维护至今。</p>
<p>ruamel.yaml 的文档里详细说明了它和 PyYAML 的<a href="https://yaml.readthedocs.io/en/latest/pyyaml.html#yaml-1-2-support">差异</a>。
总体来说，ruamel.yaml 专注在 <a href="https://yaml.org/spec/1.2.2/">YAML 1.2</a>  上，对一些语法进行了优化。</p>
<p>ruamel.yaml 最令我感兴趣的特性是输入输出的 “round-trip”，可以最大程度地保留输入源的原始格式。官方文档中的定义是这样的：</p>
<blockquote>
<p>A round-trip is a YAML load-modify-save sequence and ruamel.yaml tries to preserve, among others:</p>
<ul>
<li>comments</li>
<li>block style and key ordering are kept, so you can diff the round-tripped source</li>
<li>flow style sequences ( ‘a: b, c, d’) (based on request and test by Anthony Sottile)</li>
<li>anchor names that are hand-crafted (i.e. not of the form<code>idNNN</code>)</li>
<li>merges in dictionaries are preserved</li>
</ul>
</blockquote>
<p>如果你有尽可能保留原始格式的需求，建议使用 ruamel.yaml 代替 PyYAML。</p>
<blockquote>
<p>在使用中我注意到 ruamel.yaml 的 safe load 方法 (<code>YAML(typ='safe').load</code>) 与 PyYAML 有些不同，它无法解析 flow style 的集合定义 (如 <code>a: {&quot;foo&quot;: &quot;bar&quot;}</code>)，这点没有在文档中提及，使用时须多加注意。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>YAML 有它好的地方和坏的地方。它易于阅读，初期的学习曲线非常平缓。
但 YAML 的规范说明非常复杂，不仅造成了使用中的混乱，也使不同语言的实现在很多细微的地方难以保持一致。</p>
<p>尽管有这些小毛病，YAML 仍然是我心中最好的配置语言。希望这篇文章所介绍的技巧能够帮助你避免问题，获得更好的开发和使用体验。</p>
]]></content:encoded></item><item><title>Tips that may save you from the hell of PyYAML</title><link>https://reorx.com/blog/python-yaml-tips/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/python-yaml-tips/</guid><description>Try to make our life with PyYAML easier.</description><content:encoded><![CDATA[<p>YAML is a data-serialization language that is widely used.
As a developer, I&rsquo;m always dealing with YAML from time to time.
But processing YAML, especially using PyYAML in Python is painful and full of traps.
Here I want to share some tips and snippets that can make your life with PyYAML easier.</p>
<blockquote>
<p>Code in this article is only guaranteed to work in Python 3</p>
</blockquote>
<h2 id="always-use-safe_loadsafe_dump">Always use safe_load/safe_dump</h2>
<p>YAML&rsquo;s ability to construct an arbitrary Python object makes it dangerous to use blindly.
It might be harmful to your application to simply <code>yaml.load</code> a document from an untrusted source such as the Internet and user input.</p>
<p>See from <a href="https://pyyaml.org/wiki/PyYAMLDocumentation#loading-yaml">PyYAML official documentation</a>:</p>
<blockquote>
<p><strong>Warning</strong>: It is not safe to call <code>yaml.load</code> with any data received from an untrusted source! <code>yaml.load</code> is as powerful as <code>pickle.load</code> and so may call any Python function.</p>
</blockquote>
<p>In short, you should always use <code>yaml.safe_load</code> and <code>yaml.safe_dump</code> as the standard I/O methods for YAML.</p>
<h2 id="keep-keys-in-order-loaddump">Keep keys in order (load/dump)</h2>
<p>In Python 3.7+, the order of dict keys is naturally preserved <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, thus the dict you get from <code>yaml.safe_load</code> has the same order of keys as the original file.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;---
</span><span class="s2">... c: 1
</span><span class="s2">... b: 1
</span><span class="s2">... d: 1
</span><span class="s2">... a: 1
</span><span class="s2">... &#34;&#34;&#34;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
</code></pre></div><p>When dumping dict into a YAML string, make sure to add keyword argument <code>sort_keys=False</code> to preserve the order of keys.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>If your Python version is lower, or you want to make sure the keys order preserving always works, you can use this library called <a href="https://github.com/wimglenn/oyaml">oyaml</a> as a drop-in replacement for <code>pyyaml</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">oyaml</span> <span class="k">as</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><h2 id="enhance-list-indentation-dump">Enhance list indentation (dump)</h2>
<p>By default, PyYAML indent list items on the same level as their parent.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
<span class="o">-</span> <span class="mi">1</span>
<span class="o">-</span> <span class="mi">2</span>
<span class="o">-</span> <span class="mi">3</span>
</code></pre></div><p>This is not a good format according to style guides like
<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">Ansible</a>
and <a href="https://developers.home-assistant.io/docs/documenting/yaml-style-guide/#block-style-sequences">HomeAssistant</a>.
It is also not recognized by code editors like VSCode, making the list items unfoldable in the editor.</p>
<p>To solve this problem, you can use the snippet below to define an <code>IndentDumper</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">IndentDumper</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">Dumper</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">increase_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indentless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndentDumper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">increase_indent</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>Then pass it to the <code>Dumper</code> keyword argument in <code>yaml.dump</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dumper</span><span class="o">=</span><span class="n">IndentDumper</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
  <span class="o">-</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="mi">2</span>
  <span class="o">-</span> <span class="mi">3</span>
</code></pre></div><blockquote>
<p>Note that <code>Dumper</code> cannot be passed to <code>yaml.safe_dump</code> which has its owner dumper class defined.</p>
</blockquote>
<h2 id="output-readable-utf-8-dump">Output readable UTF-8 (dump)</h2>
<p>By default, PyYAML assumes the user only wants ASCII code in the output,
so it converts UTF-8 characters to Python&rsquo;s Unicode representation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;你好&#39;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="s2">&#34;</span><span class="se">\u4F60\u597D</span><span class="s2">&#34;</span>
</code></pre></div><p>This makes the output hard to read for humans.</p>
<p>In the modern world, UTF-8 is widely supported, it&rsquo;s safe to write UTF-8 in the output.
Pass <code>allow_unicode=True</code> to <code>yaml.safe_dump</code> to enable that.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">allow_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="n">你好</span>
</code></pre></div><h2 id="no-default_flow_style-needed-dump">No <code>default_flow_style</code> needed (dump)</h2>
<p>Most of the time we don&rsquo;t want <a href="https://yaml.org/spec/1.2.2/#chapter-7-flow-style-productions">flow style productions</a> in the output (i.e. no JSON in YAML).
According to <a href="https://pyyaml.org/wiki/PyYAMLDocumentation#dictionaries-without-nested-collections-are-not-dumped-correctly">PyYAML documentation</a>, <code>default_flow_style=False</code> should be passed to <code>yaml.safe_dump</code> to achieve that.</p>
<p>After digging into the source code of the latest PyYaml (6.0), I find it is not needed anymore.
You should remove this keyword argument to keep the code cleaner and less confusing.</p>
<p><img loading="lazy" src="/blog/python-yaml-tips/images/yaml-dump-all.png" alt=""  /></p>
<h2 id="libraries">Libraries</h2>
<h3 id="oyaml">oyaml</h3>
<p>Link: <a href="https://github.com/wimglenn/oyaml">https://github.com/wimglenn/oyaml</a></p>
<p>As mentioned above, oyaml is a drop-in replacement for PyYAML which preserves dict ordering.</p>
<p>I suggest using oyaml if you already use PyYAML in your code.</p>
<p>It&rsquo;s worth mentioning that oyaml is a single-file library with only <a href="https://github.com/wimglenn/oyaml/blob/d0195070d26bd982f1e4e604bded5510dd035cd7/oyaml.py">53 lines of code</a>.
This makes it very flexible to use, you can just copy the code to your library and customize it according to your need.</p>
<h3 id="strictyaml">strictyaml</h3>
<p>Link: <a href="https://github.com/crdoconnor/strictyaml">https://github.com/crdoconnor/strictyaml</a></p>
<p>Some people say YAML is too complex and flexible to be a good configuration language,
but I think this is not the problem of YAML, but the problem of how we use it.
If we restrict our usage to only a subset of its features, it will be as good as it should be.</p>
<p>This is where StrictYAML came up. It is a type-safe YAML parser that parses and validates a <a href="https://hitchdev.com/strictyaml/features-removed">restricted subset</a> of the YAML specification.</p>
<p>I suggest using StrictYAML if you have strong security concerns for your application.</p>
<p>There are tons of great articles on the <a href="https://hitchdev.com/strictyaml/">documentation site</a> of strictyaml, definitely worth having a look at if you have thought about YAML and other configuration languages.</p>
<h3 id="ruamel-yaml">ruamel. yaml</h3>
<p>Link: <a href="https://yaml.readthedocs.io/en/latest/overview.html">https://yaml.readthedocs.io/en/latest/overview.html</a></p>
<p>ruamel.yaml is a fork of PyYAML, it was released in 2009 and continuously maintained in the past decade.</p>
<p>The differences with PyYAML are listed <a href="https://yaml.readthedocs.io/en/latest/pyyaml.html#yaml-1-2-support">here</a>. Generally, ruamel.yaml focuses on <a href="https://yaml.org/spec/1.2.2/">YAML 1.2</a>  with some opinionated enhancements for the syntax.</p>
<p>What interests me most is the ability to round-trip in the loading/dumping process. It works like black magic. Here&rsquo;s the explanation from ruamel.yaml documentation:</p>
<blockquote>
<p>A round-trip is a YAML load-modify-save sequence and ruamel.yaml tries to preserve, among others:</p>
<ul>
<li>comments</li>
<li>block style and key ordering are kept, so you can diff the round-tripped source</li>
<li>flow style sequences ( ‘a: b, c, d’) (based on request and test by Anthony Sottile)</li>
<li>anchor names that are hand-crafted (i.e. not of the form<code>idNNN</code>)</li>
<li>merges in dictionaries are preserved</li>
</ul>
</blockquote>
<p>I suggest using ruamel.yaml if you have the requirement to preserve the original content as much as possible.</p>
<blockquote>
<p>One thing I notice is that ruamel.yaml&rsquo;s <code>safe_load</code> method (<code>YAML(typ='safe').load</code>) cannot parse flow style collection (<code>a: {&quot;foo&quot;: &quot;bar&quot;}</code>), this is a undocumented difference with PyYAML.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>YAML has its good and bad. It&rsquo;s easy to read, the learning curve is mild at the beginning,
but the specification is complex, which not only causes chaos in practice, but also makes implementations in different languages inconsistent with each other in many trivial aspects.</p>
<p>Despite these quirks, YAML is still the best configuration language for me, and as long as we can use it properly, problems will be avoided and the experience will be much better.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>See <a href="https://docs.python.org/3/whatsnew/3.7.html#:~:text=the%20insertion%2Dorder%20preservation%20nature%20of%20dict%20objects%20has%20been%20declared%20to%20be%20an%20official%20part%20of%20the%20Python%20language%20spec.">What’s New In Python 3.7</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>重新开始使用 RSS 阅读器</title><link>https://reorx.com/blog/reinitiate-rss-reader/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/reinitiate-rss-reader/</guid><description>简单明确的尝试，带来意想不到的收获</description><content:encoded><![CDATA[<h2 id="不算成功的开端">不算成功的开端</h2>
<p>我曾经是一个糟糕的 RSS 用户。</p>
<p>早在 Google Reader 流行的时期，我就热衷于将我感兴趣的资讯网站和博客订阅到 Google Reader 中 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，期盼着能从这些信息中获得有价值的东西，却总是因为懒或者忘了而不能及时查看。随着未读数的增多，焦虑感越来越强烈，最后索性不再打开阅读器，安慰自己以后总会去看的，只要订阅了就行，沉浸在虚假的满足感中。</p>
<p>我就像一个喜欢屯书的人，在 RSS 阅读器这个书架上摆满了放上去就再也没动过的书<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>后来我认识到，自己得了信息资源的囤积病，经过长时间的反思后，我下决心清理 RSS 订阅源。</p>
<p>我删除了所有资讯类网站，只留下个人博客；去掉长期未更新的，并重新审视每个博客是否是我真正想要去阅读的。最终留下大约 30 多个 RSS 源，每周的更新量被控制在 10-20 之间。自此以后，我才真正做到阅读每篇更新，也没有再因为未读数量而焦虑了。</p>
<p>再之后，我看到许多人分享自己的 RSS 使用经验<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，将 RSS 作为获取信息的效率工具，聚合和筛选资讯，甚至成为 all-in-one 的信息输入渠道。这些文章偶尔会让我蠢蠢欲动，但因担心摄入压力过大而重蹈覆辙，我总是很快熄灭了尝试的想法。</p>
<p>就这样，我从一个糟糕的 RSS 用户，变成了一个克制但低效的用户，不再每天使用，只在有提醒时打开看看博客的更新。生活继续。</p>
<h2 id="重新发现-rss">重新发现 RSS</h2>
<p>最近我开始经常逛 V2EX 。我最早的活跃时期是 2010~2013，后来因为沉迷工作，和陌生人的交流欲降低，兴趣转移到 Twitter。今年自由工作后，思维又活跃起来，回过头来发现经过 10 年时间，V2EX 依然是国内最好的开发者社区。</p>
<p>V2EX 有着丰富的 RSS 支持，在 <a href="https://v2ex.com/notifications">V2EX  ›  提醒系统</a> 页面可以获得提醒的 RSS 订阅源。为了及时收到消息通知，我开始琢磨如何利用这一功能，于是整理了下需求：</p>
<ul>
<li>直接订阅 RSS，不需要借助第三方服务</li>
<li>支持 macOS 和 iOS，同步未读条目</li>
<li>简洁清爽的界面</li>
</ul>
<p>很快，我锁定了完美满足这三点的 <a href="https://github.com/Ranchero-Software/NetNewsWire">NetNewsWire</a></p>
<p><img loading="lazy" src="/blog/reinitiate-rss-reader/images/netnewswire-1.png" alt=""  /></p>
<p>NetNewsWire 发布于 20 年前，是 macOS 上历史最悠久的 RSS 阅读器。我虽然很早就知道它，却一直没有尝试，使用的是更受追捧的 Reeder，但 Reeder 最近的几次付费更新有些令人失望，没有什么有趣的变更，我也厌倦了它那软绵绵的 UI 风格。</p>
<p>NetNewsWire 让我眼前一亮，它使用 macOS 原生的 UI 组件，适应起来没有任何障碍。打开就算经典的三栏布局，没有多余的选项，让我感觉真正在使用一个信息组织工具，而非另一个漂亮的玩具。</p>
<p>Minimal and no distraction, 这是我对 NetNewsWire 的整体印象。我很快就爱上了它，逐渐把我其他几个正在摄取的信息源也添加了上去。</p>
<p>现在我的 RSS 订阅结构是这样的：</p>
<ul>
<li>
<p>V2EX</p>
<ul>
<li>
<p>节点</p>
<p>我只对一些特定的节点有逐条浏览的兴趣，V2EX 每个节点都可以输出 RSS，只需要将 <code>https://v2ex.com/feed/{node}.xml</code> 的 <code>{node}</code> 替换为节点的英文名即可。</p>
<ul>
<li><a href="https://v2ex.com/feed/create.xml">分享创造</a></li>
<li><a href="https://v2ex.com/feed/share.xml">分享发现</a></li>
<li><a href="https://v2ex.com/feed/programmer.xml">程序员</a></li>
</ul>
</li>
<li>
<p><a href="https://rsshub.app/v2ex/topics/hot">Top Topics</a></p>
<p>V2EX 本身没有最热话题的 RSS，幸运的是，RSSHub 提供了一个公开的源。</p>
</li>
</ul>
</li>
<li>
<p><a href="https://rsshub.app/telegram/channel/hacker_news_feed">Hacker News</a></p>
<p>Hackers News 的信息量太大，不适合直接订阅，好在 <a href="https://t.me/hacker_news_feed">hacker_news_feed</a> 这个 Telegram 频道对内容进行了筛选，只推送分数大于 100 的条目。同样要感谢 RSSHub，用它将 Telegram 频道转换成了 RSS feed。</p>
</li>
<li>
<p>Obsidian</p>
<p>作为 Obsidian 重度使用者和插件维护者，我非常关注社区的动向。Obsidian 社区信息主要来自于<a href="https://forum.obsidian.md/">官方 Discourse 论坛</a>和 <a href="https://www.reddit.com/r/ObsidianMD/">subreddit</a>。两者都是通过在 URL 后面加上 <code>.rss</code> 即可获得订阅源（如 <a href="https://forum.obsidian.md/c/share-showcase/9.rss">Showcase</a> 和 <a href="https://www.reddit.com/r/ObsidianMD.rss">ObsidianMD</a>）</p>
</li>
<li>
<p>提醒</p>
<ul>
<li>V2EX</li>
<li><a href="https://www.reddit.com/prefs/feeds/">Reddit Unread</a></li>
</ul>
</li>
</ul>
<p>经过一段时间的使用，我开心地发现，自己已经能每日有效摄入上百条信息而没有焦虑。我通常是在碎片时间打开手机观看，比如早上蹲马桶时、运动后和睡前。当遇到有趣的信息时，就点击 Star 收藏，如果特别需要关注或后续调研，就在 TickTick 添加一个对应的 TODO 项。要是忙起来积攒了许多未读，我就快速划过快速 Star，然后一次性 Mark All as Read。</p>
<h2 id="进一步优化">进一步优化</h2>
<p>V2EX 的程序员节点中经常出现 Java 相关的话题，但我的技能体系与 Java 无关，因此我想过滤掉这些对我而言无用的信息。</p>
<p>NetNewsWire 有一个相关的 <a href="https://github.com/Ranchero-Software/NetNewsWire/issues/1864">issue</a>，却并没有实现。Inoreader 和 Tiny Tiny RSS 等聚合器虽然支持，但我希望保持目前直接订阅原始 RSS 源的工作流，不想引入另一个工具增加复杂度。怎么办呢？</p>
<p>我决定自己开发一个轻量的 serverless 服务: <a href="https://github.com/reorx/rss-filter">rss-filter</a>。（现在还没有完成，所以读者朋友们可以不急着 star 鼓励。）</p>
<p>rss-filter 的大致设计如下：</p>
<ul>
<li>部署在 serverless 平台</li>
<li>通过 url 参数使用
<ul>
<li><code>rss</code>: rss url</li>
<li><code>exclude_text[]</code>: regex to exclude items from text (title, description, content)</li>
<li><code>exclude_text[]</code>: regex to include items from text
<ul>
<li>if both include and exclude are provided, apply include before exclude.</li>
</ul>
</li>
<li><code>cache_seconds</code>: seconds to cache the result</li>
<li><code>debug</code>: if true, return a json to debug</li>
<li><code>token</code>: prevent abuse by anonymous users</li>
<li><code>full_content</code>: fetch full content of each item</li>
</ul>
</li>
</ul>
<p>我设想  rss-filter 完成后，只需要简单的设定参数即可创造一个过滤后的 RSS 源。比如我想要从程序员节点过滤掉 Java 相关的条目，那么新的 RSS 源应为:</p>
<pre tabindex="0"><code>https://rss-filter.reorx.com/filter?rss=https%3A%2F%2Fv2ex.com%2Ffeed%2Fprogrammer.xml&amp;exclude_text=java%7Cspring+%3Fboot%7Clog4j&amp;cache_seconds=600
</code></pre><p>其中 <code>exclude_text</code> 为 <code>java|spring ?boot|log4j</code>，用正则匹配多种不同的关键词。</p>
<h2 id="一些思考">一些思考</h2>
<p>RSS 的用法因人而异，这篇文章主要目的是分享我个人的探索过程，希望带给读者一些借鉴。选择适合自己的，不要盲目追求别人看起来「高效」「强大」的工作流。</p>
<p>前几天 <a href="https://taoshu.in/">涛叔</a> 向我推荐了他的 <a href="https://taoshu.in/webfeed/web-feed.html">WebFeed</a> 插件 (for Firefox)，它把浏览器变成 RSS 阅读器，并能自动发现网站的 RSS 源。</p>
<p><img loading="lazy" src="/blog/reinitiate-rss-reader/images/webfeed.png" alt=""  /></p>
<p>我很喜欢它的 Web 与 RSS 一体的使用体验，这让我开始思考一个问题，为何近些年来 RSS 逐渐式微，主流浏览器厂商没有做任何相关的支持<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，只有少部分开源爱好者还在坚持使用并为 RSS 社区做出贡献。</p>
<p>我能想到的答案之一是，商业公司在控制和引导互联网生态，将公开流量变成自己的私域流量。而主流浏览器背后正好也都是商业公司。想象一下，如果所有内容都来自于独立博客的 RSS，作者可以直达受众，那内容分发市场的商业价值就没他们什么事了，更不用说将用户绑定在自己的平台上。</p>
<p>另一个原因可能是内容农场的肆虐，独立创作者很难靠自己将原创内容推广，内容农场却通过 SEO 技术将自己洗稿后的文章顶在了搜索结果的前面。关于这个问题，少数派有一篇文章值得一读： <a href="https://sspai.com/post/71637">少数派思考 007：关于 RSS</a>。</p>
<p>这是一场没有硝烟的战争，商业巨头们就像<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%86%E5%A4%A7%E5%8F%91%E7%8E%B0">地理大发现</a>时期的西方文明，在开放互联网的蒙昧之地大肆开拓殖民地。国外近些年来还有 Medium、Newsletter 等多种形式的内容分发模式百花齐放，国内已经被头条、微信、微博、百度完成瓜分和镇压，沦为没有生机的焦土。</p>
<p>但即使在这样的环境下，我还是希望能成为一个纯粹的内容创作者，为别人带来启发和帮助，为自己实现学习和思考的价值。</p>
<p>欢迎你来订阅我的博客:</p>
<p class="standout">
  <a href="https://reorx.com/feed.xml">https://reorx.com/feed.xml</a>
</p>

<p>最后推荐一篇文章 <a href="https://kevincox.ca/2022/05/06/rss-feed-best-practices/">RSS Feed Best Practises</a>， 如果你也是一名维护自己博客的 webmaster，可以了解下如何优化自己网站输出的 RSS。</p>
<p>比如加上 <code>&lt;link&gt;</code> tag 使 RSS URL 可以被主流工具自动发现:</p>
<pre tabindex="0"><code>&lt;link rel=alternate title=&quot;Blog Posts&quot; type=application/atom+xml href=&quot;/feed.atom&quot;&gt;
</code></pre><p>比如最好在 RSS 中附带全文：</p>
<blockquote>
<p>It is generally recommended to provide the full content of your posts in the feed. This is what most readers prefer. Atom has both <code>&lt;summary&gt;</code> element for readers that prefer it. For RSS and the Atom <code>&lt;content&gt;</code> element the full article should be included.</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>当时使用了一款 Chrome 插件，会自动检测当前网页可用的 RSS 源，如果有的话，会在地址栏里显示 RSS 图标，点击图标就能看见 Google Reader 中的目录分类，勾选即是将 RSS 订阅到指定分类中。我非常喜欢这个插件，可惜后来 Chrome 去掉了地址栏图标的 API，再也无法实现相似的功能了。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>亦像一个喜欢在 Steam 屯游戏的人，买了上千个游戏，但每天玩的还是 Dota 2, CS GO, GTA 5&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Chrome 背后的 Google，在手机 app 上实现了自己的 <a href="https://support.google.com/websearch/answer/2819496?hl=en&amp;co=GENIE.Platform%3DAndroid">Discover Feed</a> ; Edge 有一个叫 <a href="https://support.microsoft.com/en-us/microsoft-edge/organize-your-ideas-with-collections-in-microsoft-edge-60fd7bba-6cfd-00b9-3787-b197231b507e">Collections</a> 的功能，可以 “Follow” 一个网站的更新。那为什么我要说没有支持呢？因为这些都不是真正的 RSS，它们背后的技术可能还是 RSS ，但在产品上都刻意忽略 RSS、强调自己的名词。他们各造轮子实现自己的私有功能，仍是为了将用户关在自己的信息茧房中。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>我的 Vim 自动补全配置变迁史</title><link>https://reorx.com/blog/the-history-of-my-vim-completion-config/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/the-history-of-my-vim-completion-config/</guid><description>记录了从 2017 年至今，我的 Vim 自动补全配置的每次变更，从中窥见 Vim 生态发展的一角，也纪念这些曾经给我带来过便利，最终在技术发展中被轮替的插件</description><content:encoded><![CDATA[<p>Vim 是我系统学习的第一个终端编辑器，从学生时代至今，我几乎每天都会使用到它（长时间写前端代码时除外）。</p>
<p>自动补全（auto completion）大概是每个 Vim 用户在掌握了基本用法后，第一个想要进阶配置的功能。这篇文章记录了从 2017 年至今，我的 Vim 自动补全配置的每次变更，从中窥见 Vim 生态发展的一角，也纪念这些曾经给我带来过便利，最终在技术发展中被轮替的插件。</p>
<h2 id="before-2017">Before 2017</h2>
<p>2017 年我从 Vim 切换到 <a href="https://neovim.io/">Neovim</a>（下文简称 nvim），除了增加 nvim 特殊的 <code>init.vim</code>，基本沿用了以往的配置和插件。</p>
<p>彼时我使用的语言以 Python 为主，自动补全插件为 <a href="https://github.com/davidhalter/jedi-vim">jedi-vim</a>。</p>
<p>我对 jedi-vim 的了解最早可以追溯到 2012 年，那时还没有 LSP 的概念。开发者们针对自己的需求，编写如语法增强、文档查看、自动补全等各类插件，非常零散。jedi-vim 对这些插件的功能进行了重构和集成，提供了开箱即用的统一解决方案，一经推出便广受好评，成为使用 Vim 进行 Python 开发的标配。在后来的十年里，它的初心始终不变，得到持续的维护并沿用至今。</p>
<p>jedi-vim 的流行和长寿或许可以说明一个观点，即易用和功能全面才是软件流行的第一因素，无论它的实现有多么不优雅、效率有多么低，只要是能用的、可接受的就行，用户在使用体验上得到满足后，对于小问题的容忍度是相当高的。</p>
<h2 id="2017">2017</h2>
<p>还是 2017 年，在切换到 nvim 后不久，我发现了 <a href="https://github.com/Shougo/deoplete.nvim">deoplete</a> 插件，经过一番尝试将 jedi-vim 替换成了 deoplete + deoplete-jedi。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/0760ba6f7d11526e38e15b36a0d1db8709834825">0760ba6f7d11526e38e15b36a0d1db8709834825</a></p>
<blockquote>
<p><strong>use deoplete, remove jedi-vim</strong></p>
<p><em>committed on Jun 28, 2017</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;davidhalter/jedi-vim&#39;, { &#39;for&#39;: &#39;python&#39; }
</span><span class="gd"></span><span class="gi">+Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gi">+Plug &#39;zchee/deoplete-jedi&#39;, { &#39;for&#39;: &#39;python&#39; }
</span></code></pre></div><p>deoplete 的目标是提供一个通用的异步自动补全框架，这在设计理念上是一个巨大的进步。jedi-vim 虽然开箱即用，但却是一堆粘合在一起的 spaghetti code，不仅随着项目功能的增加变得越发庞大和迟缓（这是我想要离开 jedi-vim 的主要原因，文件一大各种操作都变得肉眼可见的慢），代码的可读性也非常糟糕，难以维护和参与。而 deoplete 本身并不提供针对任何语言的分析能力，只专注于与 nvim 的整合和 completion source 的调度，并且利用 nvim 的异步功能（后来 vim 8 也推出了自己的 async 接口），大大提升了补全的流畅度。</p>
<p>但 deoplete 也有着自身的局限性。首先配置变得复杂且麻烦，用户得理解其架构和设计，学会如何通过 deoplete 对接编程语言的 completion source。为了使检查结果的提示贴合自己的使用习惯，还要再去学习 completion source 的配置，每个语言的实现不同，配置也不一样。</p>
<blockquote>
<p>当时我却没有料到，配置复杂的问题在 LSP 时代不仅没能得到解决，反而变本加厉，直到本文完成时也依旧是使用者的巨大痛点</p>
</blockquote>
<p>deoplete 的第二个问题是，它只专注在 completion，缺少对于 go to definition 和显示 function siguature 等功能的支持，这对于从 jedi-vim 的 all-in-one 体验切换过来的我，显然是个巨大的落差。好在我找到了其他插件来解决这些问题。</p>
<p>对于 “go to definition”，通过装回 jedi-vim 并打开无补全模式可以解决。这样既可以使用 jedi-vim 提供的 go to definition 等辅助功能，也不会与 deoplete 的补全产生冲突。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">Plug</span> <span class="s1">&#39;davidhalter/jedi-vim&#39;</span><span class="p">,</span> { <span class="s1">&#39;for&#39;</span>: <span class="s1">&#39;python&#39;</span> }<span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; jedi (only for go to definition)</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">jedi</span>#<span class="nx">completions_enabled</span> <span class="p">=</span> <span class="m">0</span><span class="err">
</span></code></pre></div><p>对于 “function signature”，我找到了 deoplete 作者的另一个插件 <a href="https://github.com/Shougo/echodoc.vim">echodoc</a> 来实现。它将函数的签名信息显示在 cmd 区域，规避了 deoplete 占用 <code>completeopt</code> 导致编辑界面无法显示补全菜单以外的其他信息的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">Plug</span> <span class="s1">&#39;Shougo/echodoc.vim&#39;</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; echodoc</span><span class="err">
</span><span class="err"></span><span class="nx">set</span> <span class="nx">noshowmode</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">echodoc</span>#<span class="nx">enable_at_startup</span><span class="p">=</span><span class="m">1</span><span class="err">
</span></code></pre></div><h2 id="2018">2018</h2>
<p>2018 年是里程碑式的一年，<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> 的生态逐渐成熟，新的补全工具涌现。我对 LSP 感到相当兴奋和好奇，迫不及待地从 deoplete 更换到了对 LSP 有更好支持的 <a href="https://github.com/ncm2/ncm2">ncm2</a>。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/7a1442c2334673ac17162c101663e220ef43a3c8">7a1442c2334673ac17162c101663e220ef43a3c8</a></p>
<blockquote>
<p><strong>nvim: update completion plugins (a lot!)</strong></p>
<ul>
<li>move and reorg completion plugins definitions and configurations</li>
<li>use LSP completion instead of deoplete</li>
<li>remove eslint from ale_linters</li>
<li>enable virtualenv display for airline</li>
<li>still working on passing settings to pyls through LanguageClient-neovim</li>
</ul>
<p><em>committed on Dec 7, 2018</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gd">-Plug &#39;zchee/deoplete-jedi&#39;, { &#39;for&#39;: &#39;python&#39; }
</span><span class="gd"></span><span class="gi">+Plug &#39;ervandew/supertab&#39;
</span><span class="gi">+Plug &#39;ncm2/ncm2&#39;
</span><span class="gi">+Plug &#39;roxma/nvim-yarp&#39;
</span><span class="gi">+Plug &#39;autozimu/LanguageClient-neovim&#39;, { &#39;branch&#39;: &#39;next&#39;, &#39;do&#39;: &#39;bash install.sh&#39;, }
</span></code></pre></div><p>从设计理念上看，ncm2 与 deoplete 并无差别，都是通用的异步自动补全框架，唯有与<a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a>器的集成方式不同，deoplete 是自己的私有协议，ncm2 则拥抱了更加通用的业界标准 LSP。</p>
<p>我为 deoplete 的作者感到惋惜，他在 LSP 还不够成熟的时期，自己设计了与静态分析器的集成协议，构建了一个完整的补全插件生态<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。还写了很多小巧实用的插件，代码也非常优美，让人感到赏心悦目。但因为 LSP 的发展和新一代更加 LSP native 的补全插件的涌现，它已不再是当下的第一选择，势必因为历史包袱而逐渐被淘汰。</p>
<p>说回 ncm2，其实它也有许多瑕疵，印象中配置过程比 deoplete 还要痛苦，但当时已经是让 nvim 用上 LSP 的最好插件了。之后我对 JetBrains 和 VSCode 的使用频率变高，疏于对 nvim 插件的持续跟进，ncm2 于是一直服役到 2021 年。</p>
<p>ncm2 出现后没过多久，<a href="https://github.com/neoclide/coc.nvim">coc</a> 也诞生了，在 2019 年成为最受人关注的 vim 补全插件，国内也看到很多文章（似乎作者就是国内开发者）。由于长期受 Webpack 和 Nodejs 技术栈的折磨，当我了解到 coc 是 Nodejs 实现的，就放弃了尝试的念头 <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。一想到 jedi-vim 的缓慢，我实在没办法对同样大而全的 coc 抱有足够的信心<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<p>P.S. 从当年的笔记中找到了所参考的项目和文章：</p>
<ul>
<li><a href="https://www.reddit.com/r/neovim/comments/8ejfg0/state_of_lsp_servers/">https://www.reddit.com/r/neovim/comments/8ejfg0/state_of_lsp_servers/</a></li>
<li><a href="https://github.com/autozimu/LanguageClient-neovim">https://github.com/autozimu/LanguageClient-neovim</a></li>
<li><a href="https://github.com/prabirshrestha/vim-lsp">https://github.com/prabirshrestha/vim-lsp</a></li>
<li><a href="https://github.com/ncm2/ncm2">https://github.com/ncm2/ncm2</a></li>
<li><a href="https://github.com/palantir/python-language-server">https://github.com/palantir/python-language-server</a></li>
</ul>
<h2 id="2021">2021</h2>
<p>2021 年的某一天，因为 ncm2 长期存在的一个小问题（现在已经忘了），我一气之下再次打开了 deoplete 的项目页面，惊喜地发现它已经完善了对 LSP 的支持，于是立刻就开始迁移，换回了我更欣赏且代码品质更胜一筹的 deoplete。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/cd044fcda603ad5b9ee16bd4d7d7873c9ade9a31">cd044fcda603ad5b9ee16bd4d7d7873c9ade9a31</a></p>
<blockquote>
<p><strong>nvim: rework on languageserver &amp; python completion</strong></p>
<p><em>committed on Mar 26, 2021</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;ervandew/supertab&#39;
</span><span class="gd">-Plug &#39;ncm2/ncm2&#39;
</span><span class="gd">-Plug &#39;roxma/nvim-yarp&#39;
</span><span class="gd">-Plug &#39;autozimu/LanguageClient-neovim&#39;, { &#39;branch&#39;: &#39;next&#39;, &#39;do&#39;: &#39;bash install.sh&#39;,
</span><span class="gd"></span><span class="gi">+Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gi">+Plug &#39;prabirshrestha/vim-lsp&#39;
</span><span class="gi">+Plug &#39;mattn/vim-lsp-settings&#39;
</span><span class="gi">+Plug &#39;lighttiger2505/deoplete-vim-lsp&#39;
</span></code></pre></div><p>这次变更除了换回 deoplete ，还去掉了陪伴多年的 supertab，在抄了一段看不懂的配置后，实现了我更为习惯的 tab 键触发补全的方式。</p>
<h2 id="2022">2022</h2>
<p>在咖啡馆结束了一天的主要工作后，看着好友 <a href="https://github.com/xwjdsh">@iwendellsun</a> 流畅的 vim 操作，我问起了他的 nvim 自动补全配置，果然有许多我从未听过的东西。于是趁此机会赶紧向他请教，在他的指导下完成了 2022 年的配置升级。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/3de43d030ca40b498911c6752a7396af38202fe6">3de43d030ca40b498911c6752a7396af38202fe6</a></p>
<blockquote>
<p><strong>nvim: use nvim-cmp for completion</strong></p>
<p><em>committed on May 08, 2022</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gd">-Plug &#39;prabirshrestha/vim-lsp&#39;
</span><span class="gd">-Plug &#39;mattn/vim-lsp-settings&#39;
</span><span class="gd">-Plug &#39;lighttiger2505/deoplete-vim-lsp&#39;
</span><span class="gd">-Plug &#39;w0rp/ale&#39;
</span><span class="gd">-Plug &#39;rhysd/vim-lsp-ale&#39;
</span><span class="gd"></span><span class="gi">+Plug &#39;williamboman/nvim-lsp-installer&#39;
</span><span class="gi">+Plug &#39;neovim/nvim-lspconfig&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-nvim-lsp&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-buffer&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-path&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-cmdline&#39;
</span><span class="gi">+Plug &#39;hrsh7th/nvim-cmp&#39;
</span></code></pre></div><p>这次变更分以下几个方面：</p>
<ol>
<li>补全框架从 deoplete 变为 <a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a>，我还没细看，不过据说它就是现在的 meta &amp; state of the art.</li>
<li>LSP 集成从 vim-lsp 换成了 nvim-lspconfig。迟来的官方出品。</li>
<li>去掉了 ale 和 vim-lsp-ale。nvim-cmp 可以将 LSP client 返回的错误提示直接在行内显示，不需要再依赖 ALE 这个 linter 框架了。</li>
<li>Last but not least, 这些插件的配置语法几乎都是用 Lua 写的，这让用了 10 年 Vimscript 的我感到极度陌生和恐慌。</li>
</ol>
<p>相比之前的变更，这是唯一一次生搬硬套而非全部理解的，我想快速上车，免得被社区发展抛在了后面，现在实在没有太多精力可以悠闲地慢慢尝试。虽然有人指导免去了初次上手的痛苦，但可以预见的是，想要让这套插件和我的编程习惯完美契合，还有许多坑等着我去折腾呢。</p>
<p><strong>参考链接</strong>:</p>
<ul>
<li><a href="https://github.com/hrsh7th/nvim-cmp#setup">Setup | nvim-cmp</a>
<ul>
<li><a href="https://github.com/hrsh7th/nvim-cmp/wiki/List-of-sources">List of sources · hrsh7th/nvim-cmp Wiki</a></li>
<li><a href="https://github.com/hrsh7th/nvim-cmp/wiki/Example-mappings">Example mappings · hrsh7th/nvim-cmp Wiki</a></li>
</ul>
</li>
<li><a href="https://github.com/williamboman/nvim-lsp-installer#default-configuration">Default configuration | nvim-lsp-installer</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md">Server Configurations | nvim-lspconfig</a>
<ul>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#pylsp">pylsp</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#pyright">pyright</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#gopls">gopls</a></li>
</ul>
</li>
<li><a href="https://github.com/ray-x/lsp_signature.nvim">ray-x/lsp_signature.nvim: LSP signature hint as you type</a></li>
</ul>
<p><strong>参考配置</strong>:</p>
<ul>
<li><a href="https://github.com/xwjdsh/dotfiles/blob/master/nvim1/lua/plugins.lua">https://github.com/xwjdsh/dotfiles/blob/master/nvim1/lua/plugins.lua</a></li>
<li><a href="https://github.com/Avimitin/nvim/blob/master/lua/plugins/load.lua">https://github.com/Avimitin/nvim/blob/master/lua/plugins/load.lua</a></li>
</ul>
<h2 id="结语">结语</h2>
<p>Vim 的 LSP 插件生态还有许多有待优化的空间，开发者们对生产力的追求是永无止境的，下一个 5 年编辑器的体验会有着怎样激动人心的变化，我对此充满期待。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://github.com/Shougo/deoplete.nvim/wiki/Completion-Sources">https://github.com/Shougo/deoplete.nvim/wiki/Completion-Sources</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>其实 Nodejs 在服务端的性能不差，但 Webpack 和 Electron 给我造成的印象已经根深蒂固，使我看到 Nodejs 就会立刻联想到 slow and bloated.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>2022-05-09: 本文发布后，许多朋友向我推荐了 coc，并告知它的速度很快，修正了我在没有使用过的情况下产生的偏见认知。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>使用 Sonarr 搭建自动化追番系统</title><link>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</link><pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</guid><description>A complete guide to deploy and configure Sonarr + Jackett + FlareSolverr + qBittorrent to track and download anime shows automatically.</description><content:encoded><![CDATA[<p>作为一个懒人，我很少折腾 self-hosted 服务，对于追番这种娱乐化的需求，更是有什么用什么将就度日。所以许多年来一直是用 Bilibili 观看新番，中途也尝试过 ebb.io 这类小众服务，但最后都因为连接不畅或数据滞后等原因放弃了。</p>
<p>去年为了实现 Home Assistant 家电自动化 (<a href="https://twitter.com/novoreorx/status/1450334462177263618">tweet</a>)，我购买了一台 QNAP NAS，使家里有了 24 小时常驻的 Linux server 和 Docker host。年初由于 Bilibili 迟迟不上架《鬼滅之刃遊郭篇》，我又在 NAS 上安装了 Plex，将从 <a href="https://share.dmhy.org/">dmhy</a> 手动下载的影片串流到电视上观看。最近又逢 4 月新番播出，想到家里的基础设施逐渐完备，便动起了搭建自动追番系统的心思。以下便是对这次尝试的记录和总结，希望能帮助有同样需求的人解决问题、节省时间。</p>
<h2 id="使用-qnap-download-station">使用 QNAP Download Station</h2>
<p>本着尽量不增加新的系统来解决问题的思想，我首先研究了 QNAP 的下载器 Download Station，发现它自带 RSS 订阅功能，在进行一些手动配置后，即可完成自动追番和下载。</p>
<p>如果对这一章节不感兴趣，你也可以直接跳到 <a href="#%E4%BD%BF%E7%94%A8-sonarr-%E5%92%8C%E5%AE%83%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC">使用 Sonarr 和它的朋友们</a>。</p>
<h3 id="1-找到番剧的-rss-url">1. 找到番剧的 RSS URL</h3>
<p><a href="https://bangumi.moe/">Bangume Moe</a> 是我经常使用的资源站，它提供基于 tag 的 RSS 搜索功能，可以非常精确地定位到番剧在特定字幕组、语言、分辨率瞎的视频发布链接。</p>
<ul>
<li>首先在右上角的搜索框中输入想看的番剧名称，这里我使用「夏日重现」作为例子，可以看到下方自动匹配了 <code>Summertime Render</code> 这个 tag。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-2.png" alt=""  /></li>
<li>点击这个 tag，搜索结果中会出现许多不同字幕组发布的资源，我们选择其中一个字幕组「喵萌奶茶屋」的资源，在 Torrent Details 中，可以看到其标注的 tags，有 <code>喵萌奶茶屋</code>, <code>720p</code>, <code>chs-jpn</code> 等，妥善使用这些 tags 能够帮助我们缩小搜索结果范围
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-1.png" alt=""  /></li>
<li>将 <code>喵萌奶茶屋</code>, <code>chs-jpn</code> 添加到 Selected tags 中，现在我们一共有 3 个 tags，搜索结果缩短到了 2 条，已经非常清晰了，点击右上角的 RSS 图标即可得到用于订阅的链接。（美中不足的是，喵萌奶茶屋将 1080p 的资源错标为了 <code>720p</code>，不过这点我们可以在后面的下载管理器中解决）
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime.png" alt=""  /></li>
</ul>
<h3 id="2-将-rss-url-添加到下载器">2. 将 RSS URL 添加到下载器</h3>
<p>RSS 订阅是许多下载管理器的通用功能，如 Synology、qBittorrent 也都具有，使用方式与 Download Station 大同小异。</p>
<ul>
<li>打开 RSS Download Manager，将上一步得到的订阅链接复制到 Feed URL 中。Label 填写番剧名称，两个 Location 根据自己 NAS 的目录结构选择。点击 Apply 添加。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter.png" alt=""  /></li>
<li>添加完成后，打开 Filter Settings，它可以用于进一步过滤 RSS 返回的结果，避免下载不需要的资源。之前在进行资源搜索时，我们没能通过 tag 过滤掉 720p 的结果，在 Filter Settings 中，我们选择 1080p，这样 720p 就被忽略了。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter-1.png" alt=""  /></li>
<li>回到主界面，刷新添加的 RSS，可以看到两条结果中只有 1080p 被加入到下载列表。Status 为 Finished 代表下载完成，New 代表新添加到 RSS，但不在下载列表中。</li>
</ul>
<h3 id="小结">小结</h3>
<p><strong>Pros</strong></p>
<ul>
<li>无需配置和增加新系统</li>
<li>操作过程透明清晰，可控性强</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>步骤较为繁琐，需要在多个服务之间切换</li>
<li>下载的文件因为不符合 Plex 的格式需求，需要手动重命名才能在 Plex 上观看。但如果你使用 DLNA 这类基于文件系统定位视频的方式，倒是可以忽略这个缺点。</li>
</ul>
<h2 id="使用-sonarr-和它的朋友们">使用 Sonarr 和它的朋友们</h2>
<p>Download Station RSS 虽然解决了基本的温饱问题，但与真正的自动化之间显然还有很大差距，如果你想充分利用 NAS 的功能，在家庭多媒体设施上更进一步，请继续向下阅读，走进 Sonarr 和它的朋友们的世界。</p>
<h3 id="sonarr">Sonarr</h3>
<blockquote>
<p>Sonarr is a PVR (Personal Video Recorder) for Usenet and BitTorrent users. It can monitor multiple RSS feeds for new episodes of your favorite shows and will grab, sort and rename them.</p>
</blockquote>
<p><a href="https://wiki.servarr.com/sonarr">Sonarr</a> 是一个 PVR 系统，它可以监控多种信息源的剧集发布信息，对剧集进行自动下载、刮削和重命名。</p>
<p>Sonarr 是 Sick Beard 的继任者，Sick Beard 基于 Python 开发，曾经是最著名的 PVR 系统，但后来逐渐式微，后续虽然有 Sick Gear 等 fork，但最终都没能满足人们日益增长的看片需求，最后被一群 C# 爱好者们开发出 Sonarr 给替代了。经过多年发展，Sonarr 的软件质量趋于成熟和稳定，成为构架自动化的家庭多媒体中心不可缺少的组件。</p>
<p>Sonarr 一开始就以多系统低耦合的方式进行设计，这大大降低了代码的复杂度，使其更易于维护，也为其繁盛的社区发展提供了基石。为了满足不同的用户需求，Sonarr 的作者们开发一系列以 <code>rr</code> 或其他双字母结尾的工具，以至于这种命名方式成为了 Sonarr 生态圈的一个标识和事实标准。</p>
<h3 id="jackett">Jackett</h3>
<blockquote>
<p>Jackett works as a proxy server: it translates queries from apps into tracker-site-specific http queries, parses the html or json response, and then sends results back to the requesting software.</p>
</blockquote>
<p><a href="https://github.com/Jackett/Jackett">Jackett</a> 是一个代理，用于将 Sonarr 等系统对剧集信息的查询请求转译成各种 torrent tracker/indexer （即资源发布站）所支持的请求。Jackett 的产生是 Sonarr 社区架构合理性的一个体现，它接管了适配不同 indexer 接口的脏活累活，使 Sonarr 可以专注在任务调度和剧集管理上。</p>
<p>Jackett 既然被用作资源查询的网关，实现缓存功能就顺理成章了，这样一方面可以应对 Sonarr 频繁的查询需求，另一方面也减少了 indexer 站点的负载量，实现了双赢。因此虽然它不是一个必须的组件，但我强烈建议每个使用 Sonarr 的用户都安装它。</p>
<h3 id="flaresolverr">FlareSolverr</h3>
<blockquote>
<p>FlareSolverr is a proxy server to bypass Cloudflare and DDoS-GUARD protection.</p>
</blockquote>
<p><a href="https://github.com/FlareSolverr/FlareSolverr">FlareSolverr</a> 也是一个代理，它帮助 Jackett 解决向 indexer 的请求能否成功的问题。一些 indexer 为了保护自己免于 DDoS 攻击或减少爬虫请求，会使用 Cloudflare 或一些其他的安全防护服务，如果不做处理，直接请求很可能因触发人机验证而失败。FlareSolverr 就是为解决这类问题诞生的。</p>
<p>在 Jackett 中添加新的 indexer 时，会根据站点情况提示是否需要接入 FlareSolverr 以绕过站点的保护措施。</p>
<h3 id="qbittorrent">qBittorrent</h3>
<p>大部分影视资源都使用 BT 协议进行点对点传输，因此我们也需要一个 BT 下载器，qBittorrent 就是一个很好的选择，它的功能非常全面，且与 Sonarr 有很好的接入支持。如果你已经运行了其他下载器如 Aria2，甚至 QNAP/Synology 自带的 Download Station，那么你也可以参考 <a href="https://wiki.servarr.com/sonarr/supported#downloadclient">Sonarr 支持的下载器列表</a>，尝试进行配置。（我并没有成功使 Sonarr 和 QNAP Download Station 协同工作起来）</p>
<h3 id="部署说明">部署说明</h3>
<p>各个组件介绍完毕，现在让我们进入正题，了解如何配置和部署整个 Sonarr 服务组。</p>
<p>Sonarr 现代化地提供 Docker 镜像的部署方式，因此这个章节将会围绕 Docker 相关的技术进行说明。虽然 <a href="https://www.qnapclub.eu/en/qpkg/652">Qnapclub</a> 也有 Sonarr 的安装包，但经过一番糟心的尝试，最终我只得出一个结论，那就是以后部署任何服务，能 Docker 就尽量 Docker 吧。</p>
<p><details >
  <summary markdown="span">A failed attempt to install Sonarr by qpkg</summary>
  <ul>
<li>error after install: <code>MediaInfo Library could not be loaded libmediainfo.so.0 assembly:&lt;unknown assembly&gt; type:&lt;unknown type&gt; member:(null)</code></li>
<li>dependencies
<ul>
<li><a href="https://www.qnapclub.eu/en/qpkg/193">Qmono</a>: the package is crazily 3GB in size</li>
<li><a href="https://www.qnapclub.eu/en/qpkg/712">MediaInfoCLI</a>
<ul>
<li><a href="https://forum.qnap.com/viewtopic.php?t=147702">https://forum.qnap.com/viewtopic.php?t=147702</a></li>
<li>this is not useful at all</li>
</ul>
</li>
</ul>
</li>
</ul>

</details></p>

<p>我们的部署方案的基本原理是在自己的电脑上通过 Docker 和 Docker compose CLI 对远端 NAS 上的 Docker host 进行操作。这要求读者具备基础的 Docker 相关的知识。</p>
<p>QNAP/Synology 等 NAS 系统提供的 Docker host 与标准实现基本没有差异，因此我们可以直接使用 Docker 官方软件包提供的命令行工具。你也可以使用 NAS 提供的图形化界面，但一则那样在部署多个服务时非常不便，二则如果你了解了如何使用 Docker compose 部署，自然也可以反推到图形化界面的操作方式上。</p>
<h4 id="docker-context">Docker context</h4>
<p>为了与本地的 Docker host 区分开，我们要为 NAS 上的 Docker host 创建一个新的 <a href="https://docs.docker.com/engine/context/working-with-contexts/">context</a>。</p>
<blockquote>
<p><code>harrogath</code> 是我的 NAS 的 hostname，可以使用 IP 代替</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 创建 context</span>
docker context create harrogath

<span class="c1"># 更新 context 的配置信息</span>
docker context update harrogath --docker <span class="s2">&#34;host=tcp://harrogath:2376,ca=</span><span class="nv">$HOME</span><span class="s2">/.docker/ca.pem,cert=</span><span class="nv">$HOME</span><span class="s2">/.docker/cert.pem,key=</span><span class="nv">$HOME</span><span class="s2">/.docker/key.pem&#34;</span>
</code></pre></div><p>QNAP 的 Docker 需要通过证书来访问，因此要在 Container Station 的设置中下载证书。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-docker-certs.png" alt=""  /></p>
<p>完成 context 创建后，通过 <code>use</code> 命令切换到 context，之后所有的 Docker 命令都是与 NAS Docker 进行通讯</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="l">docker context use harrogath</span><span class="w">
</span><span class="w"></span><span class="l">docker context ls</span><span class="w">
</span><span class="w"></span><span class="l">NAME                TYPE                DESCRIPTION                               DOCKER ENDPOINT                               KUBERNETES ENDPOINT   ORCHESTRATOR</span><span class="w">
</span><span class="w"></span><span class="l">default             moby                Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                                         swarm</span><span class="w">
</span><span class="w"></span><span class="l">harrogath *         moby</span><span class="w">
</span></code></pre></div><h4 id="images">Images</h4>
<p>目前主要有两个组织在维护 Sonarr 及相关服务的 Docker 镜像，<a href="https://www.linuxserver.io/">linuxserver.io</a> 和 <a href="https://hotio.dev/">hotio.dev</a>, 我选择前者作为本次部署的镜像源。下面是使用到的镜像列表，可以在其页面上查看镜像的使用说明。</p>
<ul>
<li><a href="https://hub.docker.com/r/linuxserver/sonarr">linuxserver/sonarr - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/jackett">linuxserver/jackett - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/qbittorrent">linuxserver/qbittorrent - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/flaresolverr/flaresolverr">flaresolverr/flaresolverr - Docker Image | Docker Hub</a></li>
</ul>
<h4 id="hierarchy">Hierarchy</h4>
<p>Sonarr 和它的朋友们需要对 NAS 的存储进行读写，因此在运行服务之前，首先要理解并设计一个好用的目录结构。</p>
<p>我们需要在 NAS 上创建一个 AppData 目录，作为容纳所有服务产生的文件的根目录。AppData 所在的 Volume 建议选择适合存放大量媒体数据的精简卷 (Thin Volume)。</p>
<pre tabindex="0"><code>AppData
├── jackett
│   ├── config
│   └── downloads
├── qbittorrent
│   └── config
└── sonarr
    ├── config
    ├── downloads
    ├── media
    ├── torrents
    └── usenet
</code></pre><p>在 AppData 之下，依次为 sonarr, jackett, qbittorrent 创建目录，每个目录下必须有 <code>config</code> 子目录，用于存放配置文件。flaresolverr 由于是纯网络代理服务不需要对应目录存在。</p>
<p>下面对各个服务的 NAS 目录与容器内目录的映射关系进行说明</p>
<blockquote>
<p>表示为 <code>NAS Directory -&gt; Container Directory</code></p>
</blockquote>
<ul>
<li><strong>sonarr</strong>
<ul>
<li><code>sonarr/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，可在 Sonarr 管理界面向下创建子目录</li>
</ul>
</li>
<li><strong>qbittorrent</strong>
<ul>
<li><code>qbittorrent/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，与 sonarr 保持一致，以便 sonarr 在重命名或移动文件时可以直接使用 qbittorrent 返回的文件路径</li>
</ul>
</li>
<li><strong>jackett</strong>
<ul>
<li><code>jackett/config -&gt; /config</code>: 配置文件</li>
<li><code>jackett/downloads -&gt; /downloads</code>: 默认种子文件下载路径</li>
</ul>
</li>
</ul>
<h4 id="compose-file">Compose file</h4>
<p>以我正在使用的 <code>docker-compose.yml</code> 文件作为示例，你可以复制下来修改自己的版本，只需要将 <code>/share/CACHEDEV2_DATA/Misc/AppData</code> 替换为自己在 NAS 上创建的 <code>AppData</code> 路径即可。</p>
<p>端口的配置需要额外注意，这份配置中我尽量保持各服务默认配置端口不变，若与已有服务冲突，修改到未被占用的端口即可。例如 QNAP 自带的 Download Station 已占用 6881 端口，因此我将 qbittorrent 修改到了 16881 端口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">sonarr</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/sonarr</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8989</span><span class="p">:</span><span class="m">8989</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span><span class="w">      </span>- <span class="l">/etc/localtime:/etc/localtime:ro</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">jackett</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/jackett</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">9117</span><span class="p">:</span><span class="m">9117</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/downloads:/downloads</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">qbittorrent</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/qbittorrent</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">      </span>- <span class="l">WEBUI_PORT=8080</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/qbittorrent/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8080</span><span class="p">:</span><span class="m">8080</span><span class="w">
</span><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="w">
</span><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="l">/udp</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">flaresolverr</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">flaresolverr/flaresolverr</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">LOG_LEVEL=info</span><span class="w">
</span><span class="w">      </span>- <span class="l">LOG_HTML=false</span><span class="w">
</span><span class="w">      </span>- <span class="l">CAPTCHA_SOLVER=${CAPTCHA_SOLVER:-none}</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8191</span><span class="p">:</span><span class="m">8191</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></code></pre></div><h4 id="run">Run</h4>
<p>一切准备就绪，执行以下命令:</p>
<pre tabindex="0"><code>docker compose up
</code></pre><p>这会启动所有服务并 attach 到终端输出日志，方便查看服务的运行日志。等确认所有服务稳定运行后，加上 <code>-d</code> 参数使其运行在后台。</p>
<pre tabindex="0"><code>docker compose up -d
</code></pre><h3 id="使用说明">使用说明</h3>
<p>下面对各个服务的 Web UI 的使用方法进行说明，以我的 NAS hostname  <code>harrogath</code> 为例展示服务的访问地址。</p>
<h4 id="jackett-1">Jackett</h4>
<p>打开 <code>http://harrogath:9117</code>, Jackett 的界面展示如下:</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett.png" alt=""  /></p>
<p>使用方式非常简单，Jackett 已经将这个世界上绝大部分 indexer 都内置了，只需要点击 Add indexer 搜索并添加即可。除了部分有访问限制的 indexer 需要配置外，基本上都可以一路点击确认完成添加。之后在 Sonarr 中对接时，需要复制订阅 URL 和 API key，参照截图中所示即可。</p>
<p>我目前使用了 4 个 indexer，其中 Bangumi Moe 和 dmhy 用于下载动画番剧，EZTV 和 RARBG 用于下载美剧。</p>
<p>为了使 FlareSolverr 发挥作用，我们还需要将它的 URL 填在最下方的配置中，然后点击 Apply server settings 保存生效。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-1.png" alt=""  /></p>
<h4 id="qbittorrent-1">qBittorrent</h4>
<p>打开 <code>http://harrogath:8080</code>，使用默认用户名密码 <code>admin:adminadmin</code> 登录。</p>
<p>打开 Tools » Options，将 Default Save Path 修改为 <code>/data/downloads</code>。这样做的目的是为了使 qBittorrnet 所记录的文件路径与 Sonarr 保持一致，以便不需要额外配置就能使 Sonarr 的重命名功能正常工作。若你不希望修改下载路径，或使用的是其他下载器，可以参考 <a href="https://trash-guides.info/Sonarr/Sonarr-remote-path-mapping/">Remote Path Mappings</a> 来解决路径不一致的问题。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent.png" alt=""  /></p>
<p>在 Options 中切换到 BitTorrent 选项卡，将 Seeding Limits 下的 &ldquo;then&rdquo; 修改为 &ldquo;Pause torrent&rdquo;，这是为了避免 Sonarr 在删除种子时产生冲突。&ldquo;When ratio reaches&rdquo; 代表做种分享资源的比率。BT 协议提倡共享精神，既然从别人那里获取到自己想要的资源，理应做出回馈。推荐将分享率设置为 2.0，即上传量为下载量的两倍之后停止分享。如果你担心硬盘过度损耗，可以将比率降低。(<em>也可以修改为 0 关闭做种功能，如果克服了道德感的约束</em>)
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent-3.png" alt=""  /></p>
<h4 id="sonarr-1">Sonarr</h4>
<p>终于到了追番大计最核心的组件——Sonarr，但先不要急，在添加番剧前，还有一些设置要做。</p>
<ol>
<li>
<p>Indexers</p>
<ul>
<li>将先前在 Jackett 中添加的 indexers 逐个对接到 Sonarr，使用 Torznab 协议。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-1.png" alt=""  /></li>
<li>Bangumi.moe 的配置展示，URL 和 API Key 都是从 Jackett 中复制过来。需要注意的是， Categories 是影视剧的分类，应该留空，而在 Anime Categories 中勾选所有与番剧相关的分类项。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-2.png" alt=""  />
<ul>
<li>若不确定自己要搜索在资源属于哪个分类项，可在 Jackett 中使用 Manual Search 来确认
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-2.png" alt=""  /></li>
</ul>
</li>
<li>rarbg 的配置展示，由于 rarbg 是影视剧 indexer，我们需要在 Categories 中勾选分类项而将 Anime Categories 留空
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-3.png" alt=""  /></li>
</ul>
</li>
<li>
<p>Download Clients</p>
<ul>
<li>qBittorrent 配置展示。Host 最好填写 IP，使用 hostname 可能会失败。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-qbittorrent.png" alt=""  /></li>
</ul>
</li>
<li>
<p>Profiles</p>
<p>默认只有 English，需要添加一个中文的 Profile 以在添加番剧时设定语言。<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-profile.png" alt=""  /></p>
</li>
<li>
<p>Media Management</p>
<p>这个设置关系到下载的文件能否被 Plex 或其他 media server 识别，但别被眼花缭乱的设置项吓到， 我们只需要关心下图红框圈起的部分。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-mediamanagement.png" alt=""  /></p>
<ul>
<li>首先打开 Rename Episodes 功能</li>
<li>然后配置 Anime Episode Format 和 Season Folder Format，这代表番剧被重命名后的文件名格式和上级目录格式。你不用关心源文件的名称如何被 Sonarr 解析，你只用知道它自信并出色地完成了这项脏活，让我们可以使用变量定义想要的文件和目录名称。这里我使用的是 Plex 的 <a href="https://support.plex.tv/articles/naming-and-organizing-your-tv-show-files/">TV Show Files</a> 格式，实现的结果如下: <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/finder.png" alt=""  /></li>
<li>最后配置 Root Folders，它们在添加番剧的时候会用到，作为放置番剧的目录。你可以根据自己的需求设置多个，一般来说设置两个将影视剧和动画番剧分开存放即可。还记得我们在 <code>docker-compose.yaml</code> 中配置的目录映射吗？这里的目录 <code>/data/media/anime tv</code> 在 NAS 中对应的是 <code>AppData/sonarr/data/media/anime tv</code>，在 Plex 添加媒体库时不要忘了如何找到它。</li>
<li>Optional: 文件重命名时，Sonarr 默认采取移动策略，这样会导致 BT 下载器无法继续对资源做种，为了避免这种情况，在 Media Management 页面打开 Advanced Settings，找到并打开 &ldquo;Use Hardlinks instead of Copy&rdquo;，这样既保留了下载资源的原始路径，又不会额外占用硬盘空间。</li>
</ul>
</li>
<li>
<p>Connect</p>
<p>实现自动化追剧的目的是为了不需要人工检查剧集的更新情况，因此通知是必不可少的。Connect 可以连接许多通知服务，让你第一时间知道剧集何时上线，资源何时发布，何时完成下载、可以观看。下面说明如何对接 Telegram 获取通知信息。</p>
<ul>
<li>
<p>在 Telegram 搜索机器人 <code>@BotFather</code>，按照提示创建一个新的机器人，获取 API Token。我的机器人名为 <code>@reorx_notify_bot</code>。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-2.png" alt=""  /></p>
</li>
<li>
<p>创建一个群组，将 bot 加入到群组中，请求接口 <code>https://api.telegram.org/bot&lt;TOKEN&gt;/getUpdates</code>, 取出返回结果中的 <code>result[0].channel_post.chat.id</code> 作为 chat id</p>
<blockquote>
<p>方法来自 <a href="https://stackoverflow.com/a/61215414/596206">How to obtain Telegram chat_id for a specific user?</a></p>
</blockquote>
</li>
<li>
<p>在 Sonarr 中添加 Telegram connection，勾选自己关心的通知类型，一般至少会选择 On Download，代表新剧集下载完成的时间。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram.png" alt=""  /></p>
</li>
<li>
<p>配置好后，就可以通过 Telegram 第一时间掌握番剧的更新情况了。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-1.png" alt=""  /></p>
</li>
</ul>
</li>
</ol>
<h4 id="开始追剧">开始追剧</h4>
<p>配置完成，现在可以开始追剧了。下面以「盾之勇者成名录 第二季」为例说明在 Sonarr 添加番剧的过程。</p>
<p>打开 <a href="https://thetvdb.com/">TheTVDB.com</a>, 搜索到你想要追踪的番剧的页面 <a href="https://thetvdb.com/series/the-rising-of-the-shield-hero">The Rising of the Shield Hero</a>，获取 URL 中的最后一段 <code>the-rising-of-the-shield-hero</code> 作为在 Sonarr 搜索关键词。</p>
<p>打开 Sonarr，在左上角的 Search 框中输入 <code>the-rising-of-the-shield-hero</code>，点击搜索结果，进入添加番剧的界面。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-6.png" alt=""  /></p>
<ol>
<li>Root Folder: 选择先前在 Media Management 中设置的 <code>anime tv</code></li>
<li>Monitor: 由于我们只想看最近的第二季，因此选择 Only Latest Season</li>
<li>Quality Profile: 选择 HD-1080p 或其他你需要的格式/分辨率</li>
<li>Language Profile: 选择 Chinese</li>
<li>Series Type: 选择 Anime，这里对应的是添加 Indexer 时的 Anime Categories 选项，告诉 Sonarr 从 Indexer 的 Anime Categories 中搜索资源。如果使用默认的 Standard（对应 Indexer 的 Categories），将会导致无法搜索到资源。</li>
<li>Season Folder: 勾选，为了对应 Plex 要求的目录结构</li>
<li>Start search for missing episodes: 勾选，这会使 Sonarr 在添加番剧后立刻根据 Monitor 所设置的条件开始搜索资源。也可以在添加完成后在详情页手动点击触发。</li>
</ol>
<p>完成添加后，点击番剧进入详情页。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-7.png" alt=""  /></p>
<ol>
<li>点击放大镜图标对其所在的 Season 进行剧集搜索。</li>
<li>Status 列的图标说明
<ul>
<li>🕓: 尚未播出，不会进行监控</li>
<li>⚠️: 已播出，硬盘中还没有资源，正在进行监控</li>
<li>☁️ 或进度条: 已开始下载</li>
</ul>
</li>
<li>书签符号有填充代表该季处于正在监控状态，无填充代表未监控，可以点击手动设置为监控</li>
</ol>
<p>在 Sonarr 首页可以看到各个番剧的追踪状态，蓝色代表标记追踪的剧集都已下载完成，红色代表有缺失，正在持续监控中。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-5.png" alt=""  /></p>
<p>下载了一些资源后，我们打开 Plex，将 <code>anime tv</code> 对应的路径添加到「动画」Library 中，Plex 就会开始自动扫描文件、刮削元数据、下载中文字幕了。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex.png" alt=""  /></p>
<p>大功告成，在 Plex 上愉快看番吧☺️。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex-1.png" alt=""  /></p>
<h2 id="番外">番外</h2>
<h3 id="sonarr-的其他朋友们">Sonarr 的其他朋友们</h3>
<ul>
<li><a href="https://radarr.video/">Radarr</a>
Radarr 是 Sonarr 的兄弟项目，Sonarr 专精于追剧，Radarr 专精于追踪电影</li>
<li><a href="https://www.bazarr.media/">Bazarr</a>
Bazarr 用于自动下载字幕文件，由于 Plex 本身具有这个功能，以及大部分动漫资源都有内置字幕，因此不是特别有必要部署</li>
<li><a href="https://lidarr.audio/">Lidarr</a>
Lidarr 是音乐专辑的追踪和下载器，适用于喜欢收藏本地音乐文件的用户</li>
<li><a href="https://readarr.com/">Readarr</a>
Readarr 是电子书的追踪和下载器。我看书不多，偶尔需要看的书一般从 zlibrary 下载，Calibre 足够满足我的管理需求。</li>
</ul>
<h3 id="lunasea">LunaSea</h3>
<p><a href="https://www.lunasea.app/">LunaSea</a> 是一个 Sonarr 和 Usenet 生态圈的远程控制器，能让你在手机上查看 Sonarr / Radarr / Lidarr 的资源和放送时间表。</p>
<div class="image-size-control" style="height: 600px;">
  <img src="images/lunasea.jpeg" alt="">
</div>

<h3 id="seedboxio">Seedbox.io</h3>
<p>在得知我最近的折腾经过后，我的好朋友 <a href="https://wzyboy.im/">wzyboy</a> 向我科普了一种名为 <a href="https://en.wikipedia.org/wiki/Seedbox">Seedbox</a> 的 hosted service，提供开箱即用的 BT 下载和家庭媒体服务器，并能带来以下几点好处：</p>
<ul>
<li>免于折腾和维护诸多服务/服务器</li>
<li>发扬 BT 分享精神的同时无需损耗自己的硬盘</li>
<li>规避 P2P 下载资源的版权问题</li>
</ul>
<p>其中有一家服务商叫 seedbox.io, 它们的服务器包含本篇介绍的所有组件。如果你有兴趣的话，可以通过这个 <a href="https://panel.seedbox.io/aff.php?aff=1061">affiliate link</a> 注册和购买他们的服务。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/seedbox-apps.png" alt=""  /></p>
<h2 id="结语">结语</h2>
<p>Sonarr 和它的朋友们还有许多功能，本篇旨在引导用户完成最基本的自动化追番配置，就不一一介绍了，有兴趣的读者可以自行探索，欢迎在评论区留言分享。</p>
<p>近两年来，在家办公越来越融入到我们的生活，家庭网络和服务的搭建也逐渐从以往对 Geek 的刻板印象，变成或许没被意识到，但人人都有的需求。照片存储、数据备份、远程控制、环境监控、智能家居、多媒体娱乐…这些无一不是我们的日常所需。往后我会写更多这方面的文章，将我使用 NAS 改变生活方式的过程记录下来。The digital life has just begun.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://wiki.servarr.com/">WikiArr</a></li>
<li><a href="https://trash-guides.info/">TRaSH Guides</a></li>
</ul>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-04-19: created with &ldquo;使用 QNAP Download Station&rdquo;</li>
<li>2022-05-02: added &ldquo;使用 Sonarr 和它的朋友们&rdquo;, finished &ldquo;部署说明&rdquo;</li>
<li>2022-05-04: finished &ldquo;使用说明&rdquo; and the whole article</li>
</ul>
]]></content:encoded></item><item><title>Switch open files quickly in Obsidian</title><link>https://reorx.com/blog/obsidian-switching-open-files-quickly/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/obsidian-switching-open-files-quickly/</guid><description>Imagine a quick switcher with open files at the top.</description><content:encoded><![CDATA[<h2 id="the-problem">The problem</h2>
<p>since I use the “Sliding Panes” plugin, there’s always a bunch of files open in my Obsidian. Sometimes I switch to Obsidian with a very clear goal of opening a specific file, so I press Command+O and type in the file name to find it. Because I don’t want to check whether the file is open or not (rather say there’s no way to check open files quickly), I always press Command+Enter to open the file in a new pane. As this process repeats, some files will have redundant panes, the panes are bloated and the workspace ends up being a mess.</p>
<p><a href="https://github.com/darlal/obsidian-switcher-plus">Quick Switcher++</a> is a very helpful tool, it allows me to search for open editors by typing a special prefix (<code>edt</code> by default) in the quick switcher. But after using it a while, I still feel it’s not very intuitive, I want the “search any file and open it” action and “search for existing open file and activate it” to be combined into one thing to use.</p>
<h2 id="the-solution">The solution</h2>
<p>I forked Quicker Switcher ++ and added a new setting item called “Include open files”. When it’s enabled, the switcher modal shows all the open files at the top with a different color style. If the open file is chosen, make that pane active; Other suggestions behave the same as the original, opening the file in the active pane.</p>
<figure>
<video class="video-shortcode" preload="" controls>
  <source src="https://i.imgur.com/bGLcQKl.mp4" type="">
  There should have been a video here but your browser does not seem
  to support it.
</video>
</figure>

<p>I’ll test this new feature in my workflow for a while to see if it’s actually useful. Meanwhile, I’d love to hear from the Obsidian community. What do you think about it? Do you have a better idea for my problem? Feel free to leave a message to me.</p>
]]></content:encoded></item><item><title>A look into Heptabase's split writing experience</title><link>https://reorx.com/blog/heptabase-split-writing/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/heptabase-split-writing/</guid><description>The amazing UX Heptabase creates to help reading, thinking, and writing with heavy context efficiently</description><content:encoded><![CDATA[<p>Yesterday I found Heptabase&rsquo;s new introduction video: <a href="https://www.youtube.com/watch?v=oVXQx9sz_Wk">The 3-step knowledge workflow in Heptabase</a>.</p>
<p>Heptabase is the most promising note-taking app for me in recent years. The idea of combining bi-directional links, cards, and whiteboards together is mind-blowing. The word note-taking or knowledge base is not accurate to define it, in fact, it&rsquo;s more like a tool that aims for boosting the process of thinking.</p>
<p>Traditional note-taking tools are keen on providing more than enough ways for dumping your thoughts into notes, but lack methodologies on how to retrieve and use notes. The way Heptabase organizes and interacts with the data is what really empowers the user to think and write more efficiently.</p>
<p>Back to the video at the beginning, after watching it I noticed a very interesting feature. I can&rsquo;t stop thinking of it and really wish to have something similar in other note-taking or PMK tools like Obsidian (yeah, I&rsquo;m an Obsidian fan).</p>
<h2 id="the-feature">The feature</h2>
<p>Here&rsquo;s the walk though of that amazing feature:</p>
<ul>
<li>On a whiteboard, select several cards you would like to refer to </li>
<li>Right-click on them and choose &ldquo;Open in new tab&rdquo;, a new page with a left-right split layout appears. The first card selected shows on the left; others show on the right as a folded list. </li>
<li>Click on the <code>+</code> sign button on the top menu bar; a new card is created on the left side, and the card that previously shows on the left is automatically moved to the card list on the right.  </li>
<li>You can fold/unfold notes while browsing the right side, and drag&rsquo;n drop blocks to copy them to the left side. </li>
</ul>
<p>This is the best way I&rsquo;ve ever seen to think and write a note while referring to many other notes. In other note-taking tools, take Obsidian for example, I can split the panes, but it is not convenient to organize the workspace well for more than 3 notes. As new panes are growing, it will become more and more interruptive to switch back and forth.</p>
<p>Even if I managed to build up a tidy workspace, it&rsquo;s still very frustrating to switch to another context. Obsidian has the functionality to manage workspaces, but you have to manually save before switching, otherwise, the context will be missing. In Heptabase, all the workspaces are clearly shown in the sidebar, switching around is fast and easy as a breath.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It&rsquo;s a shock to me how easy and intuitive it could be in Heptabase to create a workspace and focus on writing. I believe anybody with note-taking experience could learn something from Heptabase&rsquo;s design.</p>
<p>Obsidian is still the best PKM tool for me. I&rsquo;m going to create a plugin to achieve a similar workflow in Obsidian, possibly by creating a special pane that can add and show notes in an accordion. Stay tuned for the updates.</p>
]]></content:encoded></item></channel></rss>