<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>digital-life on Reorx’s Forge</title><link>https://reorx.com/tags/digital-life/</link><description>Recent content in digital-life on Reorx’s Forge</description><image><url>https://reorx.com/images/forge-v2-compat.svg</url><link>https://reorx.com/images/forge-v2-compat.svg</link></image><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 14 Sep 2022 00:00:00 +0800</lastBuildDate><atom:link href="https://reorx.com/tags/digital-life/feed.xml" rel="self" type="application/rss+xml"/><item><title>使用 Railway 和 Supabase 零成本搭建 n8n 自动化平台</title><link>https://reorx.com/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0800</pubDate><guid>https://reorx.com/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/</guid><description>我的 n8n 「白嫖」托管新方案。</description><content:encoded><![CDATA[<p>在前文 <a href="/blog/sharing-my-footprints-automation/">使用自动化工作流聚合信息摄入和输出</a> 中，我介绍了如何在 NAS 提供的 Docker 环境安装 n8n，以及 n8n workflow 的使用方式。经过 3 个月的使用，我有了一些新的体会和尝试，重新设计了 n8n 的部署方案。本文将对这套新的方案进行说明，并分享数据迁移和第三方服务接入的实践。</p>
<h2 id="系统架构">系统架构</h2>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/system.svg" type="" alt=""  />

  <figcaption><p>系统架构图</p></figcaption>
</figure>

<p>我们所要搭建的这套服务有着如图所示的系统关系。</p>
<ul>
<li>Cloudflare: CDN 和 Proxy，用于加速网站访问，可选组件</li>
<li>Railway: PaaS 平台，提供 Docker 环境运行 n8n 的后端进程</li>
<li>Supabase: 作为数据库供 n8n 使用</li>
</ul>
<h2 id="完整部署流程">完整部署流程</h2>
<h3 id="supabase-创建数据库">Supabase: 创建数据库</h3>
<p>首先我们要在 <a href="https://supabase.com/">Supabase</a> 上注册一个账号，登入之后，点击 New project 创建新的数据库，命名为 n8n，注意要记住创建流程中输入的密码。</p>
<p>定位到 Project settings / Database / Connection info，将图中的信息记录下来即可进入下一步。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/database-info.png" type="" alt=""  />

  <figcaption><p>Supabase Connection info</p></figcaption>
</figure>

<h3 id="github-创建-repo">GitHub: 创建 Repo</h3>
<p>在 Railway 上部署服务最便捷的方式就是关联一个 GitHub repo，你可以 fork 我准备好的: <a href="https://github.com/reorx/n8n-on-railway">reorx/n8n-on-railway</a></p>
<p>这个 repo 的内容非常简单，其中最核心的就是 <code>Dockerfile</code>，只有一行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> reorx/n8n-custom</span><span class="err">
</span></span></span></code></pre></div><p>它的作用是基于 <a href="https://hub.docker.com/repository/docker/reorx/n8n-custom/">reorx/n8n-custom</a> 定义新的镜像。Railway 会使用这个 <code>Dockerfile</code> 来自动构建和部署服务。</p>
<p><a href="https://hub.docker.com/repository/docker/reorx/n8n-custom/">reorx/n8n-custom</a> 是我个人维护的镜像，基于版本 <a href="https://github.com/n8n-io/n8n/tree/n8n%400.193.5">0.193.5</a> 构建 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，目的是提前使用 <a href="https://github.com/n8n-io/n8n/pull/3354">PR</a> 的代码，以解决无法接入 Twitter 的问题。如果你对安全性有所担忧，也可以使用官方镜像 <a href="https://hub.docker.com/r/n8nio/n8n">n8nio/n8n</a>。</p>
<p>Repo 中还有 <code>example.env</code> 和 <code>export_workflow.sh</code> 两个文件，稍后我们会用到。</p>
<h3 id="railway-创建-project">Railway: 创建 Project</h3>
<p>注册或登入 <a href="https://railway.app/">Railway</a>，点击 New Project，选择 Deploy from GitHub repo，找到上一步创建的 repo 名字（n8n-on-railway）并选择，在下一个界面点击 Deploy now 开始部署。</p>
<h4 id="修改域名">修改域名</h4>
<p>不需要等待部署完成，我们直接进入 Project，点击代表 service 的卡片，打开 Settings。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/railway-domains.png" type="" alt=""  />

  <figcaption><p>Railway Settings Domains</p></figcaption>
</figure>

<p>可以看到 Railway 已经为我们的服务分配了一个 <code>.up.railway.app</code> 的四级域名，这将是你访问 n8n Web UI 的入口。如果你对域名没有要求，可以保持不变，将这个域名记录下来；如果你希望使用自己的域名，请参考 <a href="https://docs.railway.app/deploy/exposing-your-app#custom-domains">Exposing Your App</a> 文档中的 Custom Domains 章节进行设置。</p>
<p>下图是我的域名 <code>n8n.reorx.com</code> 在 Cloudflare 的配置信息。由于 n8n 是一个重前端交互的网站，需要加载很多庞大的 JavaScript 文件，直接通过 Railway 访问效率很低。使用 Cloudflare 的 Proxy 功能，可以让这些静态资源走 Cloudflare CDN，加速网站访问。因此我非常推荐用 Cloudflare 来托管 n8n 自定义域名。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1663094576.png" type="" alt=""  />

  <figcaption><p>Cloudflare DNS config for n8n.reorx.com</p></figcaption>
</figure>

<h4 id="设置环境变量">设置环境变量</h4>
<p>确认域名后，我们要切换到 Variables 页面对环境变量进行设置。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/railway-variables-editor.png" type="" alt=""  />

  <figcaption><p>Railway Variables Raw Editor</p></figcaption>
</figure>

<p>点击 Raw Editor 按钮，在弹出的输入框中粘贴 GitHub repo 中的 <code>example.env</code> 文件的内容，并调整各变量的值。其中：</p>
<ul>
<li><code>DB_</code> 开头的部分要根据 Supabase 的 Connection info 对号入座</li>
<li><code>VUE_APP_URL_BASE_API</code> 和 <code>WEBHOOK_URL</code> 填写上一步中所使用的域名。</li>
<li><code>N8N_ENCRYPTION_KEY</code> 是 n8n 加密 credentials 所使用的 key，请务必使用自己生成的随机字符串。如果没有这个变量，n8n 会随机生成一个并保存到文件系统中，在 Railway 的运行环境下重启后就会丢失，导致已保存的 credentials 无法解密 <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</li>
</ul>
<p>以上这些变量均可在官方文档 <a href="https://docs.n8n.io/hosting/configuration/">Configuration</a> 中找到详细说明。</p>
<p>编辑完成后，点击 Update Variables，Railway 会开始新的部署任务。至此，我们就完成了 n8n 在 Railway 上使用 Supabase 数据库的部署流程。</p>
<h2 id="初始化和数据迁移">初始化和数据迁移</h2>
<p>如果一切正常，等 Railway 的部署任务完成后，即可通过 <a href="#%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D">修改域名</a> 环节所确定的域名打开 n8n 网站。第一次访问时，n8n 会引导用户创建管理员账号，安全起见，请尽快完成这一步骤。</p>
<h3 id="workflow-导入">Workflow 导入</h3>
<p>如果你有已经备份好的 workflow，此时就可以进行导入了。先创建一个空的 workflow，然后在左侧菜单点击 &ldquo;Import from File&rdquo;，选择已有 workflow 的 json 文件即可完成导入。导入后，原 workflow 所使用的 credentials 会失效，需要手动选择或创建新的 credentials 才可以正常使用。</p>
<p><a href="https://github.com/reorx/n8n-workflows">reorx/n8n-workflows</a> 是我自己使用的一些 workflow，供读者参考。</p>
<h3 id="workflow-导出">Workflow 导出</h3>
<p>出于备份或分享的目的，我们可以导出 n8n 的 workflows。下面讲解如何将运行在 Railway 中的 n8n 的 workflows 进行导出。</p>
<ol>
<li>
<p>准备一个 Docker 环境，包含一个 Docker host 以及命令行工具 <code>docker</code></p>
</li>
<li>
<p>安装 Railway 的命令行工具 <code>railway</code> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
</li>
<li>
<p>进入 GitHub Repo 所在的目录，执行 <code>railway link</code>，选择 n8n 对应的 project</p>
</li>
<li>
<p>执行如下命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">EXPORT_ROOT</span><span class="o">=</span>/path/to/volume railway run bash export_workflows.sh
</span></span></code></pre></div><p>其中 <code>EXPORT_ROOT</code> 是文件输出路径，将作为 volume 挂载到所要执行的 Docker 容器中。</p>
<p><code>railway run</code> 会将线上 project 的环境变量注入到当前 shell 中，使最终执行的脚本 <code>export_workflows.sh</code> 使用与线上一致的环境。</p>
<p>执行完毕后，即可在 <code>EXPORT_ROOT</code> 下找到当前日期命名的目录，其中的 json 文件即为导出的 workflows。这些文件是以 workflow 的 id 命名，你还可以使用我的 <a href="https://github.com/reorx/n8n-workflows/blob/master/get_workflows.py">get_workflows.py</a> 脚本修改文件名为实际的可读名称，并清理其中的无用数据:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">python get_workflows.py <span class="nv">$EXPORT_ROOT</span>/n8n-<span class="k">$(</span>date +%Y%m%d<span class="k">)</span> workflows/
</span></span></code></pre></div></li>
</ol>
<p>这个导出方法同样适用于 NAS Docker 中部署的 n8n，只需要去掉 Railway 相关的步骤即可。</p>
<h2 id="接入第三方服务">接入第三方服务</h2>
<p>n8n 的强大在于它内置了很多线上服务的 Integrations，仅需简单的配置即可完成接入。虽然官方有文档说明，但仍然有一些不大不小的坑，这里记录下我的一些配置技巧，希望能帮助你节省一些时间。</p>
<h3 id="google">Google</h3>
<p>Google 的接入相对比较复杂，请跟随文档 <a href="https://docs.n8n.io/integrations/builtin/credentials/google/">Integrations: Google</a> 的详细说明进行操作。这里只说下文档中没有提到的一个注意事项。</p>
<p><del>在创建 OAuth consent screen 后，要将 Publishing status 设为 Testing，否则 Google 的 OAuth 页面会显示应用未通过审核的警告。还要将想要接入的 Google 账号邮箱加入 Test users 列表，否则无法再 Testing 模式下通过 OAuth 验证。</del></p>
<blockquote>
<p>以下内容为 2022-09-24 更新</p>
</blockquote>
<p>在创建 OAuth consent screen 后，要将 Publishing status 设为 <strong>Production</strong>，否则一周后 OAuth token 就会过期 <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>。虽然这种方式会导致 OAuth 认证页面显示应用未通过审核的警告（点击左下角 &ldquo;Go to …&rdquo; 可以绕过），但总好过每周重新连接一次的麻烦。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1663950818.png" type="" alt=""  />

  <figcaption><p>OAuth consent screen: Publishing status</p></figcaption>
</figure>

<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1663950640.png" type="" alt=""  />

  <figcaption><p>OAuth warning for Production app without verification</p></figcaption>
</figure>

<h3 id="twitter">Twitter</h3>
<p>Twitter 由于这两年来 Developer Portal 的大幅改造，实际操作中可能与文档 <a href="https://docs.n8n.io/integrations/builtin/credentials/twitter/">Integrations: Twitter</a> 有许多不一致，但只要确保以下几点，应该可以避免大部分问题。</p>
<ol>
<li>确保创建的 App 在 &ldquo;Standalone app&rdquo; 这个分类下</li>
<li>确保 &ldquo;User authentication settings&rdquo; 按下图所示配置 
<figure class="center align-center">
  <div class="image-size-control" style="height: 500px;">
    <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1662887928.png" type="" alt=""  />
  </div>

  <figcaption><p>User authentication settings</p></figcaption>
</figure>
</li>
<li>确保向 n8n 填入的 Consumer Key 和 Consumer Secret 来自下图中红框所在的位置 
<figure class="center align-center">
  <div class="image-size-control" style="height: 500px;">
    <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1662887896.png" type="" alt=""  />
  </div>

  <figcaption><p>Consumer Keys</p></figcaption>
</figure>
</li>
</ol>
<h3 id="pinboard">Pinboard</h3>
<p>n8n 没有内置 Pinboard 接入，不过 <a href="https://www.pinboard.in/api/">Pinboard API</a> 设计非常简洁，我们可以手动实现接入。</p>
<p>创建 credential 时选择 &ldquo;Query Auth&rdquo;，向 &ldquo;Name&rdquo; 填入 <code>auth_token</code>，向 &ldquo;Value&rdquo; 填入从 <a href="https://pinboard.in/settings/password">Pinboard password</a> 页面得到的 API Token。完成后，即可在 HTTP Request node 中使用。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1663144028.png" type="" alt=""  />

  <figcaption><p>HTTP Request node with pinboard Query Auth</p></figcaption>
</figure>

<h3 id="github">GitHub</h3>
<p>n8n 虽然有内置的 GitHub 接入，但并非所有 API 都被支持，因此我建议使用 HTTP Request 手动配置验证。</p>
<p>GitHub 提供 PAT (Personal Access Token)，与 Pinboard 的 API Token 类似，相比 OAuth 更容易配置。</p>
<p>GitHub API 支持在 HTTP Header 中通过 <code>Authorization</code> 字段进行验证，其值为 <code>Bearer</code> + PAT <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>。</p>
<p>首先打开 <a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>, 点击 Generate new token，勾选所需权限。具体根据所要请求的 API 来决定，一般来说至少要勾上 <code>repo</code> 和 <code>user</code>。创建完成后复制结果即为 <code>$PAT</code>。</p>
<p>然后在 n8n 中创建 Header Auth，&ldquo;Name&rdquo; 填写 <code>Authorization</code>，Value 填写 <code>Bearer $PAT</code>（将 <code>$PAT</code> 替换为上一步的结果）。完成后，即可在 HTTP Request node 中使用。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/0-cost-self-hosted-n8n-with-railway-and-supabase/images/1663145536.png" type="" alt=""  />

  <figcaption><p>HTTP Request node with GitHub Header Auth</p></figcaption>
</figure>

<h2 id="总结">总结</h2>
<p>随着 PaaS 和 Serverless 平台的兴起，在很多场景下它们都能够代替 NAS 成为自托管服务的最佳选择。个人使用免费额度一般都绰绰有余，无论对于想要快速试验新产品的开发者，还是喜欢体验 SaaS 服务的业余爱好者，现在都是一个非常好的时代。</p>
<p>之前将 n8n 部署在 NAS 上平均每天会有几十条错误报警，一部分是 SQLite 在机械硬盘上频繁读写触发事务锁竞争，一部分则是代理不稳定造成网络访问失败。在迁移到 Railway + Supabase 的方案后，两个问题都得到了解决。PostgreSQL 有着更好的连接和并发性能；而 Railway 的运行环境本身就处于外网，自然也不会遇到代理失效的问题。</p>
<p>Railway 也可以提供包含 PostgreSQL 的全托管方案，但独立运行 PostgreSQL 不仅资源消耗大，显著占用免费额度，而且不如 Supabase 这种专业的 DaaS 稳定和安全。Cloudflare 的免费 CDN 服务，补充了 Railway 分发能力的不足，也降低了出口带宽的成本。几个平台相互搭配，取长补短，使新的方案可以用最低的成本实现最佳的性能和体验。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>代码见 <a href="https://github.com/reorx/n8n/tree/self-use">https://github.com/reorx/n8n/tree/self-use</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>论坛里有人遇到过同样的问题: <a href="https://community.n8n.io/t/credentials-error/181">https://community.n8n.io/t/credentials-error/181</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>参考官方文档 <a href="https://docs.railway.app/develop/cli">CLI</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://community.n8n.io/t/youtube-refresh-token-expired/5319">YouTube Refresh Token Expired? - Questions - n8n</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>见 GitHub 文档 <a href="https://docs.github.com/en/rest/guides/getting-started-with-the-rest-api#authenticating">Getting started with the REST API - Authenticating</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>2022 年 9 月苹果发布会观后感</title><link>https://reorx.com/blog/2022-09-apple-event/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0800</pubDate><guid>https://reorx.com/blog/2022-09-apple-event/</guid><description>论 iPhone 重量变化与我的购买决策之间的关系</description><content:encoded><![CDATA[<p>刚过完 2022 年的科技春晚——苹果9月发布会，我也照例观看（指阅读 ifanr 的汇总文章）了一遍，大致总结如下：</p>
<table>
<thead>
<tr>
<th>产品</th>
<th>买点</th>
<th>售价</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 14 Pro</td>
<td>💊 灵动岛</td>
<td>￥7999</td>
</tr>
<tr>
<td>Apple Watch Ultra</td>
<td>🔋 双倍续航</td>
<td>￥6299</td>
</tr>
<tr>
<td>Airpods Pro 2</td>
<td>📡 如 AirTag 般方便寻找</td>
<td>￥1899</td>
</tr>
</tbody>
</table>
<p>总价是￥16197，好贵！相当于一台中配 MacBook Pro。但这么一想，反而不觉得贵了，同样的价格可以得到三个不同产品的体验，简直太划算了不是吗 😏</p>
<p>我对苹果产品的购买通常从三点进行考量，一是产品设计是否有颠覆式的变革，或者足够创新有趣，iPhone 14 Pro 的灵动岛显然满足这点，并且是业界独一无二的。许多人（如罗胖）说这是硬件落后倒逼软件妥协，有道理，但我不会因此否认它的人机交互设计价值。</p>
<p>第二点则是目前的设备是否拖累了我的生产力，新的设备能否做出有效的提升。我手里的 iPhone 11 Pro 还挺顺畅，iPhone 14 Pro 也没有 life-saving 级的变化，就看库克啥时候按下降频按钮了。</p>
<p>最后一点, 是手机的大小和重量，而且不容妥协。我非常爱惜自己的右手和手腕，手机太大握持不舒服，太重则手腕容易疲劳。在 iPhone X 发布时就对我产生了巨大的考验，好在 6.1 英寸我还能勉强接受，后续也都维持了这个大小。因此每次看新 iPhone 的 spec，我总是先关注重量。下面是我整理的 iPhone 从 X 到今年的 14，重量变化的表格（X 算作初代的 Pro）：</p>
<table>
<thead>
<tr>
<th></th>
<th>iPhone Pro<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></th>
<th>iPhone<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>174g</td>
<td>-</td>
</tr>
<tr>
<td>11</td>
<td>188g</td>
<td>194g</td>
</tr>
<tr>
<td>12</td>
<td>189g</td>
<td>164g</td>
</tr>
<tr>
<td>13</td>
<td>204g</td>
<td>174g</td>
</tr>
<tr>
<td>14</td>
<td>206g</td>
<td>172g</td>
</tr>
</tbody>
</table>
<p>画成图表看更加直观：</p>
<div class="image-size-control" style="width: 100%;">
  <img loading="lazy" src="/images/blog/iphone-weight-chart.svg" type="" alt=""  />
</div>

<p>你一定想不到，当时使我决定购买 iPhone 11 Pro 而不是 iPhone 11 的原因，是前者比后者轻了 6 克！可惜的是，Pro 系列的重量在之后逐年递增，不再是我的首选项了。希望明年不带 Pro 的 iPhone 也能拥有灵动岛，这样我就会乖乖掏钱啦（库克！）。</p>
<p>再看看另外两个产品。Watch Ultra 的情况和 iPhone 14 Pro 差不多，不予考虑。Airpods Pro 2 则决定购买，已经在今晚抢到。现在我还在用着几年前买的 Airpods 2，有些旧了，正好换成最新产品。何况又有了可以像 AirTag 那样去寻找的便利性呢。</p>
<p>关于苹果，从 iPhone 11 到 13 我一直都不觉得有什么值得称道的创新，今年终于让我有些刮目相看。但我不觉得这是什么值得吹捧的事情，作为地球上最有钱的科技公司之一，本就应以引领行业发展为己任，不然赚那么多钱是干什么吃的。有人会说，资本家本就是以最低成本创造最大收益为目标呀。但这个世界还是需要有理想的人存在，哪怕只有些许的人、些许的理想，这样人类文明才不会太过无趣不是吗。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Specs: <a href="https://support.apple.com/kb/sp770?locale=en_US">iPhone X</a>, <a href="https://support.apple.com/kb/SP805?locale=en_US">iPhone 11 Pro</a>, <a href="https://support.apple.com/kb/SP831?locale=en_US">iPhone 12 Pro</a>, <a href="https://support.apple.com/kb/SP852?locale=en_US">iPhone 13 Pro</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Specs: <a href="https://support.apple.com/kb/SP804?locale=en_US">iPhone 11</a>, <a href="https://support.apple.com/kb/SP830?locale=en_US">iPhone 12</a>, <a href="https://support.apple.com/kb/SP851?locale=en_US">iPhone 13</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>种草无线便携路由器</title><link>https://reorx.com/blog/travel-routers/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0800</pubDate><guid>https://reorx.com/blog/travel-routers/</guid><description>介绍无线便携路由器 Travel Router 的功能和产品，并对比说明它与 Wi-Fi 信号放大器和随身 Wi-Fi 的差异。</description><content:encoded><![CDATA[<p>时间回到两个月前的某天，和好友 <a href="https://github.com/xwjdsh">@iwendellsun</a> 一起在咖啡馆工作时，他提出了一个问题：有没有一种路由器，它可以先连接一个已有的 Wi-Fi，再发射一个新的 Wi-Fi 供自己的设备连接？</p>
<p>我立刻理解了这个诉求的来源。咖啡馆、图书馆等场所的公共 Wi-Fi 一般都有身份验证机制，连接超过一个设备就会感觉很不方便，更不用说每个设备都还要独立设置代理；如果多人在一起工作，联机调试很可能会遇到公共 Wi-Fi 的端口限制而无法成功。我们对这个需求讨论了一番，但两人都缺乏对这类产品的认识，便不了了之。</p>
<p>最近在 Twitter 上看到 <a href="https://twitter.com/pengchujin">@酱紫表</a> 分享了一款产品，突然意识到这可能正是我们想要的东西:</p>
<div class="tweet social-quote">
  <div class="title">
    <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>

    
  </div><blockquote class="twitter-tweet" data-dnt="true"><p lang="zh" dir="ltr">收到了一款非常有趣的产品— GL-AXT1800，我喜欢这款路由器的地方实在有点多：迷你的体积带出门很方便、高通 IPQ6000 的 CPU 性能足够强大、出厂自带 openwrt 和 uboot 真的方便、type c 电源口、支持 usb 3.0 还有 Wi-Fi 6、还自带 pwm 风扇。 <a href="https://t.co/5gAFEdiGkH">pic.twitter.com/5gAFEdiGkH</a></p>&mdash; 酱紫表 (@pengchujin) <a href="https://twitter.com/pengchujin/status/1542120681520844801?ref_src=twsrc%5Etfw">June 29, 2022</a></blockquote>

</div>


<p>虽然没有提及这款名为 <a href="https://www.gl-inet.com/products/gl-axt1800/">GL-AXT1800</a> 的路由器是否可以连接已有 Wi-Fi，但既然设计的这么小巧便携，应该是针对出门在外的应用场景吧？我如此寻思，注意到它在 GL.iNet 的产品矩阵中属于 Travel Router 这一分类，于是顺着这个关键词进行了一番搜索，果然发现这类产品大都有着和我们的需求一致的应用场景。</p>
<p>我随后去阅读了 GL.iNet 的<a href="https://docs.gl-inet.com/en/4/user_guide/">官方使用手册</a>，弄清了 GL-AXT1800 所支持的四种连接互联网的模式：</p>
<ul>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_ethernet">Connect to the Internet via an ethernet cable</a></p>
<p>通过网线连接互联网。GL 的路由器都有一个 WAN 口，这种用法与通常的家用路由器一致，连接在光猫或已有路由器的后面。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_repeater">Connect to the Internet via an existing Wi-Fi</a></p>
<p>通过已有 Wi-Fi 连接互联网。这就是本文一开始所提到的在咖啡馆中的使用场景，将公共 Wi-Fi 扩展成为相对安全可控的局域网。</p>
<p>一些公共 Wi-Fi 要求对手机号/身份证等进行验证方可连接互联网，使用无线便携路由器是否会影响验证流程呢？我初步判断是不会，这种验证发生在连接 Wi-Fi 时的密码验证之后，此时无线便携路由器已完成了连接已有 Wi-Fi 并创建新的局域网的工作，假设公共 Wi-Fi 的 IP 是 192.168.1.1，无线便携路由器是 192.168.50.1，我们访问互联网触发的对 192.168.1.1 验证界面的访问是完全没有问题的，类似在家庭双层 NAT 环境下访问光猫的管理界面，DHCP 会处理好不同网段 IP 的访问关系。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_tethering">Connect to the Internet via usb tethering</a></p>
<p>通过 USB-A 口连接手机，使用手机的移动网络连接互联网。这种模式需要打开手机的热点功能，使用有线以降低传输损耗。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_cellular">Connect to the Internet via usb modem</a></p>
<p>通过 USB 调制解调器连接互联网。这种模式将只能插在笔记本电脑上的传统的无线上网卡变成可供多人使用的 Wi-Fi。</p>
</li>
</ul>
<p>这些模式基本可以定义出 Travel Router——无线便携路由器的主要功能，读者可思考其中是否有符合自己需求的功能，从而对这种产品做出种草或拔草的判断。</p>
<h2 id="同类产品介绍">同类产品介绍</h2>
<p>说完了什么是无线便携路由器，我们再来看看有哪些可供选择的同类产品。</p>
<h3 id="单板机-diy">单板机 DIY</h3>
<p>弄清楚产品功能之后，我发现家里被用作软路由<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 的 <a href="https://www.friendlyelec.com/index.php?route=product/product&amp;product_id=282">NanoPi R2S</a> 是可以成为无线便携路由器的，只不过还需要对系统和配件进行一些 DIY 配置。</p>
<p>一个未经雕琢的 R2S 长这样:</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/r2s.png" type="" alt=""  />
  </div>

  <figcaption><p>NanoPi R2S original</p></figcaption>
</figure>

<p>插上一个外置的无线扩展模块，它从结构上就与 GL-AXT1800 一般无二了:</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/r2s-2.png" type="" alt=""  />
  </div>

  <figcaption><p>NanoPi R2S with wireless adapter</p></figcaption>
</figure>

<blockquote>
<p>Note 1: 不过这样使用也有局限，由于 R2S 只有一个 USB-A 口，当扩展为 Wi-Fi 天线后，就无法实现上文提到的 USB tethering/modem 模式了。</p>
<p>Note 2: 据推友 <a href="https://twitter.com/q1ngyang">@q1ngyang</a> 告知 <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，R2S 网卡方案有点麻烦，固件大多用不了无线网卡或无法驱动 AC，因此 R2S 不见得是最好的选择，若要使用 SBC 进行 DIY，还请读者在多方考察后慎重行事。</p>
</blockquote>
<p>实际上树莓派等其他 <a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a> 也可以用同样的思路配置实现，不过我更喜欢 NanoPi 的外形和亲民的价格（去年好像涨价了），感兴趣的读者可以在淘宝认准 FriendlyElec 官方店购买。</p>
<p>固件方面，使用 OpenWrt 或其发行版即可，通过 Wi-Fi 连接互联网是 OpenWrt 的基础功能之一，官方文档对此有着非常详细的说明: <a href="https://openwrt.org/docs/guide-user/network/wifi/relay_configuration">Wi-Fi extender / repeater / bridge configuration</a>.</p>
<h3 id="纯硬件产品">纯硬件产品</h3>
<p><a href="https://www.gl-inet.com/products/gl-axt1800/">GL-AXT1800</a> 即属于此类，在硬件层面已经高度集成和完善，但固件、代理等还需用户自行配置。GL.iNet 系产品的优点之一是自带基于 OpenWrt 开发的固件 <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，功能足够强大，省去了自己刷的麻烦。</p>
<p>下面列举 GL.iNet 的其他几款 Travel Routers:</p>
<ul>
<li>
<p><a href="https://www.gl-inet.com/products/gl-mt300n-v2/">GL-MT300N-V2</a></p>
<p>昵称 Mango 芒果，有着鲜明的颜色和与 R2S 近似的小巧外形。电源输入是 5V/2A，相比 GL-AXT1800 的 5V/4A 对充电头更加友好。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/mango.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-MT300N-V2, AKA Mango</p></figcaption>
</figure>

</li>
<li>
<p><a href="https://www.gl-inet.com/products/gl-ar300m/">GL-AR300M</a></p>
<p>黑色并升级了 CPU 的 GL-MT300N-V2。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-ar300m.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-AR300M</p></figcaption>
</figure>

</li>
<li>
<p><a href="https://www.gl-inet.com/products/gl-usb150/">GL-USB150</a></p>
<p>传统 U 盘的大小，可以直接插在充电器 USB-A 口上使用。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-usb150.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-USB150</p></figcaption>
</figure>

</li>
</ul>
<p>其他品牌中，TP-Link 有一款 <a href="https://www.tp-link.com/us/home-networking/wifi-router/tl-wr902ac/">TL-WR902AC</a> 和 GL-MT300N-V2 类似，支持刷入 OpenWrt <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/TL-WR902AC.png" type="" alt=""  />
  </div>

  <figcaption><p>TP-Link TL-WR902AC</p></figcaption>
</figure>

<h3 id="硬件--服务">硬件 + 服务</h3>
<p>推友 <a href="https://twitter.com/BigEyeSmolMouth">@BigEyeSmolMouth</a>  向我分享了<a href="https://www.meihuavpn.com/">梅花VPN</a> <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>，使我得知有这类产品的存在。它们就像网易的 UU 加速盒，在硬件上内置了自己的网络代理服务，实现成软硬一体化的翻墙 Wi-Fi。</p>
<p>在我看来，这种产品优缺点都很明显。优点是开箱即用，省事不折腾；缺点是可控性差，无法更换代理提供商，且商品的溢价较高，其硬件性能不会有多少剩余空间。从安全的角度考虑，这样一个黑盒设备也无法让人信任。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/meihua.png" type="" alt=""  />
  </div>

  <figcaption><p>梅花M3家用版</p></figcaption>
</figure>


<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/meihua-1.png" type="" alt=""  />
  </div>

  <figcaption><p>梅花M3便携版</p></figcaption>
</figure>

<blockquote>
<p><a href="https://www.meihuavpn.com/collections/shop/products/11offer-h">官网</a>的 spec 中没有关于 CPU、固件、协议等信息的描述。</p>
</blockquote>
<h2 id="相似但不同的产品">相似但不同的产品</h2>
<p>看过上文对无线便携路由器的介绍后，你是否有种似曾相识的感觉？没错，其实有一些与之类似但却不同的产品存在，平时没有用过也多少见过，这也是我在一开始未能准确把握自己想要什么产品的原因，它们都存在硬件或功能上的共性。下面我将针对两种可以明确定义出功能边界的设备进行阐述。</p>
<h3 id="wi-fi-信号放大器">Wi-Fi 信号放大器</h3>
<p>也有人将其称为「无线中继」，比较准确的英文名称应该是 Range Extender。这类产品的核心用途是接收已有 Wi-Fi 的信号，作为 <a href="https://en.wikipedia.org/wiki/Wireless_access_point">AP</a> 发射出相同的 SSID，以达到延长其信号范围的目的。一般用在家庭、办公室等空间较大、Wi-Fi 信号容易衰减的环境。</p>
<p>它和无线便携路由器在接收 Wi-Fi 信号这件事情上使用了相同的技术 <a href="https://en.wikipedia.org/wiki/Wireless_distribution_system">WDS</a>，但一个是扩展已有的 LAN，一个是创建新的 LAN，用途的差异使两者最终呈现出不同的产品形态。可以把 Wi-Fi 信号放大器看做特化的无线便携路由器。</p>
<p>TP-Link 有很多<a href="https://www.tp-link.com/hk/home-networking/range-extender/">此类产品</a>，它们的外形通常像耳朵长着天线的机器人🤖</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/TPLink-RE605X.png" type="" alt=""  />
  </div>

  <figcaption><p>TP-Link RE605X</p></figcaption>
</figure>

<h3 id="随身-wi-fi">随身 Wi-Fi</h3>
<p>也叫「无线上网卡」，比较准确的英文名称应该是 Mobile Wi-Fi Router (or 4G Wi-Fi Router)。这类产品的目的是使用 3G/4G LTE 创建随时随地可供使用的 Wi-Fi。分为内置 eSIM 卡和依赖外部 SIM 卡两种。</p>
<p>国内的随身 Wi-Fi 一般都是内置 eSIM 卡的，外形像 U 盘或充电宝，在设计上并没有提供多少可定制性，但由于其普及程度非常高，广大 DIY 爱好者早已将其研究通透。<a href="https://twitter.com/pengchujin">@酱紫表</a> 分享过一篇 <a href="https://qust.me/post/msm8916/">4g 随身 Wi-Fi 刷 openwrt 变成软路由</a> 教程，成品展示在这条<a href="https://twitter.com/pengchujin/status/1536310680109735936">推文</a>中。</p>
<blockquote>
<p>其实在刷上 OpenWrt 后，随身 Wi-Fi 就等同于上文中 <a href="https://docs.gl-inet.com/en/4/tutorials/internet_cellular/">Connect to the Internet via cellular</a> 模式下的  GL.iNet，因此它同样可以看做无线便携路由器的特化版。</p>
</blockquote>
<p>Netgear 的 <a href="https://www.netgear.com/home/mobile-wifi/hotspots/mr1100/">MR1100</a> 则是插卡的，黑色金属质地体现出服务器特有的冷酷和科技感，还有着让我无法抗拒的数据指示屏。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/netgear.png" type="" alt=""  />
  </div>

  <figcaption><p>Netgear MR1100</p></figcaption>
</figure>

<p>另一款值得一提的产品是 GL.iNet 的 <a href="https://www.gl-inet.com/products/gl-e750/">GL-E750</a>，它同时具备无线便携路由器和随身 Wi-Fi 的功能，并且可以通过内置的 7000mAh 供电，相当于 GL-MT300N-V2 + 上网卡 + 充电宝的 all-in-one 组合。在咖啡馆可以连接公共 Wi-Fi 并接线充电，在户外则可以使用移动网络不依赖电源，简直是理想中的产品。但一般来说，越是什么都会，越可能什么都不精，GL-E750 具体表现如何，只有真正入手使用后才能知道。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-e750.png" type="" alt=""  />
  </div>

  <figcaption><p>GL.iNet Mudi (GL-E750)</p></figcaption>
</figure>

<h2 id="结语">结语</h2>
<p>在移动办公越来越广泛的今天，无论你是时常出差办公的技术工作者，还是四海为家的数字游民，无线便携路由器都是值得了解和尝试的产品。数据和隐私是无价的，当连接到公共 Wi-Fi 时，我们的设备便存在被攻击和窃取数据的风险，而通过无线便携路由器，我们可以在一个可控的局域网中管理设备、增加防护，获得更安全的办公环境和更高效的生产力。</p>
<p>本文仅对一些无线便携路由器做了简单的列举，不涉及传输和加密性能的测评，由于我还没有实际使用过，因此无法对这些产品的好坏做出评价，读者将本文当做科普知识的分享即可。在未来我会补充一篇实际的产品使用体验，如果你使用过这一类产品，欢迎在评论区或 Twitter 分享你的经验。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-06-30: created</li>
<li>2022-07-02: add GL-E750</li>
<li>2022-07-09: update R2S notes</li>
<li>2022-07-10: 添加关于「使用无线便携路由器是否会影响公共 Wi-Fi 手机号验证流程」的描述</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>见推文 <a href="https://twitter.com/novoreorx/status/1412406192845033473">https://twitter.com/novoreorx/status/1412406192845033473</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>见推文 <a href="https://twitter.com/q1ngyang/status/1543116478987190275">https://twitter.com/q1ngyang/status/1543116478987190275</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>见 GitHub 项目页 <a href="https://github.com/gl-inet/openwrt">https://github.com/gl-inet/openwrt</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>见 OpenWrt 官网的硬件支持页面: <a href="https://openwrt.org/toh/tp-link/tl-wr902ac_v3">https://openwrt.org/toh/tp-link/tl-wr902ac_v3</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>见推文 <a href="https://twitter.com/BigEyeSmolMouth/status/1542379014970417153">https://twitter.com/BigEyeSmolMouth/status/1542379014970417153</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>使用自动化工作流聚合信息摄入和输出</title><link>https://reorx.com/blog/sharing-my-footprints-automation/</link><pubDate>Wed, 25 May 2022 00:00:00 +0800</pubDate><guid>https://reorx.com/blog/sharing-my-footprints-automation/</guid><description>展示我是如何用 n8n 将 Twitter, YouTube, GitHub, Douban 等服务的动态同步到 Telegram Channel，实现个人数字生活的信息聚合。</description><content:encoded><![CDATA[<p>欢迎关注我的 Telegram 频道: <a href="https://t.me/reorx_share">Reorx’s Footprints</a>。这篇文章讲述我为什么创建这个频道，以及如何用 n8n 将 Twitter, YouTube, GitHub, Douban 等服务的动态同步过去，实现个人数字生活的信息聚合。</p>
<h2 id="前言">前言</h2>
<p><a href="https://en.wikipedia.org/wiki/Cyberspace">赛博空间</a>构成了我的精神世界。</p>
<p>我的大脑从苏醒的那一刻开始渴求信息，大量新鲜的信息，它们比饮用水更早地进入我的身体。每天睁开眼睛，我做的第一件事情是拿起手机，逐个查看昨夜的消息提醒。起床之后，我会在马桶上浏览 RSS 阅读器和 Telegram 频道中的新闻，让思维复苏的过程伴随新知识的冲击。我已经习惯了如此，一边加载昨日的进展并思考今日的安排，一边点开链接，使用不同的工具进行阅读、收藏和记录。</p>
<p>一天之中的碎片时间，我也会不断地在 Twitter、RSS、Telegram 之间切换，这对我来说并不是信息焦虑，而是自然而然的生活习惯。在工作上，我也完全依赖于网络，在解决问题的过程中搜索阅读大量的网站，将之转化为代码和学习笔记。</p>
<p>我就像一台不停运行的收集器和过滤器，持续地消费、生产信息。但大脑被设计用于分析和联想，却不擅长高效精确的索引，这些信息散落在各个服务中，我可以想起一些关键词或模糊的上下文，但总是很难快速获取到。我需要一个能将它们聚合在一起的工具，或者工作流，这样既可以方便自己的回溯，也可以将这些经过提纯的信息分享出来，为和我兴趣接近的人提供另一个输入管道。</p>
<h2 id="聚合什么信息">聚合什么信息？</h2>
<p>不是所有在赛博空间产生的信息都需要被聚合。一些被动产生的如搜索记录、地理位置记录、个人健康信息等，他们可以用作 <a href="https://en.wikipedia.org/wiki/Quantified_self">quantified self</a>（这是另一个话题），但并不在我的考虑范畴内。</p>
<p>我要聚合的主要有两类信息，一类是是由我主动创造的，比如Twitter 上发表的看法、GitHub 上为开源项目提交的问题；一类是我主动收藏或标记的，Pinboard 上收藏的书签、YouTube 上点赞过的视频均属此列。它们有的直接流入我的知识库<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，有的保存在线上服务中，作为知识的原材料储备，留待日后进行消化吸收。</p>
<p>考虑到分享的目的，这些信息中还要去掉功能性的部分，只保留我确认有价值的那些。比如 Twitter Like 有时会用于社交目的，作为一种赞赏的回应；YouTube, Spotify 中各种 playlist 很多只是为了满足收集癖，不一定具有普适性；豆瓣的想看、想读只是待确认的 enqueue，只有看过、读过才是值得推荐的。</p>
<h3 id="内容来源">内容来源</h3>
<p>基于以上考虑，我将自己主要摄入和产生信息的来源进行了整理，得到如下列表：</p>
<ul>
<li>
<p><strong>Telegram</strong></p>
<p>我在 Telegram 中分享一些一闪而过的想法、菜谱，转发浏览其他频道时看到特别有意思的内容。</p>
<ul>
<li>Fleeting thoughts 💭</li>
<li>Recipe 🍳</li>
<li>Forward 🔄</li>
</ul>
</li>
<li>
<p><strong>Twitter</strong> 🐦</p>
<p>我的所有 Tweet 和 Retweet 都经过认真思考，是希望被阅读的内容创作。</p>
<ul>
<li>Tweet</li>
<li>Retweet</li>
</ul>
</li>
<li>
<p><strong>Instapaper</strong> 📖</p>
<p>我这样管理我的待看列表：对于没确认是否有价值的那些，我会加入 TODO 或 Telegram Saved Messages。只有当我认真阅读过并认为值得再次阅读，我才会将其加入 Instapaper 中。</p>
</li>
<li>
<p><strong>Blog</strong> 📝</p>
<p>我的个人博客，通过 RSS 发布更新。</p>
</li>
<li>
<p><strong>Music</strong> 🎵</p>
<p>我主要使用 Spotify 听歌，类似 Instapaper，只有我愿意反复听的歌曲才会加入 Liked Songs，可以看做是我基于个人音乐品味的推荐。</p>
<ul>
<li>Spotify</li>
</ul>
</li>
<li>
<p><strong>YouTube</strong> ▶️</p>
<p>YouTube 是我探索世界无限可能性的地方，it&rsquo;s about everything and nothing。每个 Like 过的视频都有着让我会心一笑或拍案叫绝的亮点。</p>
</li>
<li>
<p><strong>Bookmark</strong> 🔖</p>
<p>我从 2013 年开始使用 Pinboard，虽然 Pinboard 的社交属性很弱，但我一直坚持用 private/public 属性来区分我的收藏，所有 public 的书签都具备一定的分享价值。</p>
<ul>
<li>Pinboard</li>
</ul>
</li>
<li>
<p><strong>GitHub</strong></p>
<p>由于对 Pinboard 的重度使用，大部分 GitHub 项目都收藏在 Pinboard 中，Star 的是我觉得值得鼓励的项目。每个 Issue 和 Pull-request 我都有认真撰写，他们是我参与开源活动的记录。</p>
<ul>
<li>Star 🌟</li>
<li>Issue ⚡️</li>
<li>Pull-request ⤴️</li>
</ul>
</li>
<li>
<p><strong>Douban</strong></p>
<p>我主要用 Douban 记录看过的电影和书。如上文所说，这里只分享在看、看过的电影和在读、读过的书籍。后续考虑对评分进行过滤。</p>
<ul>
<li>Movie 📺</li>
<li>Book 📖</li>
</ul>
</li>
</ul>
<h3 id="展现形式">展现形式</h3>
<p>我选择 Telegram Channel 作为信息聚合的目的地。一方面我许多信息都来源于 Telegram ，另一方面它也非常易于使用和接入。</p>
<p>Telegram 以下几种功能极大程度地丰富了信息的展现形式<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<ul>
<li>
<p>链接预览</p>
<p>Telegram 会将消息中附带的链接进行抓取，将摘要和图片显示在消息下方。</p>
</li>
<li>
<p>富文本格式</p>
<p>Telegram 消息支持 Markdown 和 HTML 两种富文本格式的解析，可以实现粗体、斜体、下划线、超链接、行内和块级代码等样式。</p>
</li>
<li>
<p>标签索引</p>
<p>Telegram 的消息支持 <code>#</code> 为前缀的标签，在频道/群组内点击标签即可对消息进行筛选，这让结构化的信息索引成为可能。</p>
</li>
</ul>
<h2 id="实现自动化同步">实现自动化同步</h2>
<p>我使用 <a href="https://github.com/n8n-io/n8n">n8n</a> 来实现整套信息收集和聚合的自动化工作流<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。下面将对我的操作方法和配置进行讲解，参照这些说明，你也可以快速搭建一套属于自己的自动化信息分享系统。</p>
<h3 id="n8n-概念说明">n8n 概念说明</h3>
<ul>
<li>
<p><strong>workflow</strong></p>
<p>用于定义一条自动化工作流，由多个 node 以及 node 之间的指向关系构成。</p>
</li>
<li>
<p><strong>node</strong></p>
<p>构成 workflow 的基本单位，每个 node 可以完成一个独立的任务，比如定时触发、获取数据、筛选数据、发送信息等。</p>
</li>
<li>
<p><strong>credential</strong></p>
<p>访问凭据，用于在访问在线服务接口时进行身份验证。workflow 内只存储 credential 的 id，只有在运行时才会获取其中的实际内容，这一机制确保了 workflow 在分享时不会造成凭据泄露。</p>
</li>
</ul>
<h3 id="安装-n8n">安装 n8n</h3>
<p>n8n 支持使用 Docker 进行自部署，它由 Nodejs 开发，使用 SQLite 作为数据库，没有其他外部依赖，因此理论上可以部署在任何 Docker 或 Nodejs 运行环境。</p>
<p>为了方便调试，我将 n8n 部署在家里的 NAS 上，你也可以尝试将其部署在 <a href="https://railway.app?referralCode=XkWaVV">Railway</a> 等 PaaS 平台。</p>
<p>正常情况下，参照 n8n 的 <a href="https://docs.n8n.io/hosting/installation/docker/">Docker Installation</a> 文档即可完成初步运行。但在使用中，我发现了 n8n Twitter 接入的 bug，在对代码进行了修改后，不得不在本地构建 Docker 镜像 (见 <a href="https://github.com/n8n-io/n8n/tree/master/docker/images/n8n-custom">n8n - Custom Image</a>)。如果你需要使用 Twitter 接入，在这个 <a href="https://github.com/n8n-io/n8n/pull/3354">PR</a> 合并之前，建议使用我构建好的镜像 <a href="https://hub.docker.com/r/reorx/n8n-custom">reorx/n8n-custom</a>。</p>
<p><details >
  <summary markdown="span">附上我的 docker-compose.yml 文件作为参考</summary>
  <pre tabindex="0"><code>version: &#39;3&#39;
services:
  n8n:
    #image: n8nio/n8n
    image: n8n-custom
    ports:
      - 5678:5678
    volumes:
      - /share/CACHEDEV2_DATA/Misc/AppData/n8n:/home/node/.n8n
      - /share/CACHEDEV1_DATA/homes/reorx/Misc_Backup/:/backup
    environment:
      - PUID=1000
      - PGID=1000
      - VUE_APP_URL_BASE_API=http://harrogath-local.com:5678/
      - WEBHOOK_URL=http://harrogath-local.com:5678/
      - GENERIC_TIMEZONE=Asia/Shanghai
      - TZ=Asia/Shanghai
      - N8N_LOG_LEVEL=verbose
    restart: unless-stopped
</code></pre>
</details></p>

<p>由于许多服务需要通过 OAuth 进行接入，我们运行的 n8n 需要有一个固定的访问地址，以便接收 OAuth callback url 的访问。我的做法是在局域网内将 <code>harrogath-local.com</code> 这个域名指向 n8n 所在的机器，并为 n8n 设置如下环境变量，使其显示的 OAuth callback 与域名一致。</p>
<pre tabindex="0"><code>VUE_APP_URL_BASE_API=http://harrogath-local.com:5678/
WEBHOOK_URL=http://harrogath-local.com:5678/
</code></pre><p>启动完成后，即可通过 <code>http://harrogath-local.com:5678/</code> 访问 n8n 的 web 界面了。</p>
<h3 id="创建-workflows">创建 Workflows</h3>
<p>我的每个 workflow 都分享到了 GitHub <a href="https://github.com/reorx/n8n-workflows">reorx/n8n-workflows</a> 仓库中，通过复制 <code>.json</code> 文件的内容、粘贴在 n8n 的 workflow 编辑界面，即可对 workflow 进行复用。也可以使用 n8n 的命令直接将 workflow 导入到 n8n 的数据库中 (见文档 <a href="https://docs.n8n.io/reference/cli-commands/#import-workflows-and-credentials">Import workflows and credentials</a>)。注意无论使用何种方式导入，credentials 都需要重新配置。</p>
<h4 id="new-tweet-to-telegram">New tweet to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/new%20tweet%20to%20tg.json">n8n-workflows/workflows/new tweet to tg.json</a></p>
<p>这一 workflow 实现了每 5 分钟搜索一次我的 Twitter 时间线，将最新的 tweets 发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n.png" type="" alt=""  /></p>
<p>第一个 node 是 Interval，它是一个 trigger，可以设置重复运行的间隔时长。</p>
<p>随后是 Twitter node，它通过 OAuth 连接了我的账户，使用 <code>from:novoreorx</code> 搜索语法来获取我最近的推文条目。</p>
<p>IF reply to other 是一个 IF node，通过条目中的 <code>in_reply_to_screen_name</code> 字段判断推文是否是对别人的回复，只有否才可以走向下一步。意味着只有单独创建或回复自己的推文才会被转发。</p>
<p>Set Retweeted node 根据条目中的 <code>retweeted_status</code> 字段，识别 retweet 条目，并将原推的 URL 拼凑出来，赋值给新的字段 <code>retweeted</code> 和 <code>retweetedUrl</code>，以便后续使用。</p>
<blockquote>
<p><strong>2022-08-12 updated:</strong></p>
<p>Set Retweeted node 在后续的维护中打开了 &ldquo;Keep Only Set&rdquo; 选项，只保留其中所定义的字段，实际作用已经与名称不符，称为 &ldquo;Set properties&rdquo; 更准确一些。</p>
<p>新增了 <code>proxyUrl</code> 字段，使用 <a href="https://github.com/dylanpdx/BetterTwitFix">vxTwitter</a> 服务的域名 <code>vxtwitter.com</code> 替代 <code>twitter.com</code>，以在 Telegram 中有更好的预览效果</p>
</blockquote>
<p>Function 是我写的一段 JavaScript 代码，它使用了 n8n runtime 内置的 <a href="https://docs.n8n.io/integrations/core-nodes/n8n-nodes-base.function/#method-getworkflowstaticdatatype">getWorkflowStaticData</a> 函数，记录每次更新的第一个条目 <code>lastItemId</code>，通过与上一次的记录进行对比，确保只有新的条目会被输送到下一个 node 执行。如果没有 <code>lastItemId</code>，则只返回第一个条目，避免冷启动时造成大量信息的无效转发。这段代码基本在每个 workflow 中都有用到，下面将不再赘述。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* only return new items */</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">staticData</span> <span class="o">=</span> <span class="nx">getWorkflowStaticData</span><span class="p">(</span><span class="s1">&#39;global&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">lastItemId</span> <span class="o">=</span> <span class="nx">staticData</span><span class="p">.</span><span class="nx">lastItemId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;lastItemId&#39;</span><span class="p">,</span> <span class="nx">lastItemId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">firstItem</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">getId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">lastItemId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">getId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">===</span> <span class="nx">lastItemId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newItems</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[</span><span class="nx">firstItem</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">staticData</span><span class="p">.</span><span class="nx">lastItemId</span> <span class="o">=</span> <span class="nx">getId</span><span class="p">(</span><span class="nx">firstItem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Reverse the order so that items are sent from old to new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="nx">newItems</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
</span></span></code></pre></div><p>经过 Function 的处理后，有效条目会被送往 Telegram node，进行 message 组装，最终发送到频道。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-1.png" type="" alt=""  /></p>
<p>n8n 的表达式 (Expression) 有一个可以预览的编辑界面，左侧会展示当前 node 从上一个 node 获取到的输入数据 (Input Data)，点击即可将模板变量插入到 Expression 中。模板语法 <code>{{ }}</code> 中可以使用 JavaScript 语法，这里我通过 <code>$json[&quot;retweeted&quot;]</code> 来决定 tag 为 <code>#retweet</code> 还是 <code>#tweet</code>。推文 URL 放在了 <code>&lt;a&gt;</code> 标签中，既可以触发 Telegram 的 link preview 功能，也避免展示太长的 URL 影响可读性。</p>
<blockquote>
<p><strong>2022-08-12 updated:</strong></p>
<p>Twitter 的 search API 默认会将长推文截断，只有加了 <code>tweet_mode=extended</code> 参数才能确保显示全文，不过推文内容字段会从 <code>tweet</code> 变为 <code>full_text</code>。按下图所示添加参数后，请在 &ldquo;Set Retweeted&rdquo; node 中修改字段映射 <code>text</code> → <code>tweet</code> 为 <code>full_text</code> → <code>tweet</code>。
<img loading="lazy" src="/blog/sharing-my-footprints-automation/images/tweet-mode-extended.png" type="" alt=""  /></p>
</blockquote>
<h4 id="blog-rss-to-telegram">Blog RSS to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/blog%20rss%20to%20tg.json">n8n-workflows/workflows/blog rss to tg.json</a></p>
<blockquote>
<p>从第二个 workflow 开始，我将只对大致逻辑进行说明，不再详细讲解每个 node 的实现方式，有兴趣的读者可以在 workflow 编辑器中自行查看。</p>
</blockquote>
<p>这一 workflow 实现了每 10 分钟检查一次博客的 RSS，将最新的文章发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-2.png" type="" alt=""  /></p>
<p>RSS Feed Read node 填写了博客的 RSS 地址，Function 同样是实现了有状态的更新判断，唯一的不同是将 <code>getId</code> 函数改为从 <code>item.json.guid</code> 获取 item id。</p>
<h4 id="spotify-like-to-telegram">Spotify like to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/spotify%20likes%20to%20tg.json">n8n-workflows/workflows/spotify likes to tg.json</a></p>
<p>这一 workflow 实现了每 1 小时检查一次 Spotify Liked Tracks，将最新的歌曲发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-3.png" type="" alt=""  /></p>
<h4 id="youtube-like-to-telegram">YouTube like to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/youtube%20like%20to%20tg.json">n8n-workflows/workflows/youtube like to tg.json</a></p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-4.png" type="" alt=""  /></p>
<p>这一 workflow 实现了每 30 分钟检查一次 YouTube Liked Playlist，将最新的视频发送到 Telegram Channel。</p>
<p>这里需要注意的是，Liked 是一个内置的 playlist，因此其 ID 与自己创建的不一样，通过访问 YouTube get playlists API，得到其 ID 为 <code>LL</code>，顺利完成了这一 node 的配置。</p>
<h4 id="pinboard-new-bookmark-to-telegram">Pinboard new bookmark to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/pinboard%20to%20tg.json">n8n-workflows/workflows/pinboard to tg.json</a></p>
<p>这一 workflow 实现了每 5 分钟检查一次 Pinboard 最近的书签，将最新的书签发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-5.png" type="" alt=""  /></p>
<p>n8n 没有 Pinboard 支持，但我们可以通过 HTTP Request 直接访问 Pinboard 的接口。古怪的是 Pinboard 没有官方的 API 文档，于是我对一些开源的 Pinboard SDK 代码进行阅读，得到了我所需要的接口 <code>https://api.pinboard.in/v1/posts/recent</code>。</p>
<p>Pinboard 接口返回的数据并不直接是一个列表，而是一个形如 <code>{&quot;posts&quot;: [...]}</code> 的结构，这里用了 Item Lists 将 <code>posts</code> 字段提取出来作为 items 向后传递。</p>
<h4 id="github-activities-to-telegram">GitHub activities to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/github%20activities%20to%20tg.json">n8n-workflows/workflows/github activities to tg.json</a></p>
<p>这一 workflow 实现了每 10 分钟检查一次 GitHub 的动态，筛选出 star, pull-request 和 issue 发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-6.png" type="" alt=""  /></p>
<p>GitHub 可以通过 <code>https://github.com/$username.atom</code> 获取用户公开的动态信息，因此不需要复杂的 API 接入，直接使用 RSS Feed Read 即可获取到我们所需要的数据。</p>
<p>在 Function filter 中，我用正则为动态进行了分类，并组成最终所需的消息格式，代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/* filter items */</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">regexes</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;star&#39;</span><span class="o">:</span> <span class="sr">/^reorx starred/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;pull-request&#39;</span><span class="o">:</span> <span class="sr">/^reorx opened a pull request/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;issue&#39;</span><span class="o">:</span> <span class="sr">/^reorx opened an issue/</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tagSymbols</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;star&#39;</span><span class="o">:</span> <span class="s1">&#39;🌟&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;pull-request&#39;</span><span class="o">:</span> <span class="s1">&#39;⤴️&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s1">&#39;issue&#39;</span><span class="o">:</span> <span class="s1">&#39;⚡️&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">title</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">regexes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="nx">regexes</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">title</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">tag</span> <span class="o">=</span> <span class="nx">key</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">tag</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">tag</span>
</span></span><span class="line"><span class="cl">    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">tgTitle</span> <span class="o">=</span> <span class="sb">`</span><span class="si">${</span><span class="nx">tagSymbols</span><span class="p">[</span><span class="nx">tag</span><span class="p">]</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">title</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^reorx /</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="sb"> #github #</span><span class="si">${</span><span class="nx">tag</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl">    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">guid</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newItems</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">newItems</span>
</span></span></code></pre></div><blockquote>
<p>这个 workflow 还有一个使用 GitHub API 的版本，但 RSS 可以获得所有动态，更加方便，最终胜出。</p>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/github%20issues%20to%20tg.json">n8n-workflows/workflows/github issues to tg.json</a></p>
</blockquote>
<h4 id="douban-activities-to-telegram">Douban activities to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/douban%20activities%20to%20tg.json">n8n-workflows/workflows/douban activities to tg.json</a></p>
<p>这一 workflow 实现了每 10 分钟检查一次 Douban 的动态，筛选出看过、在看、读过、在读发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-7.png" type="" alt=""  /></p>
<p>Douban 也有一个隐藏的 RSS 订阅源 <code>https://www.douban.com/feed/people/$username/interests</code>，包含书影音的所有动态。</p>
<p>Function filter 与上一个 workflow 类似，这里做了一些优化，将正则和符号定义在一个 object 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">SYMBOL_MOVIE</span> <span class="o">=</span> <span class="s1">&#39;📺&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">SYMBOL_BOOK</span> <span class="o">=</span> <span class="s1">&#39;📖&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tagInfoMap</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">watched</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/看过/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_MOVIE</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">watching</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/在看/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_MOVIE</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">read</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/读过/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_BOOK</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reading</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/在读/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_BOOK</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="异常通知">异常通知</h3>
<p>n8n 作为一个自动化服务，在配置完成后，一般我们不会去主动查看系统的运行情况，因此需要有监控手段得知异常的发生，以便及时维护。</p>
<p>n8n 支持通过 <a href="https://docs.n8n.io/integrations/core-nodes/n8n-nodes-base.errortrigger/">Error Trigger</a> 创建 Error Workflow，用于接收其他 workflow 的错误信息。这一步虽然不是必须，但我强烈建议创建一个全局的 Error Workflow，并在每个 workflow 的 Settings 中设置错误处理指向它。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-8.png" type="" alt=""  /></p>
<p>我在 <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/ERROR%20TO%20TG.json">n8n-workflows/workflows/ERROR TO TG.json</a> 中实现了将错误信息发送到 Telegram Group 的功能，效果如下。
<div class="image-size-control" style="max-width: 400px;">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/telegram.png" type="" alt=""  />
</div>
</p>
<h3 id="使用-saas-自动化服务">使用 SaaS 自动化服务</h3>
<p>对于一些 n8n 尚不支持，或配置比较麻烦的服务，也可以通过 SaaS 服务来实现自动化。IFTTT 是一个不错的选择，它应该是最早被广泛使用的自动化服务，免费用户可以设置 5 个 applet (即 workflow)，同步间隔 1 小时。</p>
<p>下图是我在 IFTTT 中配置的 Instapaper 新文章推送到 Telegram 频道的 applet。</p>
<div class="image-size-control" style="max-width: 400px;">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/ifttt.png" type="" alt=""  />
</div>

<p><a href="https://www.integromat.com/">Integromat</a> 曾是一个非常好用的 IFTTT alternative，有着现代化的交互界面，和更为灵活的定制功能，但后来 rebrand 成 make.com，变得非常难用，不仅加载速度缓慢，而且连 migration 都无法正常完成<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>。建议大家远离这个奇怪的公司。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/integromat.png" type="" alt=""  />

  <figcaption><p>曾经美好的 Integromat</p></figcaption>
</figure>

<figure class="center align-center">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/integromat-scenario.png" type="" alt=""  />

  <figcaption><p>和它出色的交互界面</p></figcaption>
</figure>

<h2 id="结语">结语</h2>
<p>使用 n8n 的过程总体是非常顺畅的，虽然一开始就在 Twitter 上栽了跟头，好在我能看懂 Nodejs 代码，自己动手修复后一路坦途。</p>
<p>曾经我特别痴迷于自己实现工具、制造轮子，现有工具稍有不顺就要全盘抛弃，自己解决。后来我在 happy xiao 的<a href="https://happyxiao.com/system/">忘记系统</a>一文中看到 <a href="https://twitter.com/johnvoorhees">John Voorhees</a> 的一段话，改变了我对使用工具的态度:</p>
<blockquote>
<p>If there&rsquo;s anything I&rsquo;ve learned about productivity systems, it&rsquo;s that the best one is the one that works for you. Approaching the problem is tricky, but my advice is to use an app first and adopt a system later. That way, you&rsquo;ll have a better understanding of what your needs are before you dive in.</p>
</blockquote>
<p>实现的结果才是最重要的，工具只是手段，不是目的。</p>
<p>这也让我对自己正在开发的产品有了更多的思考，它是一个用于信息前处理的工具，同样是为了解决信息的分散和封闭而做出的努力，我设想了很多功能要去开发，但哪些是核心需求，哪些有代替品，或者换个思路通过其他方式实现，则必须放在实际场景中去考虑，而不是凭自己作为开发者的喜欢来武断确定。</p>
<p>回到赛博空间这个话题，我一直觉得人类对电子设备的依赖是一个不可逆的过程，人脑与电脑的边界会逐渐模糊。这是当我们有了智慧、抛弃自然为我们提供的进化之路后，自己所选择的进化方式。正如 Ghost In The Shell 开篇所描绘的越来越近的未来：</p>
<blockquote>
<p>企業のネットが星を被い、電子や光が駆け巡っても</p>
<p>国家や民族が消えてなくなるほど、情報化されていない近未来</p>
</blockquote>
<p>而在这一天到来之前，我在精神上已经完成了自然人向 <a href="https://en.wikipedia.org/wiki/Cyborg">cyborg</a> 的转变。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-05-26: created</li>
<li>2022-05-27: published</li>
<li>2022-05-28: fixed &ldquo;Function&rdquo; node script items order by adding <code>.reverse()</code> to return items</li>
<li>2022-08-12:
<ul>
<li>added notes about using <code>tweet_mode=extended</code> to avoid tweet text truncation</li>
<li>added notes about vxTwitter proxy url</li>
</ul>
</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>我的知识库中有三个分类:「制品」、「技术」、「事实」。制品 (artifacts) 是人所创造的作品、产品，如一个开源项目、一个软件；技术 (techniques) 是完成一类事情的方法或经验，也可以叫做 know-how，比如做饭的菜谱、编程语言的技巧、健身动作说明；事实 (facts) 是对概念、词汇的客观解释，多数来源于维基百科的词条。这三个分类可以基本涵盖我摄入的各类信息。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>预计微信还需要 100 年才能赶上&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>self-hosted workflow automation 的另一个选择是 <a href="https://github.com/huginn/huginn">Huginn</a>, 我没有尝试和对比，在看过它的项目页面，感觉 UI 非常简陋就放弃了。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>见我在 Twitter 的吐槽: <a href="https://twitter.com/novoreorx/status/1528985317847736320">make.com 大概是我 10 年来用过最糟糕的服务</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>使用 Sonarr 搭建自动化追番系统</title><link>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</link><pubDate>Mon, 02 May 2022 00:00:00 +0800</pubDate><guid>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</guid><description>A complete guide to deploy and configure Sonarr + Jackett + FlareSolverr + qBittorrent to track and download anime shows automatically.</description><content:encoded><![CDATA[<p>作为一个懒人，我很少折腾 self-hosted 服务，对于追番这种娱乐化的需求，更是有什么用什么将就度日。所以许多年来一直是用 Bilibili 观看新番，中途也尝试过 ebb.io 这类小众服务，但最后都因为连接不畅或数据滞后等原因放弃了。</p>
<p>去年为了实现 Home Assistant 家电自动化 (<a href="https://twitter.com/novoreorx/status/1450334462177263618">tweet</a>)，我购买了一台 QNAP NAS，使家里有了 24 小时常驻的 Linux server 和 Docker host。年初由于 Bilibili 迟迟不上架《鬼滅之刃遊郭篇》，我又在 NAS 上安装了 Plex，将从 <a href="https://share.dmhy.org/">dmhy</a> 手动下载的影片串流到电视上观看。最近又逢 4 月新番播出，想到家里的基础设施逐渐完备，便动起了搭建自动追番系统的心思。以下便是对这次尝试的记录和总结，希望能帮助有同样需求的人解决问题、节省时间。</p>
<h2 id="使用-qnap-download-station">使用 QNAP Download Station</h2>
<p>本着尽量不增加新的系统来解决问题的思想，我首先研究了 QNAP 的下载器 Download Station，发现它自带 RSS 订阅功能，在进行一些手动配置后，即可完成自动追番和下载。</p>
<p>如果对这一章节不感兴趣，你也可以直接跳到 <a href="#%E4%BD%BF%E7%94%A8-sonarr-%E5%92%8C%E5%AE%83%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC">使用 Sonarr 和它的朋友们</a>。</p>
<h3 id="1-找到番剧的-rss-url">1. 找到番剧的 RSS URL</h3>
<p><a href="https://bangumi.moe/">Bangume Moe</a> 是我经常使用的资源站，它提供基于 tag 的 RSS 搜索功能，可以非常精确地定位到番剧在特定字幕组、语言、分辨率瞎的视频发布链接。</p>
<ul>
<li>首先在右上角的搜索框中输入想看的番剧名称，这里我使用「夏日重现」作为例子，可以看到下方自动匹配了 <code>Summertime Render</code> 这个 tag。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-2.png" type="" alt=""  /></li>
<li>点击这个 tag，搜索结果中会出现许多不同字幕组发布的资源，我们选择其中一个字幕组「喵萌奶茶屋」的资源，在 Torrent Details 中，可以看到其标注的 tags，有 <code>喵萌奶茶屋</code>, <code>720p</code>, <code>chs-jpn</code> 等，妥善使用这些 tags 能够帮助我们缩小搜索结果范围
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-1.png" type="" alt=""  /></li>
<li>将 <code>喵萌奶茶屋</code>, <code>chs-jpn</code> 添加到 Selected tags 中，现在我们一共有 3 个 tags，搜索结果缩短到了 2 条，已经非常清晰了，点击右上角的 RSS 图标即可得到用于订阅的链接。（美中不足的是，喵萌奶茶屋将 1080p 的资源错标为了 <code>720p</code>，不过这点我们可以在后面的下载管理器中解决）
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime.png" type="" alt=""  /></li>
</ul>
<h3 id="2-将-rss-url-添加到下载器">2. 将 RSS URL 添加到下载器</h3>
<p>RSS 订阅是许多下载管理器的通用功能，如 Synology、qBittorrent 也都具有，使用方式与 Download Station 大同小异。</p>
<ul>
<li>打开 RSS Download Manager，将上一步得到的订阅链接复制到 Feed URL 中。Label 填写番剧名称，两个 Location 根据自己 NAS 的目录结构选择。点击 Apply 添加。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter.png" type="" alt=""  /></li>
<li>添加完成后，打开 Filter Settings，它可以用于进一步过滤 RSS 返回的结果，避免下载不需要的资源。之前在进行资源搜索时，我们没能通过 tag 过滤掉 720p 的结果，在 Filter Settings 中，我们选择 1080p，这样 720p 就被忽略了。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter-1.png" type="" alt=""  /></li>
<li>回到主界面，刷新添加的 RSS，可以看到两条结果中只有 1080p 被加入到下载列表。Status 为 Finished 代表下载完成，New 代表新添加到 RSS，但不在下载列表中。</li>
</ul>
<h3 id="小结">小结</h3>
<p><strong>Pros</strong></p>
<ul>
<li>无需配置和增加新系统</li>
<li>操作过程透明清晰，可控性强</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>步骤较为繁琐，需要在多个服务之间切换</li>
<li>下载的文件因为不符合 Plex 的格式需求，需要手动重命名才能在 Plex 上观看。但如果你使用 DLNA 这类基于文件系统定位视频的方式，倒是可以忽略这个缺点。</li>
</ul>
<h2 id="使用-sonarr-和它的朋友们">使用 Sonarr 和它的朋友们</h2>
<p>Download Station RSS 虽然解决了基本的温饱问题，但与真正的自动化之间显然还有很大差距，如果你想充分利用 NAS 的功能，在家庭多媒体设施上更进一步，请继续向下阅读，走进 Sonarr 和它的朋友们的世界。</p>
<h3 id="sonarr">Sonarr</h3>
<blockquote>
<p>Sonarr is a PVR (Personal Video Recorder) for Usenet and BitTorrent users. It can monitor multiple RSS feeds for new episodes of your favorite shows and will grab, sort and rename them.</p>
</blockquote>
<p><a href="https://wiki.servarr.com/sonarr">Sonarr</a> 是一个 PVR 系统，它可以监控多种信息源的剧集发布信息，对剧集进行自动下载、刮削和重命名。</p>
<p>Sonarr 是 Sick Beard 的继任者，Sick Beard 基于 Python 开发，曾经是最著名的 PVR 系统，但后来逐渐式微，后续虽然有 Sick Gear 等 fork，但最终都没能满足人们日益增长的看片需求，最后被一群 C# 爱好者们开发出 Sonarr 给替代了。经过多年发展，Sonarr 的软件质量趋于成熟和稳定，成为构架自动化的家庭多媒体中心不可缺少的组件。</p>
<p>Sonarr 一开始就以多系统低耦合的方式进行设计，这大大降低了代码的复杂度，使其更易于维护，也为其繁盛的社区发展提供了基石。为了满足不同的用户需求，Sonarr 的作者们开发一系列以 <code>rr</code> 或其他双字母结尾的工具，以至于这种命名方式成为了 Sonarr 生态圈的一个标识和事实标准。</p>
<h3 id="jackett">Jackett</h3>
<blockquote>
<p>Jackett works as a proxy server: it translates queries from apps into tracker-site-specific http queries, parses the html or json response, and then sends results back to the requesting software.</p>
</blockquote>
<p><a href="https://github.com/Jackett/Jackett">Jackett</a> 是一个代理，用于将 Sonarr 等系统对剧集信息的查询请求转译成各种 torrent tracker/indexer （即资源发布站）所支持的请求。Jackett 的产生是 Sonarr 社区架构合理性的一个体现，它接管了适配不同 indexer 接口的脏活累活，使 Sonarr 可以专注在任务调度和剧集管理上。</p>
<p>Jackett 既然被用作资源查询的网关，实现缓存功能就顺理成章了，这样一方面可以应对 Sonarr 频繁的查询需求，另一方面也减少了 indexer 站点的负载量，实现了双赢。因此虽然它不是一个必须的组件，但我强烈建议每个使用 Sonarr 的用户都安装它。</p>
<h3 id="flaresolverr">FlareSolverr</h3>
<blockquote>
<p>FlareSolverr is a proxy server to bypass Cloudflare and DDoS-GUARD protection.</p>
</blockquote>
<p><a href="https://github.com/FlareSolverr/FlareSolverr">FlareSolverr</a> 也是一个代理，它帮助 Jackett 解决向 indexer 的请求能否成功的问题。一些 indexer 为了保护自己免于 DDoS 攻击或减少爬虫请求，会使用 Cloudflare 或一些其他的安全防护服务，如果不做处理，直接请求很可能因触发人机验证而失败。FlareSolverr 就是为解决这类问题诞生的。</p>
<p>在 Jackett 中添加新的 indexer 时，会根据站点情况提示是否需要接入 FlareSolverr 以绕过站点的保护措施。</p>
<h3 id="qbittorrent">qBittorrent</h3>
<p>大部分影视资源都使用 BT 协议进行点对点传输，因此我们也需要一个 BT 下载器，qBittorrent 就是一个很好的选择，它的功能非常全面，且与 Sonarr 有很好的接入支持。如果你已经运行了其他下载器如 Aria2，甚至 QNAP/Synology 自带的 Download Station，那么你也可以参考 <a href="https://wiki.servarr.com/sonarr/supported#downloadclient">Sonarr 支持的下载器列表</a>，尝试进行配置。（我并没有成功使 Sonarr 和 QNAP Download Station 协同工作起来）</p>
<h3 id="部署说明">部署说明</h3>
<p>各个组件介绍完毕，现在让我们进入正题，了解如何配置和部署整个 Sonarr 服务组。</p>
<p>Sonarr 现代化地提供 Docker 镜像的部署方式，因此这个章节将会围绕 Docker 相关的技术进行说明。虽然 <a href="https://www.qnapclub.eu/en/qpkg/652">Qnapclub</a> 也有 Sonarr 的安装包，但经过一番糟心的尝试，最终我只得出一个结论，那就是以后部署任何服务，能 Docker 就尽量 Docker 吧。</p>
<p><details >
  <summary markdown="span">A failed attempt to install Sonarr by qpkg</summary>
  <ul>
<li>error after install: <code>MediaInfo Library could not be loaded libmediainfo.so.0 assembly:&lt;unknown assembly&gt; type:&lt;unknown type&gt; member:(null)</code></li>
<li>dependencies
<ul>
<li><a href="https://www.qnapclub.eu/en/qpkg/193">Qmono</a>: the package is crazily 3GB in size</li>
<li><a href="https://www.qnapclub.eu/en/qpkg/712">MediaInfoCLI</a>
<ul>
<li><a href="https://forum.qnap.com/viewtopic.php?t=147702">https://forum.qnap.com/viewtopic.php?t=147702</a></li>
<li>this is not useful at all</li>
</ul>
</li>
</ul>
</li>
</ul>

</details></p>

<p>我们的部署方案的基本原理是在自己的电脑上通过 Docker 和 Docker compose CLI 对远端 NAS 上的 Docker host 进行操作。这要求读者具备基础的 Docker 相关的知识。</p>
<p>QNAP/Synology 等 NAS 系统提供的 Docker host 与标准实现基本没有差异，因此我们可以直接使用 Docker 官方软件包提供的命令行工具。你也可以使用 NAS 提供的图形化界面，但一则那样在部署多个服务时非常不便，二则如果你了解了如何使用 Docker compose 部署，自然也可以反推到图形化界面的操作方式上。</p>
<h4 id="docker-context">Docker context</h4>
<p>为了与本地的 Docker host 区分开，我们要为 NAS 上的 Docker host 创建一个新的 <a href="https://docs.docker.com/engine/context/working-with-contexts/">context</a>。</p>
<blockquote>
<p><code>harrogath</code> 是我的 NAS 的 hostname，可以使用 IP 代替</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 创建 context</span>
</span></span><span class="line"><span class="cl">docker context create harrogath
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 更新 context 的配置信息</span>
</span></span><span class="line"><span class="cl">docker context update harrogath --docker <span class="s2">&#34;host=tcp://harrogath:2376,ca=</span><span class="nv">$HOME</span><span class="s2">/.docker/ca.pem,cert=</span><span class="nv">$HOME</span><span class="s2">/.docker/cert.pem,key=</span><span class="nv">$HOME</span><span class="s2">/.docker/key.pem&#34;</span>
</span></span></code></pre></div><p>QNAP 的 Docker 需要通过证书来访问，因此要在 Container Station 的设置中下载证书。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-docker-certs.png" type="" alt=""  /></p>
<p>完成 context 创建后，通过 <code>use</code> 命令切换到 context，之后所有的 Docker 命令都是与 NAS Docker 进行通讯</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="l">docker context use harrogath</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">docker context ls</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">NAME                TYPE                DESCRIPTION                               DOCKER ENDPOINT                               KUBERNETES ENDPOINT   ORCHESTRATOR</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">default             moby                Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                                         swarm</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">harrogath *         moby</span><span class="w">
</span></span></span></code></pre></div><h4 id="images">Images</h4>
<p>目前主要有两个组织在维护 Sonarr 及相关服务的 Docker 镜像，<a href="https://www.linuxserver.io/">linuxserver.io</a> 和 <a href="https://hotio.dev/">hotio.dev</a>, 我选择前者作为本次部署的镜像源。下面是使用到的镜像列表，可以在其页面上查看镜像的使用说明。</p>
<ul>
<li><a href="https://hub.docker.com/r/linuxserver/sonarr">linuxserver/sonarr - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/jackett">linuxserver/jackett - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/qbittorrent">linuxserver/qbittorrent - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/flaresolverr/flaresolverr">flaresolverr/flaresolverr - Docker Image | Docker Hub</a></li>
</ul>
<h4 id="hierarchy">Hierarchy</h4>
<p>Sonarr 和它的朋友们需要对 NAS 的存储进行读写，因此在运行服务之前，首先要理解并设计一个好用的目录结构。</p>
<p>我们需要在 NAS 上创建一个 AppData 目录，作为容纳所有服务产生的文件的根目录。AppData 所在的 Volume 建议选择适合存放大量媒体数据的精简卷 (Thin Volume)。</p>
<pre tabindex="0"><code>AppData
├── jackett
│   ├── config
│   └── downloads
├── qbittorrent
│   └── config
└── sonarr
    ├── config
    ├── downloads
    ├── media
    ├── torrents
    └── usenet
</code></pre><p>在 AppData 之下，依次为 sonarr, jackett, qbittorrent 创建目录，每个目录下必须有 <code>config</code> 子目录，用于存放配置文件。flaresolverr 由于是纯网络代理服务不需要对应目录存在。</p>
<p>下面对各个服务的 NAS 目录与容器内目录的映射关系进行说明</p>
<blockquote>
<p>表示为 <code>NAS Directory -&gt; Container Directory</code></p>
</blockquote>
<ul>
<li><strong>sonarr</strong>
<ul>
<li><code>sonarr/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，可在 Sonarr 管理界面向下创建子目录</li>
</ul>
</li>
<li><strong>qbittorrent</strong>
<ul>
<li><code>qbittorrent/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，与 sonarr 保持一致，以便 sonarr 在重命名或移动文件时可以直接使用 qbittorrent 返回的文件路径</li>
</ul>
</li>
<li><strong>jackett</strong>
<ul>
<li><code>jackett/config -&gt; /config</code>: 配置文件</li>
<li><code>jackett/downloads -&gt; /downloads</code>: 默认种子文件下载路径</li>
</ul>
</li>
</ul>
<h4 id="compose-file">Compose file</h4>
<p>以我正在使用的 <code>docker-compose.yml</code> 文件作为示例，你可以复制下来修改自己的版本，只需要将 <code>/share/CACHEDEV2_DATA/Misc/AppData</code> 替换为自己在 NAS 上创建的 <code>AppData</code> 路径即可。</p>
<p>端口的配置需要额外注意，这份配置中我尽量保持各服务默认配置端口不变，若与已有服务冲突，修改到未被占用的端口即可。例如 QNAP 自带的 Download Station 已占用 6881 端口，因此我将 qbittorrent 修改到了 16881 端口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">sonarr</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/sonarr</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">8989</span><span class="p">:</span><span class="m">8989</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr/config:/config</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/etc/localtime:/etc/localtime:ro</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">jackett</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/jackett</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">9117</span><span class="p">:</span><span class="m">9117</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/config:/config</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/downloads:/downloads</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">qbittorrent</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/qbittorrent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">WEBUI_PORT=8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/qbittorrent/config:/config</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">8080</span><span class="p">:</span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="l">/udp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">flaresolverr</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">flaresolverr/flaresolverr</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">LOG_LEVEL=info</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">LOG_HTML=false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">CAPTCHA_SOLVER=${CAPTCHA_SOLVER:-none}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">8191</span><span class="p">:</span><span class="m">8191</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></span></span></code></pre></div><h4 id="run">Run</h4>
<p>一切准备就绪，执行以下命令:</p>
<pre tabindex="0"><code>docker compose up
</code></pre><p>这会启动所有服务并 attach 到终端输出日志，方便查看服务的运行日志。等确认所有服务稳定运行后，加上 <code>-d</code> 参数使其运行在后台。</p>
<pre tabindex="0"><code>docker compose up -d
</code></pre><h3 id="使用说明">使用说明</h3>
<p>下面对各个服务的 Web UI 的使用方法进行说明，以我的 NAS hostname  <code>harrogath</code> 为例展示服务的访问地址。</p>
<h4 id="jackett-1">Jackett</h4>
<p>打开 <code>http://harrogath:9117</code>, Jackett 的界面展示如下:</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett.png" type="" alt=""  /></p>
<p>使用方式非常简单，Jackett 已经将这个世界上绝大部分 indexer 都内置了，只需要点击 Add indexer 搜索并添加即可。除了部分有访问限制的 indexer 需要配置外，基本上都可以一路点击确认完成添加。之后在 Sonarr 中对接时，需要复制订阅 URL 和 API key，参照截图中所示即可。</p>
<p>我目前使用了 4 个 indexer，其中 Bangumi Moe 和 dmhy 用于下载动画番剧，EZTV 和 RARBG 用于下载美剧。</p>
<p>为了使 FlareSolverr 发挥作用，我们还需要将它的 URL 填在最下方的配置中，然后点击 Apply server settings 保存生效。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-1.png" type="" alt=""  /></p>
<h4 id="qbittorrent-1">qBittorrent</h4>
<p>打开 <code>http://harrogath:8080</code>，使用默认用户名密码 <code>admin:adminadmin</code> 登录。</p>
<p>打开 Tools » Options，将 Default Save Path 修改为 <code>/data/downloads</code>。这样做的目的是为了使 qBittorrnet 所记录的文件路径与 Sonarr 保持一致，以便不需要额外配置就能使 Sonarr 的重命名功能正常工作。若你不希望修改下载路径，或使用的是其他下载器，可以参考 <a href="https://trash-guides.info/Sonarr/Sonarr-remote-path-mapping/">Remote Path Mappings</a> 来解决路径不一致的问题。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent.png" type="" alt=""  /></p>
<p>在 Options 中切换到 BitTorrent 选项卡，将 Seeding Limits 下的 &ldquo;then&rdquo; 修改为 &ldquo;Pause torrent&rdquo;，这是为了避免 Sonarr 在删除种子时产生冲突。&ldquo;When ratio reaches&rdquo; 代表做种分享资源的比率。BT 协议提倡共享精神，既然从别人那里获取到自己想要的资源，理应做出回馈。推荐将分享率设置为 2.0，即上传量为下载量的两倍之后停止分享。如果你担心硬盘过度损耗，可以将比率降低。(<em>也可以修改为 0 关闭做种功能，如果克服了道德感的约束</em>)
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent-3.png" type="" alt=""  /></p>
<h4 id="sonarr-1">Sonarr</h4>
<p>终于到了追番大计最核心的组件——Sonarr，但先不要急，在添加番剧前，还有一些设置要做。</p>
<ol>
<li>
<p>Indexers</p>
<ul>
<li>将先前在 Jackett 中添加的 indexers 逐个对接到 Sonarr，使用 Torznab 协议。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-1.png" type="" alt=""  /></li>
<li>Bangumi.moe 的配置展示，URL 和 API Key 都是从 Jackett 中复制过来。需要注意的是， Categories 是影视剧的分类，应该留空，而在 Anime Categories 中勾选所有与番剧相关的分类项。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-2.png" type="" alt=""  />
<ul>
<li>若不确定自己要搜索在资源属于哪个分类项，可在 Jackett 中使用 Manual Search 来确认
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-2.png" type="" alt=""  /></li>
</ul>
</li>
<li>rarbg 的配置展示，由于 rarbg 是影视剧 indexer，我们需要在 Categories 中勾选分类项而将 Anime Categories 留空
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-3.png" type="" alt=""  /></li>
</ul>
</li>
<li>
<p>Download Clients</p>
<ul>
<li>qBittorrent 配置展示。Host 最好填写 IP，使用 hostname 可能会失败。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-qbittorrent.png" type="" alt=""  /></li>
</ul>
</li>
<li>
<p>Profiles</p>
<p>默认只有 English，需要添加一个中文的 Profile 以在添加番剧时设定语言。<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-profile.png" type="" alt=""  /></p>
</li>
<li>
<p>Media Management</p>
<p>这个设置关系到下载的文件能否被 Plex 或其他 media server 识别，但别被眼花缭乱的设置项吓到， 我们只需要关心下图红框圈起的部分。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-mediamanagement.png" type="" alt=""  /></p>
<ul>
<li>首先打开 Rename Episodes 功能</li>
<li>然后配置 Anime Episode Format 和 Season Folder Format，这代表番剧被重命名后的文件名格式和上级目录格式。你不用关心源文件的名称如何被 Sonarr 解析，你只用知道它自信并出色地完成了这项脏活，让我们可以使用变量定义想要的文件和目录名称。这里我使用的是 Plex 的 <a href="https://support.plex.tv/articles/naming-and-organizing-your-tv-show-files/">TV Show Files</a> 格式，实现的结果如下: <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/finder.png" type="" alt=""  /></li>
<li>最后配置 Root Folders，它们在添加番剧的时候会用到，作为放置番剧的目录。你可以根据自己的需求设置多个，一般来说设置两个将影视剧和动画番剧分开存放即可。还记得我们在 <code>docker-compose.yaml</code> 中配置的目录映射吗？这里的目录 <code>/data/media/anime tv</code> 在 NAS 中对应的是 <code>AppData/sonarr/data/media/anime tv</code>，在 Plex 添加媒体库时不要忘了如何找到它。</li>
<li>Optional: 文件重命名时，Sonarr 默认采取移动策略，这样会导致 BT 下载器无法继续对资源做种，为了避免这种情况，在 Media Management 页面打开 Advanced Settings，找到并打开 &ldquo;Use Hardlinks instead of Copy&rdquo;，这样既保留了下载资源的原始路径，又不会额外占用硬盘空间。</li>
</ul>
</li>
<li>
<p>Connect</p>
<p>实现自动化追剧的目的是为了不需要人工检查剧集的更新情况，因此通知是必不可少的。Connect 可以连接许多通知服务，让你第一时间知道剧集何时上线，资源何时发布，何时完成下载、可以观看。下面说明如何对接 Telegram 获取通知信息。</p>
<ul>
<li>
<p>在 Telegram 搜索机器人 <code>@BotFather</code>，按照提示创建一个新的机器人，获取 API Token。我的机器人名为 <code>@reorx_notify_bot</code>。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-2.png" type="" alt=""  /></p>
</li>
<li>
<p>创建一个群组，将 bot 加入到群组中，请求接口 <code>https://api.telegram.org/bot&lt;TOKEN&gt;/getUpdates</code>, 取出返回结果中的 <code>result[0].channel_post.chat.id</code> 作为 chat id</p>
<blockquote>
<p>方法来自 <a href="https://stackoverflow.com/a/61215414/596206">How to obtain Telegram chat_id for a specific user?</a></p>
</blockquote>
<ul>
<li>2022-08-11 updated: 也可以通过将 <code>@getidsbot</code> 邀请到群组中来获得 chat id，这个方法更加简单便捷</li>
</ul>
</li>
<li>
<p>在 Sonarr 中添加 Telegram connection，勾选自己关心的通知类型，一般至少会选择 On Download，代表新剧集下载完成的时间。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram.png" type="" alt=""  /></p>
</li>
<li>
<p>配置好后，就可以通过 Telegram 第一时间掌握番剧的更新情况了。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-1.png" type="" alt=""  /></p>
</li>
</ul>
</li>
</ol>
<h4 id="开始追剧">开始追剧</h4>
<p>配置完成，现在可以开始追剧了。下面以「盾之勇者成名录 第二季」为例说明在 Sonarr 添加番剧的过程。</p>
<p>打开 <a href="https://thetvdb.com/">TheTVDB.com</a>, 搜索到你想要追踪的番剧的页面 <a href="https://thetvdb.com/series/the-rising-of-the-shield-hero">The Rising of the Shield Hero</a>，获取 URL 中的最后一段 <code>the-rising-of-the-shield-hero</code> 作为在 Sonarr 搜索关键词。</p>
<p>打开 Sonarr，在左上角的 Search 框中输入 <code>the-rising-of-the-shield-hero</code>，点击搜索结果，进入添加番剧的界面。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-6.png" type="" alt=""  /></p>
<ol>
<li>Root Folder: 选择先前在 Media Management 中设置的 <code>anime tv</code></li>
<li>Monitor: 由于我们只想看最近的第二季，因此选择 Only Latest Season</li>
<li>Quality Profile: 选择 HD-1080p 或其他你需要的格式/分辨率</li>
<li>Language Profile: 选择 Chinese</li>
<li>Series Type: 选择 Anime，这里对应的是添加 Indexer 时的 Anime Categories 选项，告诉 Sonarr 从 Indexer 的 Anime Categories 中搜索资源。如果使用默认的 Standard（对应 Indexer 的 Categories），将会导致无法搜索到资源。</li>
<li>Season Folder: 勾选，为了对应 Plex 要求的目录结构</li>
<li>Start search for missing episodes: 勾选，这会使 Sonarr 在添加番剧后立刻根据 Monitor 所设置的条件开始搜索资源。也可以在添加完成后在详情页手动点击触发。</li>
</ol>
<p>完成添加后，点击番剧进入详情页。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-7.png" type="" alt=""  /></p>
<ol>
<li>点击放大镜图标对其所在的 Season 进行剧集搜索。</li>
<li>Status 列的图标说明
<ul>
<li>🕓: 尚未播出，不会进行监控</li>
<li>⚠️: 已播出，硬盘中还没有资源，正在进行监控</li>
<li>☁️ 或进度条: 已开始下载</li>
</ul>
</li>
<li>书签符号有填充代表该季处于正在监控状态，无填充代表未监控，可以点击手动设置为监控</li>
</ol>
<p>在 Sonarr 首页可以看到各个番剧的追踪状态，蓝色代表标记追踪的剧集都已下载完成，红色代表有缺失，正在持续监控中。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-5.png" type="" alt=""  /></p>
<p>下载了一些资源后，我们打开 Plex，将 <code>anime tv</code> 对应的路径添加到「动画」Library 中，Plex 就会开始自动扫描文件、刮削元数据、下载中文字幕了。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex.png" type="" alt=""  /></p>
<p>大功告成，在 Plex 上愉快看番吧☺️。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex-1.png" type="" alt=""  /></p>
<h2 id="番外">番外</h2>
<h3 id="sonarr-的其他朋友们">Sonarr 的其他朋友们</h3>
<ul>
<li><a href="https://radarr.video/">Radarr</a>
Radarr 是 Sonarr 的兄弟项目，Sonarr 专精于追剧，Radarr 专精于追踪电影</li>
<li><a href="https://www.bazarr.media/">Bazarr</a>
Bazarr 用于自动下载字幕文件，由于 Plex 本身具有这个功能，以及大部分动漫资源都有内置字幕，因此不是特别有必要部署</li>
<li><a href="https://lidarr.audio/">Lidarr</a>
Lidarr 是音乐专辑的追踪和下载器，适用于喜欢收藏本地音乐文件的用户</li>
<li><a href="https://readarr.com/">Readarr</a>
Readarr 是电子书的追踪和下载器。我看书不多，偶尔需要看的书一般从 zlibrary 下载，Calibre 足够满足我的管理需求。</li>
</ul>
<h3 id="lunasea">LunaSea</h3>
<p><a href="https://www.lunasea.app/">LunaSea</a> 是一个 Sonarr 和 Usenet 生态圈的远程控制器，能让你在手机上查看 Sonarr / Radarr / Lidarr 的资源和放送时间表。</p>

<figure class="center align-center">
  <div class="image-size-control" style="height: 600px;">
    <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/lunasea.jpeg" type="" alt=""  />
  </div>

  <figcaption><p>LunaSea iOS app screenshot</p></figcaption>
</figure>

<h3 id="seedboxio">Seedbox.io</h3>
<p>在得知我最近的折腾经过后，我的好朋友 <a href="https://wzyboy.im/">wzyboy</a> 向我科普了一种名为 <a href="https://en.wikipedia.org/wiki/Seedbox">Seedbox</a> 的 hosted service，提供开箱即用的 BT 下载和家庭媒体服务器，并能带来以下几点好处：</p>
<ul>
<li>免于折腾和维护诸多服务/服务器</li>
<li>发扬 BT 分享精神的同时无需损耗自己的硬盘</li>
<li>规避 P2P 下载资源的版权问题</li>
</ul>
<p>其中有一家服务商叫 seedbox.io, 它们的服务器包含本篇介绍的所有组件。如果你有兴趣的话，可以通过这个 <a href="https://panel.seedbox.io/aff.php?aff=1061">affiliate link</a> 注册和购买他们的服务。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/seedbox-apps.png" type="" alt=""  /></p>
<h2 id="结语">结语</h2>
<p>Sonarr 和它的朋友们还有许多功能，本篇旨在引导用户完成最基本的自动化追番配置，就不一一介绍了，有兴趣的读者可以自行探索，欢迎在评论区留言分享。</p>
<p>近两年来，在家办公越来越融入到我们的生活，家庭网络和服务的搭建也逐渐从以往对 Geek 的刻板印象，变成或许没被意识到，但人人都有的需求。照片存储、数据备份、远程控制、环境监控、智能家居、多媒体娱乐…这些无一不是我们的日常所需。往后我会写更多这方面的文章，将我使用 NAS 改变生活方式的过程记录下来。The digital life has just begun.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://wiki.servarr.com/">WikiArr</a></li>
<li><a href="https://trash-guides.info/">TRaSH Guides</a></li>
</ul>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-04-19: created with &ldquo;使用 QNAP Download Station&rdquo;</li>
<li>2022-05-02: added &ldquo;使用 Sonarr 和它的朋友们&rdquo;, finished &ldquo;部署说明&rdquo;</li>
<li>2022-05-04: finished &ldquo;使用说明&rdquo; and the whole article</li>
<li>2022-08-11: added using <code>@getidsbot</code> to find Chat ID in Telegram</li>
</ul>
]]></content:encoded></item></channel></rss>