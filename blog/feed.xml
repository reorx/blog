<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Blogs on Reorx’s Forge</title><link>https://reorx.com/blog/</link><description>Recent content in Blogs on Reorx’s Forge</description><image><url>https://reorx.com/forge-v2-compat.svg</url><link>https://reorx.com/forge-v2-compat.svg</link></image><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 30 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://reorx.com/blog/feed.xml" rel="self" type="application/rss+xml"/><item><title>种草无线便携路由器</title><link>https://reorx.com/blog/travel-routers/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/travel-routers/</guid><description>介绍无线便携路由器 Travel Router 的功能和产品，并对比说明它与 Wi-Fi 信号放大器和随身 Wi-Fi 的差异。</description><content:encoded><![CDATA[<p>时间回到两个月前的某天，和好友 <a href="https://github.com/xwjdsh">@iwendellsun</a> 一起在咖啡馆工作时，他提出了一个问题：有没有一种路由器，它可以先连接一个已有的 Wi-Fi，再发射一个新的 Wi-Fi 供自己的设备连接？</p>
<p>我立刻理解了这个诉求的来源。咖啡馆、图书馆等场所的公共 Wi-Fi 一般都有身份验证机制，连接超过一个设备就会感觉很不方便，更不用说每个设备都还要独立设置代理；如果多人在一起工作，联机调试很可能会遇到公共 Wi-Fi 的端口限制而无法成功。我们对这个需求讨论了一番，但两人都缺乏对这类产品的认识，便不了了之。</p>
<p>最近在 Twitter 上看到 <a href="https://twitter.com/pengchujin">@酱紫表</a> 分享了一款产品，突然意识到这可能正是我们想要的东西:</p>
<div class="tweet social-quote">
  <div class="title">
    <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>

    
  </div>

  <blockquote class="twitter-tweet" data-dnt="true"><p lang="zh" dir="ltr">收到了一款非常有趣的产品— GL-AXT1800，我喜欢这款路由器的地方实在有点多：迷你的体积带出门很方便、高通 IPQ6000 的 CPU 性能足够强大、出厂自带 openwrt 和 uboot 真的方便、type c 电源口、支持 usb 3.0 还有 Wi-Fi 6、还自带 pwm 风扇。 <a href="https://t.co/5gAFEdiGkH">pic.twitter.com/5gAFEdiGkH</a></p>&mdash; 酱紫表 (@pengchujin) <a href="https://twitter.com/pengchujin/status/1542120681520844801?ref_src=twsrc%5Etfw">June 29, 2022</a></blockquote>

</div>


<p>虽然没有提及这款名为 <a href="https://www.gl-inet.com/products/gl-axt1800/">GL-AXT1800</a> 的路由器是否可以连接已有 Wi-Fi，但既然设计的这么小巧便携，应该是针对出门在外的应用场景吧？我如此寻思，注意到它在 GL.iNet 的产品矩阵中属于 Travel Router 这一分类，于是顺着这个关键词进行了一番搜索，果然发现这类产品大都有着和我们的需求一致的应用场景。</p>
<p>我随后去阅读了 GL.iNet 的<a href="https://docs.gl-inet.com/en/4/user_guide/">官方使用手册</a>，弄清了 GL-AXT1800 所支持的四种连接互联网的模式：</p>
<ul>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_ethernet">Connect to the Internet via an ethernet cable</a></p>
<p>通过网线连接互联网。GL 的路由器都有一个 WAN 口，这种用法与通常的家用路由器一致，连接在光猫或已有路由器的后面。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_repeater">Connect to the Internet via an existing Wi-Fi</a></p>
<p>通过已有 Wi-Fi 连接互联网。这就是本文一开始所提到的在咖啡馆中的使用场景，将公共 Wi-Fi 扩展成为相对安全可控的局域网。</p>
<p>一些公共 Wi-Fi 要求对手机号/身份证等进行验证方可连接互联网，使用无线便携路由器是否会影响验证流程呢？我初步判断是不会，这种验证发生在连接 Wi-Fi 时的密码验证之后，此时无线便携路由器已完成了连接已有 Wi-Fi 并创建新的局域网的工作，假设公共 Wi-Fi 的 IP 是 192.168.1.1，无线便携路由器是 192.168.50.1，我们访问互联网触发的对 192.168.1.1 验证界面的访问是完全没有问题的，类似在家庭双层 NAT 环境下访问光猫的管理界面，DHCP 会处理好不同网段 IP 的访问关系。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_tethering">Connect to the Internet via usb tethering</a></p>
<p>通过 USB-A 口连接手机，使用手机的移动网络连接互联网。这种模式需要打开手机的热点功能，使用有线以降低传输损耗。</p>
</li>
<li>
<p><a href="https://docs.gl-inet.com/en/4/tutorials/internet_cellular">Connect to the Internet via usb modem</a></p>
<p>通过 USB 调制解调器连接互联网。这种模式将只能插在笔记本电脑上的传统的无线上网卡变成可供多人使用的 Wi-Fi。</p>
</li>
</ul>
<p>这些模式基本可以定义出 Travel Router——无线便携路由器的主要功能，读者可思考其中是否有符合自己需求的功能，从而对这种产品做出种草或拔草的判断。</p>
<h2 id="同类产品介绍">同类产品介绍</h2>
<p>说完了什么是无线便携路由器，我们再来看看有哪些可供选择的同类产品。</p>
<h3 id="单板机-diy">单板机 DIY</h3>
<p>弄清楚产品功能之后，我发现家里被用作软路由<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 的 <a href="https://www.friendlyelec.com/index.php?route=product/product&amp;product_id=282">NanoPi R2S</a> 是可以成为无线便携路由器的，只不过还需要对系统和配件进行一些 DIY 配置。</p>
<p>一个未经雕琢的 R2S 长这样:</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/r2s.png" type="" alt=""  />
  </div>

  <figcaption><p>NanoPi R2S original</p></figcaption>
</figure>

<p>插上一个外置的无线扩展模块，它从结构上就与 GL-AXT1800 一般无二了:</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/r2s-2.png" type="" alt=""  />
  </div>

  <figcaption><p>NanoPi R2S with wireless adapter</p></figcaption>
</figure>

<blockquote>
<p>Note 1: 不过这样使用也有局限，由于 R2S 只有一个 USB-A 口，当扩展为 Wi-Fi 天线后，就无法实现上文提到的 USB tethering/modem 模式了。</p>
<p>Note 2: 据推友 <a href="https://twitter.com/q1ngyang">@q1ngyang</a> 告知 <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，R2S 网卡方案有点麻烦，固件大多用不了无线网卡或无法驱动 AC，因此 R2S 不见得是最好的选择，若要使用 SBC 进行 DIY，还请读者在多方考察后慎重行事。</p>
</blockquote>
<p>实际上树莓派等其他 <a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a> 也可以用同样的思路配置实现，不过我更喜欢 NanoPi 的外形和亲民的价格（去年好像涨价了），感兴趣的读者可以在淘宝认准 FriendlyElec 官方店购买。</p>
<p>固件方面，使用 OpenWrt 或其发行版即可，通过 Wi-Fi 连接互联网是 OpenWrt 的基础功能之一，官方文档对此有着非常详细的说明: <a href="https://openwrt.org/docs/guide-user/network/wifi/relay_configuration">Wi-Fi extender / repeater / bridge configuration</a>.</p>
<h3 id="纯硬件产品">纯硬件产品</h3>
<p><a href="https://www.gl-inet.com/products/gl-axt1800/">GL-AXT1800</a> 即属于此类，在硬件层面已经高度集成和完善，但固件、代理等还需用户自行配置。GL.iNet 系产品的优点之一是自带基于 OpenWrt 开发的固件 <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，功能足够强大，省去了自己刷的麻烦。</p>
<p>下面列举 GL.iNet 的其他几款 Travel Routers:</p>
<ul>
<li>
<p><a href="https://www.gl-inet.com/products/gl-mt300n-v2/">GL-MT300N-V2</a></p>
<p>昵称 Mango 芒果，有着鲜明的颜色和与 R2S 近似的小巧外形。电源输入是 5V/2A，相比 GL-AXT1800 的 5V/4A 对充电头更加友好。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/mango.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-MT300N-V2, AKA Mango</p></figcaption>
</figure>

</li>
<li>
<p><a href="https://www.gl-inet.com/products/gl-ar300m/">GL-AR300M</a></p>
<p>黑色并升级了 CPU 的 GL-MT300N-V2。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-ar300m.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-AR300M</p></figcaption>
</figure>

</li>
<li>
<p><a href="https://www.gl-inet.com/products/gl-usb150/">GL-USB150</a></p>
<p>传统 U 盘的大小，可以直接插在充电器 USB-A 口上使用。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-usb150.png" type="" alt=""  />
  </div>

  <figcaption><p>GL-USB150</p></figcaption>
</figure>

</li>
</ul>
<p>其他品牌中，TP-Link 有一款 <a href="https://www.tp-link.com/us/home-networking/wifi-router/tl-wr902ac/">TL-WR902AC</a> 和 GL-MT300N-V2 类似，支持刷入 OpenWrt <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/TL-WR902AC.png" type="" alt=""  />
  </div>

  <figcaption><p>TP-Link TL-WR902AC</p></figcaption>
</figure>

<h3 id="硬件--服务">硬件 + 服务</h3>
<p>推友 <a href="https://twitter.com/BigEyeSmolMouth">@BigEyeSmolMouth</a>  向我分享了<a href="https://www.meihuavpn.com/">梅花VPN</a> <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>，使我得知有这类产品的存在。它们就像网易的 UU 加速盒，在硬件上内置了自己的网络代理服务，实现成软硬一体化的翻墙 Wi-Fi。</p>
<p>在我看来，这种产品优缺点都很明显。优点是开箱即用，省事不折腾；缺点是可控性差，无法更换代理提供商，且商品的溢价较高，其硬件性能不会有多少剩余空间。从安全的角度考虑，这样一个黑盒设备也无法让人信任。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/meihua.png" type="" alt=""  />
  </div>

  <figcaption><p>梅花M3家用版</p></figcaption>
</figure>


<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/meihua-1.png" type="" alt=""  />
  </div>

  <figcaption><p>梅花M3便携版</p></figcaption>
</figure>

<blockquote>
<p><a href="https://www.meihuavpn.com/collections/shop/products/11offer-h">官网</a>的 spec 中没有关于 CPU、固件、协议等信息的描述。</p>
</blockquote>
<h2 id="相似但不同的产品">相似但不同的产品</h2>
<p>看过上文对无线便携路由器的介绍后，你是否有种似曾相识的感觉？没错，其实有一些与之类似但却不同的产品存在，平时没有用过也多少见过，这也是我在一开始未能准确把握自己想要什么产品的原因，它们都存在硬件或功能上的共性。下面我将针对两种可以明确定义出功能边界的设备进行阐述。</p>
<h3 id="wi-fi-信号放大器">Wi-Fi 信号放大器</h3>
<p>也有人将其称为「无线中继」，比较准确的英文名称应该是 Range Extender。这类产品的核心用途是接收已有 Wi-Fi 的信号，作为 <a href="https://en.wikipedia.org/wiki/Wireless_access_point">AP</a> 发射出相同的 SSID，以达到延长其信号范围的目的。一般用在家庭、办公室等空间较大、Wi-Fi 信号容易衰减的环境。</p>
<p>它和无线便携路由器在接收 Wi-Fi 信号这件事情上使用了相同的技术 <a href="https://en.wikipedia.org/wiki/Wireless_distribution_system">WDS</a>，但一个是扩展已有的 LAN，一个是创建新的 LAN，用途的差异使两者最终呈现出不同的产品形态。可以把 Wi-Fi 信号放大器看做特化的无线便携路由器。</p>
<p>TP-Link 有很多<a href="https://www.tp-link.com/hk/home-networking/range-extender/">此类产品</a>，它们的外形通常像耳朵长着天线的机器人🤖</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/TPLink-RE605X.png" type="" alt=""  />
  </div>

  <figcaption><p>TP-Link RE605X</p></figcaption>
</figure>

<h3 id="随身-wi-fi">随身 Wi-Fi</h3>
<p>也叫「无线上网卡」，比较准确的英文名称应该是 Mobile Wi-Fi Router (or 4G Wi-Fi Router)。这类产品的目的是使用 3G/4G LTE 创建随时随地可供使用的 Wi-Fi。分为内置 eSIM 卡和依赖外部 SIM 卡两种。</p>
<p>国内的随身 Wi-Fi 一般都是内置 eSIM 卡的，外形像 U 盘或充电宝，在设计上并没有提供多少可定制性，但由于其普及程度非常高，广大 DIY 爱好者早已将其研究通透。<a href="https://twitter.com/pengchujin">@酱紫表</a> 分享过一篇 <a href="https://qust.me/post/msm8916/">4g 随身 Wi-Fi 刷 openwrt 变成软路由</a> 教程，成品展示在这条<a href="https://twitter.com/pengchujin/status/1536310680109735936">推文</a>中。</p>
<blockquote>
<p>其实在刷上 OpenWrt 后，随身 Wi-Fi 就等同于上文中 <a href="https://docs.gl-inet.com/en/4/tutorials/internet_cellular/">Connect to the Internet via cellular</a> 模式下的  GL.iNet，因此它同样可以看做无线便携路由器的特化版。</p>
</blockquote>
<p>Netgear 的 <a href="https://www.netgear.com/home/mobile-wifi/hotspots/mr1100/">MR1100</a> 则是插卡的，黑色金属质地体现出服务器特有的冷酷和科技感，还有着让我无法抗拒的数据指示屏。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/netgear.png" type="" alt=""  />
  </div>

  <figcaption><p>Netgear MR1100</p></figcaption>
</figure>

<p>另一款值得一提的产品是 GL.iNet 的 <a href="https://www.gl-inet.com/products/gl-e750/">GL-E750</a>，它同时具备无线便携路由器和随身 Wi-Fi 的功能，并且可以通过内置的 7000mAh 供电，相当于 GL-MT300N-V2 + 上网卡 + 充电宝的 all-in-one 组合。在咖啡馆可以连接公共 Wi-Fi 并接线充电，在户外则可以使用移动网络不依赖电源，简直是理想中的产品。但一般来说，越是什么都会，越可能什么都不精，GL-E750 具体表现如何，只有真正入手使用后才能知道。</p>

<figure class="center align-center">
  <div class="image-size-control" style="max-width: 500px;">
    <img loading="lazy" src="/blog/travel-routers/images/gl-e750.png" type="" alt=""  />
  </div>

  <figcaption><p>GL.iNet Mudi (GL-E750)</p></figcaption>
</figure>

<h2 id="结语">结语</h2>
<p>在移动办公越来越广泛的今天，无论你是时常出差办公的技术工作者，还是四海为家的数字游民，无线便携路由器都是值得了解和尝试的产品。数据和隐私是无价的，当连接到公共 Wi-Fi 时，我们的设备便存在被攻击和窃取数据的风险，而通过无线便携路由器，我们可以在一个可控的局域网中管理设备、增加防护，获得更安全的办公环境和更高效的生产力。</p>
<p>本文仅对一些无线便携路由器做了简单的列举，不涉及传输和加密性能的测评，由于我还没有实际使用过，因此无法对这些产品的好坏做出评价，读者将本文当做科普知识的分享即可。在未来我会补充一篇实际的产品使用体验，如果你使用过这一类产品，欢迎在评论区或 Twitter 分享你的经验。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-06-30: created</li>
<li>2022-07-02: add GL-E750</li>
<li>2022-07-09: update R2S notes</li>
<li>2022-07-10: 添加关于「使用无线便携路由器是否会影响公共 Wi-Fi 手机号验证流程」的描述</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>见推文 <a href="https://twitter.com/novoreorx/status/1412406192845033473">https://twitter.com/novoreorx/status/1412406192845033473</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>见推文 <a href="https://twitter.com/q1ngyang/status/1543116478987190275">https://twitter.com/q1ngyang/status/1543116478987190275</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>见 GitHub 项目页 <a href="https://github.com/gl-inet/openwrt">https://github.com/gl-inet/openwrt</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>见 OpenWrt 官网的硬件支持页面: <a href="https://openwrt.org/toh/tp-link/tl-wr902ac_v3">https://openwrt.org/toh/tp-link/tl-wr902ac_v3</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>见推文 <a href="https://twitter.com/BigEyeSmolMouth/status/1542379014970417153">https://twitter.com/BigEyeSmolMouth/status/1542379014970417153</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>更换博客评论系统</title><link>https://reorx.com/blog/blog-commenting-systems/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/blog-commenting-systems/</guid><description>整理了一份比较完整的评论系统评测列表，并详细介绍了最终选择的 Remark42。</description><content:encoded><![CDATA[<h2 id="告别-disqus">告别 Disqus</h2>
<p>博客建成也有一段时日了，渐渐也会收到一些读者的评论，在和大家交流中学到了很多新的知识，我很喜欢这种感觉，把评论看做我和读者之间重要的交流渠道。有一天我收到了 <a href="https://twitter.com/geekdada">@geekdada</a> 在 <a href="/blog/deploy-umami-for-personal-website/">搭建 umami …</a> 下的留言:</p>
<blockquote>
<p>非常感谢推荐。不知道作者有没有想把 Disqus 换掉，又臃肿又收集数据。</p>
</blockquote>
<p>于是我开始留意起 Disqus 的使用体验。其实我在 2013 年就注册了 Disqus，用在了自己最早的一版个人网站上，对它也算是有些感情，这也是一开始快速实现时选择它的原因。</p>
<p>我打开 Chrome Dev Tools，刷新文章页，果然看见一大堆请求，一共有 94 次，这可太恶心了！且不论它收集了哪些统计数据和用户隐私，光是数量之多就让有代码洁癖的我无法忍受。</p>
<p><img loading="lazy" src="/blog/blog-commenting-systems/images/disqus.png" type="" alt=""  /></p>
<p>再试探性地关掉 ublock，这下更不得了，显示出有半个屏幕之大的广告区域，充斥着猎奇的图片和 clickbait 标题的链接。去设置页看了下，果然只有付费用户才可以关闭广告，但接连被恶心到，我已经彻底决定抛弃 Disqus。</p>
<p>就像之前从 Google analytics 换到 umami 那样，我踏上了寻找新的评论系统的旅程。</p>
<h2 id="评论系统的选择">评论系统的选择</h2>
<p>经过一番调查，我大致将评论系统分为了如下几类，每类都放上我认为最好的几种可选项，为同样带着自己的需求寻找评论系统的读者提供参考。</p>
<ul>
<li>
<p><strong>Full-fledged</strong></p>
<p>全功能的评论系统，从前端的 UI 组件到后端的 API、数据存储都完整实现。其下又分为 SaaS 和 Self-hosted 两类。</p>
<ul>
<li>
<p><strong>SaaS</strong></p>
<p>Disqus 就是属于这一类产品，优点是配置便捷，不用操心；缺点则是可能会收集隐私数据，缺乏可控性，并且价格都比较贵。</p>
<ul>
<li><a href="https://commento.io/">Commento</a>: 目前是我最喜欢的一个 SaaS 评论系统，界面简洁清爽，能适应大部分博客的主题样式，无广告和追踪。价格为每月 $10。</li>
<li><a href="https://commentbox.io/">CommentBox</a>: 我很早收藏过的一个评论系统，和 Commento 一样的 slogan 和价格，就是功能和设计看起来要弱一些。</li>
</ul>
</li>
<li>
<p><strong>Self-hosted</strong></p>
<p>与一般的互联网服务不同，评论系统中 Self-hosted 的比例反而比 SaaS 化的大很多，这大概是因为自建博客的市场比较小众，且使用者也多为喜欢造轮子的程序员。Self-hosted 虽然较为麻烦，但优势也非常明显——由开源带来的高可控性、高定制性，并且近年来 PaaS 平台的蓬勃发展大大降低了部署成本，不需要拥有服务器便可一条龙 0 元购搭建起来。因此如果你有一定的技术基础，非常建议尝试自部署一套评论系统。</p>
<ul>
<li><a href="https://github.com/umputun/remark42">Remark42</a>: 我最喜欢的一个 self-hosted 评论系统，也是本文接下来所要讲解的对象。</li>
<li><a href="https://github.com/posativ/isso">Isso</a>: 使用 Python 开发，数据库为 SQLite。界面复古而简洁，适合 minimalist。Isso 可以配置评论自动通过，或者先审核再通过。</li>
<li><a href="https://github.com/djyde/cusdis">Cusdis</a>: 我很佩服的开发者 <a href="https://lutaonan.com/">Randy</a> 的作品，也是使用 SQLite 作为数据库，就像是 Isso 的 Nodejs 翻版，但界面更加美观。与 Isso 不同的是，Cusdis 要求评论必须通过人工审核才可以显示，提供了 Email 和 Dashboard 两种审核方式。</li>
<li><a href="https://github.com/adtac/commento">Commento</a>: SaaS Commento 的开源版，使用 Go 开发，支持各种 social auth 登录，甚至可以配置 SSO。但这个项目已经停止更新一年多了，如果你有兴趣，可以考虑使用社区 fork 维护的 <a href="https://github.com/souramoo/commentoplusplus">Commento++</a>，作者的更新还挺活跃的。</li>
<li><a href="https://twikoo.js.org/">Twikoo</a>, <a href="https://artalk.js.org/">Artalk</a>, <a href="https://valine.js.org/">Valine</a>: 三者都是面向国内用户所开发的评论系统，有很多相似之处，因此放在一起介绍。与上述其他项目不同的是，三者的接入方式并非 iframe，而是直接操作网页的 DOM 元素。
<ul>
<li>Twikoo 主要支持腾讯云 CloudBase，也可以部署到 Vercel。数据库是 MongoDB。更新<a href="https://github.com/imaegoo/twikoo/graphs/contributors">比较活跃</a>。</li>
<li>Artalk 使用 Go 开发，无部署环境限制，支持常见的 RDBMS。更新<a href="https://github.com/ArtalkJS/Artalk/graphs/contributors">近期较为活跃</a>。
<mark>Artalk 的作者 <a href="https://qwqaq.com/about/">qwqcode</a> 去年高考步入大学，开发 Artalk 的时候刚上高一。在三年里独立完成 Artalk 从 PHP 向 Go 的架构转变，TypeScript 也写的贼溜，<a href="https://twitter.com/novoreorx/status/1532175668766683136">现在的年轻人真是越来越强了</a></mark>。</li>
<li>Valine 似乎只支持 LeanCloud 部署，已经<a href="https://github.com/xCss/Valine/graphs/contributors">很久没有更新</a>了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Proxied</strong></p>
<p>类似 full-fledged，有自己实现的 UI 和 API，但数据存储依托于一个已有的其他服务。我个人并不偏爱此类应用，一者登录方式被限制在其所依托的服务上，再者数据也不好维护。</p>
<ul>
<li><a href="https://github.com/utterance/utterances">utterances</a>: 应该是最早的基于 GitHub 的评论系统，提供了一个用于接入评论的公开服务。</li>
<li><a href="https://github.com/giscus/giscus">giscus</a>: utterances 的 fork 版，增加了自部署的能力。</li>
</ul>
</li>
<li>
<p><strong>IM Plugin</strong></p>
<p>由即时通讯服务提供的插件。这是个顺理成章的思路，对于即时通许服务商来说，可以利用已有的基础设施提供更多的 user engagement，何乐而不为呢。其中最为知名的当属 Facebook，Google 曾经也有，但和 Google Plus 一同被埋葬了。这种评论系统也存在登录方式单一的问题，请谨慎选择。</p>
<ul>
<li><a href="https://comments.app/">Comments.app</a>: Telegram 提供的网站评论插件，使用简便，界面美观，支持 dark mode 和 accent color。</li>
<li><a href="https://core.telegram.org/widgets/discussion">Discussion Widget</a>: 同样是 Telegram 的服务，但与 Comments.app 的不同在于，Discussion Widget 原本的设计目的是将 Channel 消息中的评论嵌入到网页中，但我发现这同样是一种评论系统，并且多出了将评论对应到 Channel 消息的功能。我在探索中已经顺便将 Discussion Widget 实现到了博客主题中，你可以在这个页面中预览和尝试: <a href="/playground/comment-telegram/">Commenting System: Telegram Widget</a></li>
<li><a href="https://developers.facebook.com/docs/plugins/comments/?locale=en_US">Meta Comments Plugin</a>: Meta (Facebook) 的评论插件，我的社交圈里基本没人使用 Facebook，因此不予评价。</li>
</ul>
</li>
<li>
<p><strong>Static</strong></p>
<p>静态评论，即评论作为静态网站原始数据的一部分，跟随网站的构建流程生成到页面中。不同于其他评论系统可以灵活嵌入到任何页面，静态评论只能用于静态网站中。评论的数据是否应该属于网站本身呢？这是一个非常两极分化的问题。</p>
<ul>
<li><a href="https://welcomments.io/">Welcomments</a>: 静态评论 SaaS 服务，需要用户绑定自己网站的 GitHub 仓库。当有人评论时，Welcomments 会生成一个 commit 包含评论的数据提交到仓库中，触发 GitHub 的自动构建流程，将评论更新到静态网页中。Welcomments 支持在它的网站上进行评论审核，还接入了 <a href="https://akismet.com/">Akismet</a> anti-spam 服务，每月 $6，年付减为 $4。</li>
<li><a href="https://github.com/eduardoboucas/staticman">Staticman</a>: 更为强大的 Welcomments，并且是 self-hosted。Staticman 支持更多的代码托管平台，并且可以通过 pull-request 的方式审核评论，这才是基于 Git 的工作流应有的样子。但 Staticman 已经有 2 年没更新了，在进行更深入的调研之前，不建议作为第一选择。</li>
<li>手动维护: 任何手动维护评论的方式。有的博主会在网站会留下邮箱、即时通讯号等联系方式，让读者将想要评论的内容发送过去，然后将评论内容手动更新到文章的评论区。这种方式虽然简陋，但也不失为一种最简单的实现手段，毕竟评论的本质就是交流。</li>
</ul>
</li>
</ul>
<h2 id="我的选择-remark42">我的选择: Remark42</h2>
<p>基于如下这些原因，我在众多评论系统中选择了 Remark42。</p>
<h3 id="技术层面">技术层面</h3>
<ul>
<li>它使用 Go 语言实现，我很难抗拒二进制单文件的诱惑。</li>
<li>它使用基于文件的数据库。我最喜欢的数据库是 SQLite，单文件无任何依赖，Remark42 使用的 <a href="https://github.com/etcd-io/bbolt">boltdb</a> 也是基于文件，对我来说和 SQLite 一样美好。</li>
<li>它有较为现代化的前端技术栈，使用 TypeScript, Preact, Postcss 开发。</li>
<li>它是一个成熟的开源项目，文档全面、开发时间长，基本上我的任何问题都可以在文档和 Issues 中找到解答。</li>
<li>它的 <a href="https://remark42.com/docs/contributing/api/">API</a> 非常完善，比如导入导出都可以用一行 curl 来完成。在其他方面作者也显示出很高的<a href="https://remark42.com/docs/contributing/technical-details/">技术品味</a>。</li>
</ul>
<h3 id="视觉层面">视觉层面</h3>
<p>Remark42 界面简洁美观，虽然比 Isso 和 Cusdis 复杂，但依然保持了足够的适应性和可塑性。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/blog-commenting-systems/images/remark42-1.png" type="" alt=""  />

  <figcaption><p>Remark42 简洁的界面</p></figcaption>
</figure>

<h3 id="功能层面">功能层面</h3>
<p>我其实不喜欢 pre-moderation，即评论必须先通过审核才可以显示，这会给我带来额外的工作量，并且评论者也没法得到即时的效果反馈。但我也不想开放无审核的匿名评论，给自己带来被评论机器人攻击的风险。</p>
<p>我想到的折中方案是，首先提供尽可能多的 social auth 登录方式，比如 Twitter, Google, GitHub，这些 Remark42 都支持；再提供一种基于邮箱的认证方式，这是 Remark42 最大的亮点——Passwordless Authentication。评论者输入邮箱，点击 login，Remark42 会向其发送一个含有 token 的邮件，评论者使用这个 token 完成登入便可以进行评论。</p>
<p>邮箱认证是我个人最喜欢的登录方式，因为社交账号登录总是会存在风险，服务会拿到可以访问用户数据的 access token，你不知道它会做些什么 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。而邮箱不存在用户数据，唯一的担忧是被 spam 骚扰，但有很多匿名邮箱和邮件转发服务帮助我们解决这个问题。<del>使用邮箱登录进行的评论，在被回复后也会发送邮件提醒评论者，确保了双向沟通的流畅性</del><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p><figure>
    <video class="video-shortcode" preload="metadata" controls>
      <source src="/blog/blog-commenting-systems/images/remark42-email-login.mov">
      There should have been a video here but your browser does not seem to support it.
    </video>
    </figure></p>
<p>Remark42 还有一个特别的地方，它没有 Admin 界面，或者 Dashboard，这得益于其清晰的设计理念和完善的功能实现。一般对于评论系统来说，Admin 主要用于查看和审核评论，但 Remark42 不需要审核，而对评论和评论者的操作（隐藏、删除、屏蔽）都集成在评论控件中。加上 API 简单易用，去掉 Admin 不仅没有让人感到不便，反而成为一个值得一提的 feature 了。</p>
<p>最后，Remark42 在设计上就支持 multi-site，只需要部署一个实例，便可以为多个不同域名的站点提供评论服务。</p>
<h3 id="隐私层面">隐私层面</h3>
<p>Remark42 的标语是「Privacy-focused lightweight commenting engine」，而它的确在隐私这件事情上做了许多事情。无追踪和广告自不必说，尽可能少的申请 OAuth 权限也只是基操，Remark42 还对用户数据做了这些考虑：</p>
<blockquote>
<p>Users can request all information Remark42 knows about them and receive the export in the gz file.</p>
</blockquote>
<p>用户可将自己在一个 Remark42 服务中的所有评论数据导出，多希望我高中时使用的百度空间也有这个功能。</p>
<blockquote>
<p>Supports complete cleanup of all information related to user&rsquo;s activity by user&rsquo;s &ldquo;deleteme&rdquo; request.</p>
</blockquote>
<p>用户可以通过 &ldquo;deleteme&rdquo; 请求将所有与自己相关的数据全部清除，类似近年来用户呼吁各大网站去支持的 opt-out <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<h2 id="小结">小结</h2>
<p>Remark42 还有许多功能，比如评论的 RSS 输出、Telegram 通知接入、Webhook 等等，限于本文篇幅，就不做展开了。下一篇博客我会对如何在 <a href="https://fly.io/">Fly.io</a> 部署 Remark42、自定义 UI、接入 CDN 等内容进行详细的讲解，让读者也可以快速搭建自己的 Remark42 实例，敬请期待。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>虽然一个优秀的服务应尽可能少的申请用户权限（减少 scope），但遇到糟糕的服务申请过多权限，我们一个不留神点了 Allow 的风险依然存在。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>经过尝试和搜索，发现 Remark42 的用户提醒是一项单独的功能（Subscribe），与是否用邮箱登录无关。我打算为邮箱登录实现一个「subscribe to notification」的勾选框，实现登录后即可自动订阅邮件提醒，见此 issue 下的<a href="https://github.com/umputun/remark42/issues/745#issuecomment-1144526472">评论</a>。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://justdeleteme.xyz/">JustDeleteMe</a> 列出了各大网站对删除账户数据的支持情况，并提供直达链接。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>使用自动化工作流聚合信息摄入和输出</title><link>https://reorx.com/blog/sharing-my-footprints-automation/</link><pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/sharing-my-footprints-automation/</guid><description>展示我是如何用 n8n 将 Twitter, YouTube, GitHub, Douban 等服务的动态同步到 Telegram Channel，实现个人数字生活的信息聚合。</description><content:encoded><![CDATA[<p>欢迎关注我的 Telegram 频道: <a href="https://t.me/reorx_share">Reorx’s Footprints</a>。这篇文章讲述我为什么创建这个频道，以及如何用 n8n 将 Twitter, YouTube, GitHub, Douban 等服务的动态同步过去，实现个人数字生活的信息聚合。</p>
<h2 id="前言">前言</h2>
<p><a href="https://en.wikipedia.org/wiki/Cyberspace">赛博空间</a>构成了我的精神世界。</p>
<p>我的大脑从苏醒的那一刻开始渴求信息，大量新鲜的信息，它们比饮用水更早地进入我的身体。每天睁开眼睛，我做的第一件事情是拿起手机，逐个查看昨夜的消息提醒。起床之后，我会在马桶上浏览 RSS 阅读器和 Telegram 频道中的新闻，让思维复苏的过程伴随新知识的冲击。我已经习惯了如此，一边加载昨日的进展并思考今日的安排，一边点开链接，使用不同的工具进行阅读、收藏和记录。</p>
<p>一天之中的碎片时间，我也会不断地在 Twitter、RSS、Telegram 之间切换，这对我来说并不是信息焦虑，而是自然而然的生活习惯。在工作上，我也完全依赖于网络，在解决问题的过程中搜索阅读大量的网站，将之转化为代码和学习笔记。</p>
<p>我就像一台不停运行的收集器和过滤器，持续地消费、生产信息。但大脑被设计用于分析和联想，却不擅长高效精确的索引，这些信息散落在各个服务中，我可以想起一些关键词或模糊的上下文，但总是很难快速获取到。我需要一个能将它们聚合在一起的工具，或者工作流，这样既可以方便自己的回溯，也可以将这些经过提纯的信息分享出来，为和我兴趣接近的人提供另一个输入管道。</p>
<h2 id="聚合什么信息">聚合什么信息？</h2>
<p>不是所有在赛博空间产生的信息都需要被聚合。一些被动产生的如搜索记录、地理位置记录、个人健康信息等，他们可以用作 <a href="https://en.wikipedia.org/wiki/Quantified_self">quantified self</a>（这是另一个话题），但并不在我的考虑范畴内。</p>
<p>我要聚合的主要有两类信息，一类是是由我主动创造的，比如Twitter 上发表的看法、GitHub 上为开源项目提交的问题；一类是我主动收藏或标记的，Pinboard 上收藏的书签、YouTube 上点赞过的视频均属此列。它们有的直接流入我的知识库<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，有的保存在线上服务中，作为知识的原材料储备，留待日后进行消化吸收。</p>
<p>考虑到分享的目的，这些信息中还要去掉功能性的部分，只保留我确认有价值的那些。比如 Twitter Like 有时会用于社交目的，作为一种赞赏的回应；YouTube, Spotify 中各种 playlist 很多只是为了满足收集癖，不一定具有普适性；豆瓣的想看、想读只是待确认的 enqueue，只有看过、读过才是值得推荐的。</p>
<h3 id="内容来源">内容来源</h3>
<p>基于以上考虑，我将自己主要摄入和产生信息的来源进行了整理，得到如下列表：</p>
<ul>
<li>
<p><strong>Telegram</strong></p>
<p>我在 Telegram 中分享一些一闪而过的想法、菜谱，转发浏览其他频道时看到特别有意思的内容。</p>
<ul>
<li>Fleeting thoughts 💭</li>
<li>Recipe 🍳</li>
<li>Forward 🔄</li>
</ul>
</li>
<li>
<p><strong>Twitter</strong> 🐦</p>
<p>我的所有 Tweet 和 Retweet 都经过认真思考，是希望被阅读的内容创作。</p>
<ul>
<li>Tweet</li>
<li>Retweet</li>
</ul>
</li>
<li>
<p><strong>Instapaper</strong> 📖</p>
<p>我这样管理我的待看列表：对于没确认是否有价值的那些，我会加入 TODO 或 Telegram Saved Messages。只有当我认真阅读过并认为值得再次阅读，我才会将其加入 Instapaper 中。</p>
</li>
<li>
<p><strong>Blog</strong> 📝</p>
<p>我的个人博客，通过 RSS 发布更新。</p>
</li>
<li>
<p><strong>Music</strong> 🎵</p>
<p>我主要使用 Spotify 听歌，类似 Instapaper，只有我愿意反复听的歌曲才会加入 Liked Songs，可以看做是我基于个人音乐品味的推荐。</p>
<ul>
<li>Spotify</li>
</ul>
</li>
<li>
<p><strong>YouTube</strong> ▶️</p>
<p>YouTube 是我探索世界无限可能性的地方，it&rsquo;s about everything and nothing。每个 Like 过的视频都有着让我会心一笑或拍案叫绝的亮点。</p>
</li>
<li>
<p><strong>Bookmark</strong> 🔖</p>
<p>我从 2013 年开始使用 Pinboard，虽然 Pinboard 的社交属性很弱，但我一直坚持用 private/public 属性来区分我的收藏，所有 public 的书签都具备一定的分享价值。</p>
<ul>
<li>Pinboard</li>
</ul>
</li>
<li>
<p><strong>GitHub</strong></p>
<p>由于对 Pinboard 的重度使用，大部分 GitHub 项目都收藏在 Pinboard 中，Star 的是我觉得值得鼓励的项目。每个 Issue 和 Pull-request 我都有认真撰写，他们是我参与开源活动的记录。</p>
<ul>
<li>Star 🌟</li>
<li>Issue ⚡️</li>
<li>Pull-request ⤴️</li>
</ul>
</li>
<li>
<p><strong>Douban</strong></p>
<p>我主要用 Douban 记录看过的电影和书。如上文所说，这里只分享在看、看过的电影和在读、读过的书籍。后续考虑对评分进行过滤。</p>
<ul>
<li>Movie 📺</li>
<li>Book 📖</li>
</ul>
</li>
</ul>
<h3 id="展现形式">展现形式</h3>
<p>我选择 Telegram Channel 作为信息聚合的目的地。一方面我许多信息都来源于 Telegram ，另一方面它也非常易于使用和接入。</p>
<p>Telegram 以下几种功能极大程度地丰富了信息的展现形式<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<ul>
<li>
<p>链接预览</p>
<p>Telegram 会将消息中附带的链接进行抓取，将摘要和图片显示在消息下方。</p>
</li>
<li>
<p>富文本格式</p>
<p>Telegram 消息支持 Markdown 和 HTML 两种富文本格式的解析，可以实现粗体、斜体、下划线、超链接、行内和块级代码等样式。</p>
</li>
<li>
<p>标签索引</p>
<p>Telegram 的消息支持 <code>#</code> 为前缀的标签，在频道/群组内点击标签即可对消息进行筛选，这让结构化的信息索引成为可能。</p>
</li>
</ul>
<h2 id="实现自动化同步">实现自动化同步</h2>
<p>我使用 <a href="https://github.com/n8n-io/n8n">n8n</a> 来实现整套信息收集和聚合的自动化工作流<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。下面将对我的操作方法和配置进行讲解，参照这些说明，你也可以快速搭建一套属于自己的自动化信息分享系统。</p>
<h3 id="n8n-概念说明">n8n 概念说明</h3>
<ul>
<li>
<p><strong>workflow</strong></p>
<p>用于定义一条自动化工作流，由多个 node 以及 node 之间的指向关系构成。</p>
</li>
<li>
<p><strong>node</strong></p>
<p>构成 workflow 的基本单位，每个 node 可以完成一个独立的任务，比如定时触发、获取数据、筛选数据、发送信息等。</p>
</li>
<li>
<p><strong>credential</strong></p>
<p>访问凭据，用于在访问在线服务接口时进行身份验证。workflow 内只存储 credential 的 id，只有在运行时才会获取其中的实际内容，这一机制确保了 workflow 在分享时不会造成凭据泄露。</p>
</li>
</ul>
<h3 id="安装-n8n">安装 n8n</h3>
<p>n8n 支持使用 Docker 进行自部署，它由 Nodejs 开发，使用 SQLite 作为数据库，没有其他外部依赖，因此理论上可以部署在任何 Docker 或 Nodejs 运行环境。</p>
<p>为了方便调试，我将 n8n 部署在家里的 NAS 上，你也可以尝试将其部署在 <a href="https://railway.app?referralCode=XkWaVV">Railway</a> 等 PaaS 平台。</p>
<p>正常情况下，参照 n8n 的 <a href="https://docs.n8n.io/hosting/installation/docker/">Docker Installation</a> 文档即可完成初步运行。但在使用中，我发现了 n8n Twitter 接入的 bug，在对代码进行了修改后，不得不在本地构建 Docker 镜像 (见 <a href="https://github.com/n8n-io/n8n/tree/master/docker/images/n8n-custom">n8n - Custom Image</a>)。如果你需要使用 Twitter 接入，在这个 <a href="https://github.com/n8n-io/n8n/pull/3354">PR</a> 合并之前，建议使用我构建好的镜像 <a href="https://hub.docker.com/r/reorx/n8n-custom">reorx/n8n-custom</a>。</p>
<p><details >
  <summary markdown="span">附上我的 docker-compose.yml 文件作为参考</summary>
  <pre tabindex="0"><code>version: '3'
services:
  n8n:
    #image: n8nio/n8n
    image: n8n-custom
    ports:
      - 5678:5678
    volumes:
      - /share/CACHEDEV2_DATA/Misc/AppData/n8n:/home/node/.n8n
      - /share/CACHEDEV1_DATA/homes/reorx/Misc_Backup/:/backup
    environment:
      - PUID=1000
      - PGID=1000
      - VUE_APP_URL_BASE_API=http://harrogath-local.com:5678/
      - WEBHOOK_URL=http://harrogath-local.com:5678/
      - GENERIC_TIMEZONE=Asia/Shanghai
      - TZ=Asia/Shanghai
      - N8N_LOG_LEVEL=verbose
    restart: unless-stopped

</code></pre>
</details></p>

<p>由于许多服务需要通过 OAuth 进行接入，我们运行的 n8n 需要有一个固定的访问地址，以便接收 OAuth callback url 的访问。我的做法是在局域网内将 <code>harrogath-local.com</code> 这个域名指向 n8n 所在的机器，并为 n8n 设置如下环境变量，使其显示的 OAuth callback 与域名一致。</p>
<pre tabindex="0"><code>VUE_APP_URL_BASE_API=http://harrogath-local.com:5678/
WEBHOOK_URL=http://harrogath-local.com:5678/
</code></pre><p>启动完成后，即可通过 <code>http://harrogath-local.com:5678/</code> 访问 n8n 的 web 界面了。</p>
<h3 id="创建-workflows">创建 Workflows</h3>
<p>我的每个 workflow 都分享到了 GitHub <a href="https://github.com/reorx/n8n-workflows">reorx/n8n-workflows</a> 仓库中，通过复制 <code>.json</code> 文件的内容、粘贴在 n8n 的 workflow 编辑界面，即可对 workflow 进行复用。也可以使用 n8n 的命令直接将 workflow 导入到 n8n 的数据库中 (见文档 <a href="https://docs.n8n.io/reference/cli-commands/#import-workflows-and-credentials">Import workflows and credentials</a>)。注意无论使用何种方式导入，credentials 都需要重新配置。</p>
<h4 id="new-tweet-to-telegram">New tweet to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/new%20tweet%20to%20tg.json">n8n-workflows/workflows/new tweet to tg.json</a></p>
<p>这一 workflow 实现了每 5 分钟搜索一次我的 Twitter 时间线，将最新的 tweets 发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n.png" type="" alt=""  /></p>
<p>第一个 node 是 Interval，它是一个 trigger，可以设置重复运行的间隔时长。</p>
<p>随后是 Twitter node，它通过 OAuth 连接了我的账户，使用 <code>from:novoreorx</code> 搜索语法来获取我最近的推文条目。</p>
<p>IF reply to other 是一个 IF node，通过条目中的 <code>in_reply_to_screen_name</code> 字段判断推文是否是对别人的回复，只有否才可以走向下一步。意味着只有单独创建或回复自己的推文才会被转发。</p>
<p>Set Retweeted node 根据条目中的 <code>retweeted_status</code> 字段，识别 retweet 条目，并将原推的 URL 拼凑出来，赋值给新的字段 <code>retweeted</code> 和 <code>retweetedUrl</code>，以便后续使用。</p>
<blockquote>
<p><strong>2022-08-12 updated:</strong></p>
<p>Set Retweeted node 在后续的维护中打开了 &ldquo;Keep Only Set&rdquo; 选项，只保留其中所定义的字段，实际作用已经与名称不符，称为 &ldquo;Set properties&rdquo; 更准确一些。</p>
<p>新增了 <code>proxyUrl</code> 字段，使用 <a href="https://github.com/dylanpdx/BetterTwitFix">vxTwitter</a> 服务的域名 <code>vxtwitter.com</code> 替代 <code>twitter.com</code>，以在 Telegram 中有更好的预览效果</p>
</blockquote>
<p>Function 是我写的一段 JavaScript 代码，它使用了 n8n runtime 内置的 <a href="https://docs.n8n.io/integrations/core-nodes/n8n-nodes-base.function/#method-getworkflowstaticdatatype">getWorkflowStaticData</a> 函数，记录每次更新的第一个条目 <code>lastItemId</code>，通过与上一次的记录进行对比，确保只有新的条目会被输送到下一个 node 执行。如果没有 <code>lastItemId</code>，则只返回第一个条目，避免冷启动时造成大量信息的无效转发。这段代码基本在每个 workflow 中都有用到，下面将不再赘述。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="cm">/* only return new items */</span>
<span class="kr">const</span> <span class="nx">staticData</span> <span class="o">=</span> <span class="nx">getWorkflowStaticData</span><span class="p">(</span><span class="s1">&#39;global&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">lastItemId</span> <span class="o">=</span> <span class="nx">staticData</span><span class="p">.</span><span class="nx">lastItemId</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;lastItemId&#39;</span><span class="p">,</span> <span class="nx">lastItemId</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">firstItem</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nx">getId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">lastItemId</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">getId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">===</span> <span class="nx">lastItemId</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">newItems</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[</span><span class="nx">firstItem</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">staticData</span><span class="p">.</span><span class="nx">lastItemId</span> <span class="o">=</span> <span class="nx">getId</span><span class="p">(</span><span class="nx">firstItem</span><span class="p">)</span>
<span class="c1">// Reverse the order so that items are sent from old to new
</span><span class="c1"></span><span class="k">return</span> <span class="nx">newItems</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
</code></pre></div><p>经过 Function 的处理后，有效条目会被送往 Telegram node，进行 message 组装，最终发送到频道。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-1.png" type="" alt=""  /></p>
<p>n8n 的表达式 (Expression) 有一个可以预览的编辑界面，左侧会展示当前 node 从上一个 node 获取到的输入数据 (Input Data)，点击即可将模板变量插入到 Expression 中。模板语法 <code>{{ }}</code> 中可以使用 JavaScript 语法，这里我通过 <code>$json[&quot;retweeted&quot;]</code> 来决定 tag 为 <code>#retweet</code> 还是 <code>#tweet</code>。推文 URL 放在了 <code>&lt;a&gt;</code> 标签中，既可以触发 Telegram 的 link preview 功能，也避免展示太长的 URL 影响可读性。</p>
<blockquote>
<p><strong>2022-08-12 updated:</strong></p>
<p>Twitter 的 search API 默认会将长推文截断，只有加了 <code>tweet_mode=extended</code> 参数才能确保显示全文，不过推文内容字段会从 <code>tweet</code> 变为 <code>full_text</code>。按下图所示添加参数后，请在 &ldquo;Set Retweeted&rdquo; node 中修改字段映射 <code>text</code> → <code>tweet</code> 为 <code>full_text</code> → <code>tweet</code>。
<img loading="lazy" src="/blog/sharing-my-footprints-automation/images/tweet-mode-extended.png" type="" alt=""  /></p>
</blockquote>
<h4 id="blog-rss-to-telegram">Blog RSS to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/blog%20rss%20to%20tg.json">n8n-workflows/workflows/blog rss to tg.json</a></p>
<blockquote>
<p>从第二个 workflow 开始，我将只对大致逻辑进行说明，不再详细讲解每个 node 的实现方式，有兴趣的读者可以在 workflow 编辑器中自行查看。</p>
</blockquote>
<p>这一 workflow 实现了每 10 分钟检查一次博客的 RSS，将最新的文章发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-2.png" type="" alt=""  /></p>
<p>RSS Feed Read node 填写了博客的 RSS 地址，Function 同样是实现了有状态的更新判断，唯一的不同是将 <code>getId</code> 函数改为从 <code>item.json.guid</code> 获取 item id。</p>
<h4 id="spotify-like-to-telegram">Spotify like to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/spotify%20likes%20to%20tg.json">n8n-workflows/workflows/spotify likes to tg.json</a></p>
<p>这一 workflow 实现了每 1 小时检查一次 Spotify Liked Tracks，将最新的歌曲发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-3.png" type="" alt=""  /></p>
<h4 id="youtube-like-to-telegram">YouTube like to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/youtube%20like%20to%20tg.json">n8n-workflows/workflows/youtube like to tg.json</a></p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-4.png" type="" alt=""  /></p>
<p>这一 workflow 实现了每 30 分钟检查一次 YouTube Liked Playlist，将最新的视频发送到 Telegram Channel。</p>
<p>这里需要注意的是，Liked 是一个内置的 playlist，因此其 ID 与自己创建的不一样，通过访问 YouTube get playlists API，得到其 ID 为 <code>LL</code>，顺利完成了这一 node 的配置。</p>
<h4 id="pinboard-new-bookmark-to-telegram">Pinboard new bookmark to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/pinboard%20to%20tg.json">n8n-workflows/workflows/pinboard to tg.json</a></p>
<p>这一 workflow 实现了每 5 分钟检查一次 Pinboard 最近的书签，将最新的书签发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-5.png" type="" alt=""  /></p>
<p>n8n 没有 Pinboard 支持，但我们可以通过 HTTP Request 直接访问 Pinboard 的接口。古怪的是 Pinboard 没有官方的 API 文档，于是我对一些开源的 Pinboard SDK 代码进行阅读，得到了我所需要的接口 <code>https://api.pinboard.in/v1/posts/recent</code>。</p>
<p>Pinboard 接口返回的数据并不直接是一个列表，而是一个形如 <code>{&quot;posts&quot;: [...]}</code> 的结构，这里用了 Item Lists 将 <code>posts</code> 字段提取出来作为 items 向后传递。</p>
<h4 id="github-activities-to-telegram">GitHub activities to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/github%20activities%20to%20tg.json">n8n-workflows/workflows/github activities to tg.json</a></p>
<p>这一 workflow 实现了每 10 分钟检查一次 GitHub 的动态，筛选出 star, pull-request 和 issue 发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-6.png" type="" alt=""  /></p>
<p>GitHub 可以通过 <code>https://github.com/$username.atom</code> 获取用户公开的动态信息，因此不需要复杂的 API 接入，直接使用 RSS Feed Read 即可获取到我们所需要的数据。</p>
<p>在 Function filter 中，我用正则为动态进行了分类，并组成最终所需的消息格式，代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="cm">/* filter items */</span>
<span class="kr">const</span> <span class="nx">newItems</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kr">const</span> <span class="nx">regexes</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;star&#39;</span><span class="o">:</span> <span class="sr">/^reorx starred/</span><span class="p">,</span>
  <span class="s1">&#39;pull-request&#39;</span><span class="o">:</span> <span class="sr">/^reorx opened a pull request/</span><span class="p">,</span>
  <span class="s1">&#39;issue&#39;</span><span class="o">:</span> <span class="sr">/^reorx opened an issue/</span><span class="p">,</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">tagSymbols</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;star&#39;</span><span class="o">:</span> <span class="s1">&#39;🌟&#39;</span><span class="p">,</span>
  <span class="s1">&#39;pull-request&#39;</span><span class="o">:</span> <span class="s1">&#39;⤴️&#39;</span><span class="p">,</span>
  <span class="s1">&#39;issue&#39;</span><span class="o">:</span> <span class="s1">&#39;⚡️&#39;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">title</span>
  <span class="kd">let</span> <span class="nx">tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">regexes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="nx">regexes</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">regex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">title</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">tag</span> <span class="o">=</span> <span class="nx">key</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">tag</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">tag</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">tgTitle</span> <span class="o">=</span> <span class="sb">`</span><span class="si">${</span><span class="nx">tagSymbols</span><span class="p">[</span><span class="nx">tag</span><span class="p">]</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">title</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^reorx /</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="sb"> #github #</span><span class="si">${</span><span class="nx">tag</span><span class="si">}</span><span class="sb">`</span>
    <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">guid</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">json</span><span class="p">.</span><span class="nx">id</span>
    <span class="nx">newItems</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nx">newItems</span>
</code></pre></div><blockquote>
<p>这个 workflow 还有一个使用 GitHub API 的版本，但 RSS 可以获得所有动态，更加方便，最终胜出。</p>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/github%20issues%20to%20tg.json">n8n-workflows/workflows/github issues to tg.json</a></p>
</blockquote>
<h4 id="douban-activities-to-telegram">Douban activities to telegram</h4>
<p>Link: <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/douban%20activities%20to%20tg.json">n8n-workflows/workflows/douban activities to tg.json</a></p>
<p>这一 workflow 实现了每 10 分钟检查一次 Douban 的动态，筛选出看过、在看、读过、在读发送到 Telegram Channel。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-7.png" type="" alt=""  /></p>
<p>Douban 也有一个隐藏的 RSS 订阅源 <code>https://www.douban.com/feed/people/$username/interests</code>，包含书影音的所有动态。</p>
<p>Function filter 与上一个 workflow 类似，这里做了一些优化，将正则和符号定义在一个 object 中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">SYMBOL_MOVIE</span> <span class="o">=</span> <span class="s1">&#39;📺&#39;</span>
<span class="kr">const</span> <span class="nx">SYMBOL_BOOK</span> <span class="o">=</span> <span class="s1">&#39;📖&#39;</span>

<span class="kr">const</span> <span class="nx">tagInfoMap</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">watched</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/看过/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_MOVIE</span> <span class="p">},</span>
  <span class="nx">watching</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/在看/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_MOVIE</span> <span class="p">},</span>
  <span class="nx">read</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/读过/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_BOOK</span> <span class="p">},</span>
  <span class="nx">reading</span><span class="o">:</span> <span class="p">{</span> <span class="nx">re</span><span class="o">:</span> <span class="sr">/在读/</span><span class="p">,</span> <span class="nx">symbol</span><span class="o">:</span> <span class="nx">SYMBOL_BOOK</span> <span class="p">},</span>
<span class="p">}</span>
</code></pre></div><h3 id="异常通知">异常通知</h3>
<p>n8n 作为一个自动化服务，在配置完成后，一般我们不会去主动查看系统的运行情况，因此需要有监控手段得知异常的发生，以便及时维护。</p>
<p>n8n 支持通过 <a href="https://docs.n8n.io/integrations/core-nodes/n8n-nodes-base.errortrigger/">Error Trigger</a> 创建 Error Workflow，用于接收其他 workflow 的错误信息。这一步虽然不是必须，但我强烈建议创建一个全局的 Error Workflow，并在每个 workflow 的 Settings 中设置错误处理指向它。</p>
<p><img loading="lazy" src="/blog/sharing-my-footprints-automation/images/n8n-8.png" type="" alt=""  /></p>
<p>我在 <a href="https://github.com/reorx/n8n-workflows/blob/master/workflows/ERROR%20TO%20TG.json">n8n-workflows/workflows/ERROR TO TG.json</a> 中实现了将错误信息发送到 Telegram Group 的功能，效果如下。
<div class="image-size-control" style="max-width: 400px;">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/telegram.png" type="" alt=""  />
</div>
</p>
<h3 id="使用-saas-自动化服务">使用 SaaS 自动化服务</h3>
<p>对于一些 n8n 尚不支持，或配置比较麻烦的服务，也可以通过 SaaS 服务来实现自动化。IFTTT 是一个不错的选择，它应该是最早被广泛使用的自动化服务，免费用户可以设置 5 个 applet (即 workflow)，同步间隔 1 小时。</p>
<p>下图是我在 IFTTT 中配置的 Instapaper 新文章推送到 Telegram 频道的 applet。</p>
<div class="image-size-control" style="max-width: 400px;">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/ifttt.png" type="" alt=""  />
</div>

<p><a href="https://www.integromat.com/">Integromat</a> 曾是一个非常好用的 IFTTT alternative，有着现代化的交互界面，和更为灵活的定制功能，但后来 rebrand 成 make.com，变得非常难用，不仅加载速度缓慢，而且连 migration 都无法正常完成<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>。建议大家远离这个奇怪的公司。</p>
<figure class="center align-center">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/integromat.png" type="" alt=""  />

  <figcaption><p>曾经美好的 Integromat</p></figcaption>
</figure>

<figure class="center align-center">
  <img loading="lazy" src="/blog/sharing-my-footprints-automation/images/integromat-scenario.png" type="" alt=""  />

  <figcaption><p>和它出色的交互界面</p></figcaption>
</figure>

<h2 id="结语">结语</h2>
<p>使用 n8n 的过程总体是非常顺畅的，虽然一开始就在 Twitter 上栽了跟头，好在我能看懂 Nodejs 代码，自己动手修复后一路坦途。</p>
<p>曾经我特别痴迷于自己实现工具、制造轮子，现有工具稍有不顺就要全盘抛弃，自己解决。后来我在 happy xiao 的<a href="https://happyxiao.com/system/">忘记系统</a>一文中看到 <a href="https://twitter.com/johnvoorhees">John Voorhees</a> 的一段话，改变了我对使用工具的态度:</p>
<blockquote>
<p>If there&rsquo;s anything I&rsquo;ve learned about productivity systems, it&rsquo;s that the best one is the one that works for you. Approaching the problem is tricky, but my advice is to use an app first and adopt a system later. That way, you&rsquo;ll have a better understanding of what your needs are before you dive in.</p>
</blockquote>
<p>实现的结果才是最重要的，工具只是手段，不是目的。</p>
<p>这也让我对自己正在开发的产品有了更多的思考，它是一个用于信息前处理的工具，同样是为了解决信息的分散和封闭而做出的努力，我设想了很多功能要去开发，但哪些是核心需求，哪些有代替品，或者换个思路通过其他方式实现，则必须放在实际场景中去考虑，而不是凭自己作为开发者的喜欢来武断确定。</p>
<p>回到赛博空间这个话题，我一直觉得人类对电子设备的依赖是一个不可逆的过程，人脑与电脑的边界会逐渐模糊。这是当我们有了智慧、抛弃自然为我们提供的进化之路后，自己所选择的进化方式。正如 Ghost In The Shell 开篇所描绘的越来越近的未来：</p>
<blockquote>
<p>企業のネットが星を被い、電子や光が駆け巡っても</p>
<p>国家や民族が消えてなくなるほど、情報化されていない近未来</p>
</blockquote>
<p>而在这一天到来之前，我在精神上已经完成了自然人向 <a href="https://en.wikipedia.org/wiki/Cyborg">cyborg</a> 的转变。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-05-26: created</li>
<li>2022-05-27: published</li>
<li>2022-05-28: fixed &ldquo;Function&rdquo; node script items order by adding <code>.reverse()</code> to return items</li>
<li>2022-08-12:
<ul>
<li>added notes about using <code>tweet_mode=extended</code> to avoid tweet text truncation</li>
<li>added notes about vxTwitter proxy url</li>
</ul>
</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>我的知识库中有三个分类:「制品」、「技术」、「事实」。制品 (artifacts) 是人所创造的作品、产品，如一个开源项目、一个软件；技术 (techniques) 是完成一类事情的方法或经验，也可以叫做 know-how，比如做饭的菜谱、编程语言的技巧、健身动作说明；事实 (facts) 是对概念、词汇的客观解释，多数来源于维基百科的词条。这三个分类可以基本涵盖我摄入的各类信息。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>预计微信还需要 100 年才能赶上&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>self-hosted workflow automation 的另一个选择是 <a href="https://github.com/huginn/huginn">Huginn</a>, 我没有尝试和对比，在看过它的项目页面，感觉 UI 非常简陋就放弃了。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>见我在 Twitter 的吐槽: <a href="https://twitter.com/novoreorx/status/1528985317847736320">make.com 大概是我 10 年来用过最糟糕的服务</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>我关注的独立开发者们</title><link>https://reorx.com/blog/indie-makers-im-following/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/indie-makers-im-following/</guid><description>列举一些我所知的独立开发者们，让更多的人看到他们的经历和作品，获得启发。</description><content:encoded><![CDATA[<p>独立开发者，AKA indie makers, solo developers, or quite-my-job makers，是一群特别的人。他们或厌倦了大厂上班做重复性的工作，或不甘于只作为别人设计的实现者，或想要挑战自己的创造力、寻求被动收入甚至实现财务自由，初始的动机虽然各异，但却有一个共同点：不满足于一件事情已有的做法和存在方式，想用自己的手去改变和创造，实现心中那个理想的产品。</p>
<blockquote>
<p>An indie maker is an <strong>independent creator</strong>. They build projects with their own resources, often without funding, taking care of all aspects: development, design, marketing&hellip;</p>
<p>by <a href="https://www.whatisanindiemaker.com/">What is an Indie Maker?</a></p>
</blockquote>
<p>独立开发者有着两个特质，勇气和追求。放弃待遇优渥的工作，投身不确定的未来，是勇气；对已有的产品不满，用更高的标准要求打磨，则是追求。</p>
<p>我一直关注着一些独立开发者们，怀着敬意欣赏他们的作品，为他们的成就欢呼喝彩，从他们身上汲取勇气和追求的养分，让踏上同样道路的自己得到志同道合者的陪伴。这篇文章将我所知的独立开发者们列举出来<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，让更多的人能看到他们的经历和作品，获得启发。</p>
<blockquote>
<p>如果看到本文的你也是一位独立开发者（或者认识某位），欢迎在评论和推文中分享你的经历和作品。</p>
</blockquote>
<h2 id="zh">ZH</h2>
<ul>
<li><a href="https://blog.guyskk.com/about">Guyskk</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://blog.guyskk.com/notes/onebiz-begin">自宅创业 - 开始</a></li>
<li><a href="https://blog.guyskk.com/notes/onebiz-1-recent-and-product">自宅创业 - 两周近况和新产品</a></li>
<li><a href="https://blog.guyskk.com/notes/onebiz-6">自宅创业 - 创业三个月了</a></li>
<li><a href="https://blog.guyskk.com/notes/onebiz-13">自宅创业 - #13 创业半年回顾</a></li>
<li><a href="https://blog.guyskk.com/notes/review-2021">2021自宅创业10个月总结，我会再次挑战</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://github.com/anyant/rssant">蚁阅</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://timqian.com/">Tim Qian</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://blog.t9t.io/transparent-startup-experiment-2019-05-20/">我的透明创业实验</a></li>
<li><a href="https://blog.t9t.io/2019-2020-01-03/">2019 年 t9t.io 赚了多少钱</a></li>
<li><a href="https://blog.t9t.io/t9t-year1-2020-05-18/">我的一年独立开发经历</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://feeds.pub/">Feeds Pub</a></li>
<li><a href="https://github.com/timqian/chart.xkcd">chart.xkcd</a></li>
<li><a href="https://github.com/bytebase/star-history">star-history</a></li>
</ul>
</li>
</ul>
</li>
<li>Tob
<ul>
<li>Experiences
<ul>
<li><a href="https://eleduck.com/posts/MkRfER">独立开发挑战:做一款产品,6个月之内实现月收入30,000元 | 电鸭</a></li>
<li><a href="https://eleduck.com/posts/ez1fBR">从硅谷到北京再到东南亚，为自己而工作的306天 | 电鸭</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://www.21cloudbox.com/">21YunBox</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://ranhe.xyz/about/">染河</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDYwNjk2NA==&amp;mid=2247483680&amp;idx=1&amp;sn=1797b7e6b02724abd02caf2865117801&amp;chksm=cfb4d3bbf8c35aad173a1de7313e6b49d1f0fec3bd627b01a5aec768479887fa54934bfa4032&amp;mpshare=1&amp;scene=1&amp;srcid=0314XxUXk5LuIVDw6P4D1yTJ&amp;sharer_sharetime=1647247408010&amp;sharer_shareid=499a00e1cb53b0df2fa10b0279edd40a#rd">我为什么从字节跳动裸辞全职开发浏览器扩展</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="http://circlereader.com/">Circle 阅读助手</a></li>
</ul>
</li>
</ul>
</li>
<li>zy5a59
<ul>
<li>Experiences
<ul>
<li><a href="https://www.v2ex.com/t/850671">人生自由实验 - V2EX</a></li>
<li><a href="https://www.v2ex.com/t/759394#reply11">『独立开发』复盘一个“可能”月入过万的小项目 - V2EX</a></li>
<li><a href="https://space.bilibili.com/20667846">我是张万里的个人空间_哔哩哔哩_bilibili</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://yezishuzhai.com/">叶子书摘</a></li>
</ul>
</li>
</ul>
</li>
<li>Hawstein
<ul>
<li>Experiences
<ul>
<li><a href="https://hawstein.com/2020/02/17/be-an-indie-hacker-for-613-days/">不上班的 613 天</a></li>
<li><a href="https://hawstein.com/2020/01/08/indie-hacker-notes-issue-14/">Indie Hacker 笔记</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://algocasts.io/">AlgoCasts 简明、轻松、易懂的算法教学视频</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="en">EN</h2>
<ul>
<li><a href="https://mtlynch.io/">Michael Lynch</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://mtlynch.io/why-i-quit-google/">Why I Quit Google to Work for Myself · mtlynch.io</a></li>
<li><a href="https://mtlynch.io/solo-developer-year-1/">My First Year as a Solo Developer</a></li>
<li><a href="https://mtlynch.io/solo-developer-year-2/">My Second Year as a Solo Developer</a></li>
<li><a href="https://mtlynch.io/solo-developer-year-3/">My Third Year as a Solo Developer</a></li>
<li><a href="https://mtlynch.io/solo-developer-year-4/">My Fourth Year as a Bootstrapped Founder</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://tinypilotkvm.com/">The Modern, Open-Source KVM over IP | TinyPilot</a></li>
<li><a href="https://refactoringenglish.com/">Refactoring English</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://benstokes.dev/">Ben Stokes</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://tinyprojects.dev/posts/i_spent_two_years_launching_tiny_projects">I Spent 2 years Launching Tiny Projects | Tiny Projects</a></li>
<li><a href="https://daily.tinyprojects.dev/paper_website">I blew $720 on 100 notebooks from Alibaba and started a Paper Website business | Tiny Projects</a></li>
<li><a href="https://tinyprojects.dev/projects/earlyname">Earlyname: Reserving Usernames on the Internet | Tiny Projects</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://tinyprojects.dev/">Tiny Projects</a></li>
<li><a href="https://paperwebsite.com/">Paper Website: Start a tiny website from your notebook</a></li>
<li><a href="https://earlyname.com/">Earlyname | Get Your Username Before Anyone Else</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://twitter.com/levelsio">@levelsio</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://levels.io/how-i-built-a-remote-jobs-board/">How I built Nomad Jobs, a remote job board for 100% distributed startups</a></li>
<li><a href="https://levels.io/12-startups-12-months/">I&rsquo;m Launching 12 Startups in 12 Months</a></li>
<li><a href="https://levels.io/product-hunt-hacker-news-number-one/">How I got my startup to #1 on both Product Hunt and Hacker News by accident</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://nomadlist.com/">Nomad List - Best Places to Live for Digital Nomads</a></li>
<li><a href="https://remoteok.com/">Remote Jobs in Programming, Design, Sales and more #OpenSalaries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://twitter.com/damengchen">@damengchen</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://testimonial.to/blog/one-year-of-indie-hacking-i-have-learned-a-lot">One year of indie hacking, I&rsquo;ve learned a lot!</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://testimonial.to/">Testimonial - Collect and embed testimonials in minutes</a></li>
<li><a href="https://embed.so/">Embed.so - The video hosting platform for your business</a></li>
<li><a href="https://supportman.io/">Supportman - Intercom Metrics &amp; Ratings in Slack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://tonydinh.com/">Tony Dinh</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://twitter.com/tdinh_me/status/1427930913355100167">After 7 years working as a dev, I quit my job to pursue my dream: build software I love and make a living out of it.</a></li>
<li><a href="https://newsletter.tonydinh.com/">Tony Dinh’s Newsletter | Revue</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://blackmagic.so/">Twitter Analytics &amp; CRM - BlackMagic.so</a></li>
<li><a href="https://devutils.app/">DevUtils.app - All-in-one Toolbox for Developers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://alyssax.com/">Alyssa</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://medium.com/women-make/how-i-built-a-macos-app-and-made-5000-in-a-week-de25c7be0458">How I built a MacOS app and made $5000+ in a week | Women Make</a></li>
<li><a href="https://newsletter.alyssax.com/">The Serial Entrepreneur Newsletter by Alyssa X</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://chrome.google.com/webstore/detail/omni-bookmark-history-tab/mapjgeachilmcbbokkgcbgpbakaaeehi?hl=en&amp;authuser=0">Omni - Bookmark, History, &amp; Tab Manager - Chrome Web Store</a></li>
<li><a href="https://getlater.app/">Later - Save your Mac apps for later</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://twitter.com/SachinNeravath">@SachinNeravath</a>
<ul>
<li>Experiences
<ul>
<li>See twitter timeline</li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://www.paritydeals.com/">ParityDeals - Price Smarter, Sell bigger!</a></li>
<li><a href="https://www.samay.live/">Samay - Supercharge your focus and productivity.</a></li>
<li><a href="https://www.lightgalleryjs.com/">lightGallery - Full featured javascript gallery for web and mobile.</a></li>
<li><a href="http://tack.one">http://tack.one</a> (100% free)</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.thomas-sanlis.com/">Thomas Sanlis</a>
<ul>
<li>Experiences
<ul>
<li><a href="https://www.thomas-sanlis.com/blog/when-why-and-how-i-have-changed-my-life/">When, Why and How I&rsquo;ve changed my life</a></li>
</ul>
</li>
<li>Products
<ul>
<li><a href="https://www.uneed.best/">Uneed, the best tools of the internet.</a></li>
<li><a href="https://www.griddely.com/">Griddely</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://destroytoday.com/">Jonnie Hallman</a>
<ul>
<li>Products
<a href="https://cushionapp.com/">Cushion</a></li>
<li>Experiences
<ul>
<li><a href="https://cushionapp.com/journal/launch">Cushion Journal - Launch</a></li>
<li><a href="https://cushionapp.com/journal/funding-cushion">Cushion Journal - Funding Cushion</a></li>
<li>…all in <a href="https://destroytoday.com/blog/categories/cushion">https://destroytoday.com/blog/categories/cushion</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一些链接">一些链接</h2>
<p>本文不打算整理对如何成为一个独立开发者的建议或工具（以后有机会可以做下分享<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>），如果你看到这里感到意犹未尽，想了解更多关于独立开发的事情，可以对下面的链接进行探索。</p>
<ul>
<li><a href="https://www.whatisanindiemaker.com/">What is an Indie Maker?</a></li>
<li><a href="https://news.ycombinator.com/item?id=29667095">Ask HN: Those making $500/month on side projects in 2021 – Show and tell | Hacker News</a></li>
<li><a href="https://github.com/mezod/awesome-indie">mezod/awesome-indie: Resources for independent developers to make money</a></li>
<li><a href="https://www.indiehackers.com/">Indie Hackers: Work Together to Build Profitable Online Businesses</a></li>
<li><a href="https://josephchang10.github.io/chinese-indie-hackers/">独立 | 中国独立 iOS 和 macOS 开发者图鉴</a></li>
<li><a href="https://microacquire.com/">MicroAcquire, the #1 Startup Acquisition Marketplace</a></li>
</ul>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-05-22: created</li>
<li>2022-08-11: added Hawstein in ZH</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>本文列举的独立开发者都分享过自己的经历，这是对我来讲特别重要的一点，但并不是只有分享经历的独立开发者才值得关注。每个独立开发者都是人间宝藏。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>但正如我的一个推文所说，专注于具体创作的人在输出经验方面的精力会比较少 <a href="https://twitter.com/novoreorx/status/1528309074550747138">https://twitter.com/novoreorx/status/1528309074550747138</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>我理想中的 Newsletter platform</title><link>https://reorx.com/blog/the-newsletter-platform-i-long-for/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/the-newsletter-platform-i-long-for/</guid><description>一些我对 Newsletter platform 产品形态非常主观的探索和思考</description><content:encoded><![CDATA[<p>近年来 Newletter 这种发布形式越来越受到欢迎，我也在考虑是否要创建一个自己的邮件专栏。由于我的博客是由静态网站生成器构建的，因此我也希望通过同样的方式来撰写邮件通讯。</p>
<p>我的设想是为博客创建一个新的路径 <code>/weekly</code>，当我在这个路径下发布文章，比如 <code>/weekly/2022W20/</code>，就触发 GitHub Actions 的 CI 任务，将文章的 HTML 通过 Newsletter 服务商的接口发送出去。</p>
<p>带着这个目的，我调研了市面上的一些服务，选定了 4 家进行对比。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Pricing</th>
<th>API</th>
<th>Send email via API</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buttondown</td>
<td>小于 100 订阅者免费; 100~1000 收费 $9/每月</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Revue</td>
<td>免费使用，无限订阅者; 付费订阅收取 5% 佣金</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Substack</td>
<td>免费使用，无限订阅者; 付费订阅收取 10% 佣金</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>ConvertKit</td>
<td>小于 300 订阅者免费; 大于 300 收费 $9/每月</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Curated</td>
<td>小于 1500 订阅者免费; 1500~2500 收费 39$/每月</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>&ldquo;Send email via API&rdquo; 一列表示是否可以通过 API 创建并发送邮件 (或叫 issue, broadcast，每家称呼不同)，这是我最关注的一个功能，其中只有 Buttondown 和 ConvertKit 支持，他们都是基于订阅者数量的收费模式。但每月 $9+ 的费用让我却步，我想写的是分享见闻和思考的 Weekly Newsletter，这种内容并不足以支撑起付费订阅的模式。我喜欢写作并乐意分享，但为此负担额外的费用就不大令人开心了，这也是为什么我特别感谢像 Cloudflare 这样为独立开发者考虑的公司<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<blockquote>
<p>经 EGOIST 提醒，<a href="https://documentation.mailgun.com/en/latest/api-mailinglists.html#mailing-lists">Mailgun</a> 的 API 有 mailing list 管理功能，同样可以实现 Newletter 所需的订阅者管理和群发。实际上 Newsletter 的本质就是 mailing list，之前我潜意识里觉得 Mailgun, SES 这些服务只是 SMTP 协议的接口化，忽略了他们其实有一些面向邮件订阅服务开发者的高级功能。</p>
</blockquote>
<p><details >
  <summary markdown="span">References</summary>
  <ul>
<li><a href="https://buttondown.email/">Buttondown</a>
<ul>
<li><a href="https://buttondown.email/pricing">https://buttondown.email/pricing</a></li>
</ul>
</li>
<li><a href="https://www.getrevue.co/">Revue</a>
<ul>
<li><a href="http://help.getrevue.co/en/articles/4754361-how-pricing-works-on-revue">http://help.getrevue.co/en/articles/4754361-how-pricing-works-on-revue</a></li>
<li><a href="https://www.getrevue.co/api">https://www.getrevue.co/api</a></li>
</ul>
</li>
<li><a href="https://substack.com/">Substack</a>
<ul>
<li><a href="https://support.substack.com/hc/en-us/articles/360037607131-How-much-does-Substack-cost-">How much does Substack cost? – Substack, Inc</a></li>
</ul>
</li>
<li><a href="https://convertkit.com/">ConvertKit</a>
<ul>
<li><a href="https://convertkit.com/pricing">https://convertkit.com/pricing</a></li>
<li><a href="https://developers.convertkit.com/#create-a-broadcast">https://developers.convertkit.com/#create-a-broadcast</a></li>
</ul>
</li>
<li><a href="https://www.curated.co/">Curated</a>
<ul>
<li><a href="https://www.curated.co/pricing">https://www.curated.co/pricing</a></li>
<li><a href="https://support.curated.co/help/api">https://support.curated.co/help/api</a></li>
</ul>
</li>
</ul>

</details></p>

<h2 id="竹白">竹白</h2>
<p>由于订阅了 <a href="https://shyrz.zhubai.love/">Shyrism.News</a> 和 <a href="https://xpaidia.zhubai.love/">落日间</a>，我得知了竹白这个国内的 Newsletter 发布平台。我很喜欢它简单易用的特性和清晰可读的设计风格，甚至让我这个只相信本地编辑器的人也有了在网页上创作的冲动。</p>
<p>这改变了我的想法，我开始思考，基于 Newsletter 平台去管理文章和发布，再使用静态网站生成器来构建网站是否是可行的。</p>
<p>如果以这种架构为目标，竹白还缺少一些东西，一个更为理想的竹白应该是这样的：</p>
<ul>
<li>
<p><input checked="" disabled="" type="checkbox"> 一个内容管理和发布平台</p>
<p>Newsletter 平台首先其实是一个标准的 CMS</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> 一个 Newsletter 管理后台</p>
<p>管理订阅者，收集和展示统计数据</p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> 一个付费平台</p>
<p>支持接收用户的 donation；支持付费订阅</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 提供 email subscrible API</p>
<p>这个接口用于在个人网站上创建订阅表单，类似于 <a href="https://formspree.io/">Formspree</a> 和 <a href="https://fieldgoal.io/">FieldGoal</a>，通过 HTML 的 <code>&lt;form&gt;</code> 标签提交用户的订阅请求。</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 提供 headless CMS API</p>
<p>让创作者可以使用 Hugo, Next.js, Gatsby 等 JAMStack 工具获取数据，自由地开发定制属于自己的网站形态。</p>
</li>
</ul>
<p>以上几点中，竹白还有最后两点没有实现，其他我所知道的产品中，最为接近的是 <a href="http://ghost.io/">Ghost</a>，除了 email subscribe API 不确定之外，其他全部都能满足。但 Ghost 是专注于网站内容的管理，最近才有 Newsletter 的功能，在专业性上会略逊于其他 Newsletter 发布平台。并且 Ghost 提供的功能太多（甚至支持 Podcast），且价格昂贵，如果我购买后只用它的 Newsletter 功能显然是非常不划算的<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<h2 id="proselog">Proselog</h2>
<p>我的朋友 <a href="https://egoist.sh/">EGOIST</a> 今天发布了他开发的博客平台: <a href="https://blog.proselog.com/meet-proselog">Meet Proselog: The Open Blogging Platform</a></p>
<p>Proselog 的界面相比竹白更加简洁清晰，界面上处处体现出 EGOIST 特有的克制而明快设计审美，这让基于网页编辑器的创作流程变得舒适而愉悦。</p>
<p>Proselog 不仅仅是一个 Substack/竹白 alternative，它还是一个<a href="https://github.com/proselog/proselog">开源项目</a>，意味着创作者的数据和隐私将完全由自己掌控，这与 Fediverse 系的发布平台如 <a href="https://github.com/writefreely/writefreely">Writefreely</a> 的理念不谋而合。</p>
<p>和 EGOIST 讨论后，他表示 Proselog 的确有 headless CMS 的开发计划，这让我异常期待 Proselog 后续的发展。也许这次，我找到了那个理想中的 Newsletter 发布平台。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Cloudflare 在<a href="https://blog.cloudflare.com/r2-open-beta/">一篇文章</a>中提到: “One of our main goals has been to serve the developers who can’t negotiate large discounts with cloud vendors”&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>这里不讨论 Ghost 的 self-hosted 版本，我更希望使用 hosting 的 Newsletter 服务，因为网站已经需要自己去维护，不想再增加维护一个复杂系统的负担&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>搭建 umami 收集个人网站统计数据</title><link>https://reorx.com/blog/deploy-umami-for-personal-website/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/deploy-umami-for-personal-website/</guid><description>教你如何免费搭建和使用美丽的 umami 网站统计服务，和 Google Analytics 说再见。</description><content:encoded><![CDATA[<p>距离博客第一篇文章发布正好一个月，我想查看一下网站的统计数据，在 Google Analytics 上操作了一番，发觉自己已无法忍受这个复杂且迟缓的老旧产品，这让我开始思考有没有更好的解决方案。</p>
<p>我首先想到的是切换到另一家 hosting 的网站统计服务，如果可以的话，最好能有免费额度。然而开公司并不是做慈善，Google 之所以开放 Analytics 免费使用，除了本身体量足够大、边际成本够低之外，也因为网站统计与其核心的广告业务是密不可分的，Google 乐于让尽可能多的网站使用 Analytics，以得到可以推动广告和搜索业务发展的数据。果不其然，目前风评比较好的服务如 <a href="https://usefathom.com/pricing">fathom</a> 都没有免费套餐，价格也不便宜；<a href="https://plausible.io/#pricing">plausible</a> 价格较低，并且提供开源可部署的版本，这让我开始考虑自建统计服务的可行性。</p>
<p>要选择一个 self-hosted 网站统计服务，我有以下几个考量：</p>
<ul>
<li><strong>实现语言</strong>：我非常倾向于 JavaScript 的实现，这并非出于我对它更加熟悉或者偏爱，而是因为近年来 Cloudflare 在 serverless 和 edge computing 领域不断深耕，推动了一系列基于 JavaScript 的运行环境和基础设施的发展，最近还联合 Vercel 等友商成立了 <a href="https://blog.cloudflare.com/introducing-the-wintercg/">WinterCG</a> 社区组织，让我看到了 JavaScript 一站式云端开发部署的未来。我自己也尝试过 Workers 开发，体验很好，免费额度充裕。如果一个服务是 JavaScript 实现，就有在 Workers 上部署的可能性。</li>
<li><strong>数据库</strong>：最好是 SQLite。SQLite 的存储基于单文件，非常适合小型服务的开发部署。<a href="https://litestream.io/">Litestream</a> 的存在让基于 S3 等对象存储的低成本数据库维护成为可能。</li>
<li><strong>便于部署</strong>：有官方维护的 docker image，或提供 PaaS/Serverless 平台的一键部署模板</li>
<li><strong>尊重数据隐私</strong>：其实 self-hosted 统计服务产生的目的之一就是为了抵制商业服务滥用用户数据，因此这一点大部分项目都可以满足，稍加注意即可。</li>
<li><strong>ublock</strong>：作为一个 webmaster，肯定希望统计数据越精确越好，因此这个服务得有绕过 ublock 拦截的能力。虽然我个人也会使用 ublock 拦截各种 tracker，但 self-hosted 统计服务本身不会过度收集用户数据，更不会将其用于商业目的，可以理直气壮地想办法确保其正常加载。</li>
</ul>
<p>经过一番调查，我选择了 umami，它基本满足以上所有需求：</p>
<ul>
<li>前后端全部使用 TypeScript 和 Next.js 开发</li>
<li>数据库是 PostgreSQL，我比较喜欢，可以接受</li>
<li>项目页面有个大大的 “Deploy on Railway”，也有 docker image</li>
<li>项目 Slogan 就是 “privacy focused”
<blockquote>
<p>Umami does not collect any personally identifiable information and anonymizes all data collected.</p>
</blockquote>
</li>
<li>提供 <code>TRACKER_SCRIPT_NAME</code> 环境变量用于自定义 script 名称，可以绕过 ublock 的默认规则</li>
</ul>
<p>择日不如撞日，选定工具后我立刻开始尝试部署。umami 的部署流程是如此顺滑，只花了大概 15 分钟，我就确信自己做了一个十分正确的选择。</p>
<h2 id="部署说明">部署说明</h2>
<p>我之前就对 Railway 有所了解，所以直接点击 “Deploy on Railway” 按钮开始部署流程。</p>
<p><a href="https://railway.app">Railway</a> 是一个 PaaS 平台，可运行 JavaScript, Python, Go 等多种语言，提供 Redis, MySQL, MongoDB 等主流数据库存储。由于支持全面、界面友好，加上和 Cloudflare 一样有充裕的<a href="https://railway.app/pricing">免费额度</a>，足够个人项目免费使用，Railway 一直是我心中最好的 PaaS 之一。如果你有兴趣，欢迎通过我的 <a href="https://railway.app?referralCode=XkWaVV">referral link</a> 注册。</p>
<p>umani 有一篇 <a href="https://umami.is/docs/running-on-railway">Running on Railway</a> 文档，我遵照这个流程很快就完成了初步部署。其实只有一个 <code>HASH_SALT</code> 需要输入，其他只需点点点即可。</p>
<p>Railway Project 创建后，在管理界面可以看到两个 block，左边是数据库实例，右边是 umami 的后端服务。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway.png" type="" alt=""  /></p>
<h3 id="安装依赖">安装依赖</h3>
<p>在等待 umami 的镜像构建和部署的过程中，我们可以在命令行进行一些其他工作。</p>
<p>打开命令行，使用以下命令安装 Railway CLI 和 pgsql 两个软件依赖。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">brew install railwayapp/railway/railway
brew install libpg
</code></pre></div><p>完成后，将 libpg 的 bin 路径添加到 PATH 中，在 <code>.zshrc</code> 或 <code>.bashrc</code> 中添加一行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$PATH</span><span class="s2">:/opt/homebrew/opt/libpq/bin&#34;</span>
</code></pre></div><p>你可以通过执行 <code>type pgsql</code> 确认 <code>pgsql</code> 是否存在。</p>
<h3 id="更新数据库">更新数据库</h3>
<p>Railway 在创建 Project 时，会将 umami 的代码复制到在你的 GitHub 账户所创建的名为 <code>umami</code> 的仓库中，我们需要先将此仓库 clone 下来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">git clone git@github.com:username/umami.git
</code></pre></div><p>进入 umami 目录，执行以下命令，登录 Railway CLI 并完成链接:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> umami
railway login
railway link
</code></pre></div><p>这一步完成后，可以通过 <code>railway variables</code> 看到 umami 服务的环境变量，确认 CLI 可以访问到线上数据。</p>
<pre tabindex="0"><code>DATABASE_URL:        postgresql://postgres:xxxxxxxxx@containers-us-west.railway.app:6595/railway
DISABLE_TELEMETRY:   1
HASH_SALT:           xxXXxxXXxxXXxx
HOSTNAME:
PGDATABASE:          railway
PGHOST:              containers-us-west.railway.app
PGPASSWORD:          xxXXxxXXxxXXxx
PGPORT:              6595
PGUSER:              postgres
PORT:                3000
</code></pre><p>执行以下命令，为 umami 创建表格、添加初始数据。注意要将 bash variable 替换为上文中的数据:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">railway run psql -h <span class="nv">$PGHOST</span> -U <span class="nv">$PGUSER</span> -d <span class="nv">$PGDATABASE</span> -f sql/schema.postgresql.sql
</code></pre></div><h3 id="配置服务">配置服务</h3>
<p>数据库初始化完毕后，回到 Project 管理界面，确认 umami 部署完毕，即可打开服务的主页。</p>
<h4 id="更换密码">更换密码</h4>
<p>使用初始用户名密码 <code>admin:umami</code> 登录进去，然后立刻到 Settings &gt; Accounts 界面更换一个强密码。</p>
<h4 id="绑定个人域名">绑定个人域名</h4>
<p>在 Project 管理界面点击 umami，选择 Settings，在 Service Domains 下添加个人域名。比如我使用的是 <code>oishii.reorx.com</code>。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway-1.png" type="" alt=""  /></p>
<p>打开域名的 DNS 服务商，根据 Railway 中的提示，为自定义域名添加 CNAME 记录。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/cloudflare.png" type="" alt=""  /></p>
<p>等待几分钟，生效后 Railway 中会显示上图所示的 ✅ 符号。</p>
<h4 id="修改脚本名称">修改脚本名称</h4>
<p>为了避免 umami 被 ublock 误杀（有的规则集中有匹配 umami 的正则），还需要为它的统计脚本更换一个名称。<a href="https://umami.is/docs/environment-variables">Environment variables</a> 文档中的 <code>TRACKER_SCRIPT_NAME</code> 提供了这一功能。</p>
<p>再次进入 Railway，打开 umami 的 Variables 选项卡，按下图所示添加环境变量，我使用的名称为 <code>oishii</code>，可以更换为任意非 tracker 特征词汇。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/railway-2.png" type="" alt=""  /></p>
<p>完成这一步后，需要重新构建 umami 的镜像，目前我还没有找到触发 rebuild 的简单方法，只能通过修改 Dockerfile 实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff">RUN yarn next telemetry disable
<span class="gi">+# Ensures `yarn build` will always run when BUILD_TIME is different
</span><span class="gi">+ARG BUILD_TIME
</span><span class="gi"></span>RUN yarn build
</code></pre></div><p>在 <code>yarn build</code> 之前增加一行 <code>ARG BUILD_TIME</code>，这样当此参数不同时，就会触发 <code>yarn build</code> 及之后的命令重新执行。</p>
<p>保存修改，然后执行 <code>railway up</code>，等待镜像构建和部署完成。</p>
<h2 id="接入个人网站">接入个人网站</h2>
<p>一切准备就绪，我们重新使用自定义域名和修改后的密码登录 umami。</p>
<p>要进行统计，第一件事情是添加一个 Website。操作非常简单，读者可以参考 <a href="https://umami.is/docs/add-a-website">Add a website</a> 文档来进行。唯一需要注意的是 Enable share URL 选项，如果你想将自己网站的统计数据分享出去，则需要勾选之。你可以在 <a href="https://oishii.reorx.com/share/jKljpE4T/reorx.com">https://oishii.reorx.com/share/jKljpE4T/reorx.com</a> 访问本站的统计信息。</p>
<p>添加完成后，点击网站列表中对应网站的 Get tracking code 按钮，在浮窗中获得需要加入到网站 HTML 中的代码。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/umami.png" type="" alt=""  /></p>
<p>需要注意将 <code>src</code> 结尾的 <code>umami.js</code> 替换为 <code>$TRACKER_SCRIPT_NAME.js</code>。</p>
<p>复制代码并添加到自己个人网站的 <code>&lt;head&gt;</code> 标签下的任意位置，由于使用了 <code>defer</code> 属性，这个 script 不会对网页加载造成阻塞。</p>
<p>网站更新完成后，呼朋唤友点击访问一番，就可以看到 umami 清晰、美观的统计数据了。</p>
<p><img loading="lazy" src="/blog/deploy-umami-for-personal-website/images/umami-1.png" type="" alt=""  /></p>
]]></content:encoded></item><item><title>Frontend Guide 01: Webpack babel-loader 使用指南</title><link>https://reorx.com/blog/migrate-from-ts-loader-to-babel-loader/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/migrate-from-ts-loader-to-babel-loader/</guid><description>Frontend Guide 系列的第一篇文章，讲述我为何从 ts-loader 迁移到 babel-loader，以及我的 babel-loader 详细配置方案说明。</description><content:encoded><![CDATA[<h2 id="引子">引子</h2>
<p>大约在两个月前，为了做出一款属于自己的产品，我正式开始学习 TypeScript 和 React 开发<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。虽然接触 JavaScript 时间不短了，但一直热衷于使用 Vanilla JS，也没有正式做过比较严肃的项目。因此，我把自己定位为一个前端新手，决定从 0 开始学习现代化前端开发。</p>
<p>这两个月来，我在学习实践过程中累计了一些自己的心得和体会，算不上高深，但应该可以为同样在学习中的新手起到参考作用。从这篇文章开始，我会逐一将我认为有价值的部分写成博客，归类于 #frontend-guide 标签下，并在未来的学习中持续更新。作为一个非专业的前端学习者，这些文章中一定会出现错误和疏漏，请读者朋友们不吝指正，如果能从批评中学到什么，将会是我写作的最大收获。</p>
<p>先大致列举一些可写的话题，以作备忘：</p>
<ul>
<li>如何构建一个最基本的 TypeScript 项目
<ul>
<li>介绍 package.json 和基本的 devDependencies</li>
<li>介绍 tsconfig.json 中必须了解的选项</li>
<li>tsc 和 esbuild</li>
</ul>
</li>
<li>如何使用 jest 进行细粒度的 TDD</li>
<li>从零开始构建自己的 React project template
<ul>
<li>不使用 create-react-app 有哪些好处</li>
<li>webpack</li>
<li>babel: modular import and hot reload</li>
<li>config and APP_ENV</li>
</ul>
</li>
<li>如何构建一个最基本的 monorepo
<ul>
<li>npm workspace</li>
<li>tsconfig reference</li>
<li>webpack: resolve alias and tsconfig paths plugin</li>
</ul>
</li>
<li>TypeScript caveats and cheatsheet</li>
<li>如何使用 TypeScript 和 React 开发 Chrome Extension</li>
<li>Mobx 使用指南</li>
<li>实现一个简单的 useFetch Hook</li>
<li>如何使用 swr 调用 HTTP API</li>
<li>如何使用 Protobuf 和 TypeScript 封装 HTTP API</li>
</ul>
<h2 id="ts-loader">ts-loader</h2>
<p>在现代化前端项目中，TypeScript 因其静态类型的特性，为代码的可维护性、健壮性带来了极大的提升，已逐渐成为前端开发的标准语言。但 TypeScript 不能直接在浏览器中运行，因此在项目构建流程中需要引入 <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a> 来将其编译为浏览器可用的 JavaScript。<a href="https://github.com/TypeStrong/ts-loader">ts-loader</a> 就是为 Webpack 设计的 transpiler 之一。</p>
<p>过去的开发生涯中，我虽然不是专业的前端，也对 JavaScript 世界中的基石 babel 有所耳闻目见。但在这次从零开始学习 TypeScript 开发时，因为对 babel 有种过于复杂的印象，我选择了 ts-loader 作为第一个学习和上手的插件。</p>
<p>ts-loader 的使用非常简单，文档也足够清晰，如果你的项目本身有正确配置 <code>tsconfig.json</code> 并可以使用 <code>tsc -b</code> 完成编译，那么在 webpack 中引入 ts-loader 后不需要额外的配置即可工作。</p>
<p>下面是一份使用 ts-loader 的 <code>webpack.config.js</code> 示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">entry</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">index</span><span class="o">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">srcDir</span><span class="p">,</span> <span class="s1">&#39;index.tsx&#39;</span><span class="p">),</span>
  <span class="p">},</span>
  <span class="nx">output</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">path</span><span class="o">:</span> <span class="nx">destDir</span><span class="p">,</span>
    <span class="nx">filename</span><span class="o">:</span> <span class="s1">&#39;[name].bundle.js&#39;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;ts-loader&#39;</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>经过一段时间的使用，我发现了对 ts-loader 不太满意的几个地方：</p>
<ul>
<li>
<p>偶尔出现莫名的错误</p>
<p>有的时候，当对 TypeScript 源文件进行了某种变更，或许是大量的类型变化，或许是文件重命名和移动目录，可能会触发 ts-loader 报错，但此时 VSCode 的静态检查器却没有显示出任何问题（所有源文件），重启 webpack serve 也无济于事。这时只能通过删除所有与构建过程和结果有关的文件，如 <code>build</code>, <code>dist</code>, <code>**/*.d.ts</code>, <code>*.tsbuildinfo</code>，重新运行才可以消除这个不存在的错误。</p>
</li>
<li>
<p>难以 Debug 某些 transpiling 过程中的错误</p>
<p>如果你的 <code>tsconfig.json</code> 中设置了 <code>noEmit: true</code> 或 <code>noEmitOnError: true</code>, 那你很有可能会看到 <code>Error: TypeScript emitted no output for…</code> 这样的报错，这是因为 ts-loader 在将 TypeScript 转换成 JavaScript 时无法成功，于是没有输出 js 文件。但具体是什么错误，完全无法搞清楚。我在 GitHub 上跟踪了一个 <a href="https://github.com/TypeStrong/ts-loader/issues/1257">issue</a>, 目前仍然没有收获。</p>
</li>
<li>
<p>项目内多个 package 引用必须生成描述文件</p>
<p>如果想在项目内想要拆分多个 package 并互相引用，需要使用 TypeScript 的 <a href="https://www.typescriptlang.org/docs/handbook/project-references.html">Project References</a> 功能，而 <code>declaration</code>  必须设置为 true，此时 ts-loader 会为被引用的包生成 <code>.d.ts</code> 的描述文件，使文件浏览器变得混乱。</p>
</li>
<li>
<p>在插件生态中不是一等公民</p>
<p>一些优化项目开发流程的插件，如 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">react-refresh-webpack-plugin</a>, 优先支持 babel 而非 ts-loader；<a href="https://github.com/umijs/babel-plugin-import">babel-plugin-import</a> 的 ts-loader 实现 <a href="https://github.com/Brooooooklyn/ts-import-plugin">ts-import-plugin</a> 远不如其本身流行。</p>
</li>
</ul>
<p>于是我决定对 babel-loader 进行一次尝试。</p>
<h2 id="babel-loader">babel-loader</h2>
<p><a href="https://github.com/babel/babel-loader">babel-loader</a> 的项目页面有详细的安装配置说明，在此不做赘述。下面是一个在 TypeScript + React 项目中工作的最小化配置示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
            <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
              <span class="nx">presets</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-env&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">targets</span><span class="o">:</span> <span class="s2">&#34;defaults&#34;</span> <span class="p">}],</span>
                <span class="s1">&#39;@babel/preset-typescript&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-react&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;runtime&#39;</span><span class="o">:</span> <span class="s1">&#39;automatic&#39;</span><span class="p">}]</span>
              <span class="p">],</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>配置完成后，代码顺利编译，随后我开始了对构建配置优化的探索。</p>
<h3 id="webpack-bundle-analyzer">webpack-bundle-analyzer</h3>
<p>我首先想到的是对构建出的 bundle 的大小进行检查，一看竟然有 7MB 之大，于是安装了 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>, 对 bundle 中所包含的依赖进行分析。</p>
<p>下面是引入 webpack-bundle-analyzer 之后的 <code>webpack.config.js</code> 文件，通过环境变量 <code>WEBPACK_USE_ANALYZE</code> 判断是否进入分析模式并修改 webpack 配置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">useAnalyze</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">WEBPACK_USE_ANALYZE</span>

<span class="kr">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{...}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">useAnalyze</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">BundleAnalyzerPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;webpack-bundle-analyzer&#39;</span><span class="p">).</span><span class="nx">BundleAnalyzerPlugin</span><span class="p">;</span>

  <span class="nx">config</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="s1">&#39;development&#39;</span>
  <span class="nx">config</span><span class="p">.</span><span class="nx">plugins</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">BundleAnalyzerPlugin</span><span class="p">({</span>
      <span class="nx">analyzerPort</span><span class="o">:</span> <span class="mi">18888</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">config</span>
</code></pre></div><p>运行 <code>WEBPACK_USE_ANALYZE=1 webpack</code> 在浏览器中查看分析结果。</p>
<p><img loading="lazy" src="/blog/migrate-from-ts-loader-to-babel-loader/images/webpack-analyze.png" type="" alt=""  /></p>
<p>原来 tabler-icons-react 一个库就占了 5.28MB，其他库中 lodash 也不算正常，似乎和 tabler-icons-react 一样被完整包含进来了。</p>
<h3 id="babel-plugin-import">babel-plugin-import</h3>
<p><a href="https://github.com/konradkalemba/tabler-icons-react">tabler-icons-react</a> 是一个 SVG 图标库，我只是使用了其中一部分图标。lodash 是非常通用的工具函数库，同样的，我只对其中一部分函数进行了引用。那么有没有办法按需加载依赖中的模块，只输出被 import 到的部分呢？答案就是 <a href="https://github.com/umijs/babel-plugin-import">babel-plugin-import</a>。</p>
<p>继续修改 <code>webpack.config.js</code>，为 babel-loader 增加 plugins:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
    <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;tabler-icons-react&#39;</span><span class="p">,</span>
        <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;dist/icons&#39;</span><span class="p">,</span>
      <span class="p">}],</span>
      <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;lodash&#39;</span><span class="p">,</span>
        <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">camel2DashComponentName</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="p">}],</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>再次运行 <code>WEBPACK_USE_ANALYZE=1 webpack</code> ，可以看出 bundle 结构有了显著的改进（红色的部分是 tabler-icons-react 和 lodash）:</p>
<p><img loading="lazy" src="/blog/migrate-from-ts-loader-to-babel-loader/images/webpack-analyze-2.png" type="" alt=""  /></p>
<blockquote>
<p><a href="https://github.com/lodash/babel-plugin-lodash">babel-plugin-lodash</a> 也可以实现 lodash 的按需加载，但它是专为 lodash 开发的，不具备 babel-plugin-import 的通用性。</p>
</blockquote>
<h3 id="babelpreset-env">@babel/preset-env</h3>
<p><a href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a> 是 babel 中最重要的一个 preset。所谓 preset，即预设配置的封装，让需求相近的用户可以不用关注细节直接使用，preset-env 提供了非常丰富的选项，让使用者可以快速定制出符合目标需求的编译结果。</p>
<p>首先要关注的是 <a href="https://babeljs.io/docs/en/options#targets">targets</a> 选项，它决定了 babel 所编译出的 JavaScript 能否在特定平台上运行。<code>targets</code> 支持 <a href="https://github.com/ai/browserslist">browserslist</a> 语法，上文中我们的初始配置 <code>['@babel/preset-env', { targets: &quot;defaults&quot; }],</code> 代表使用 browserslist 的 defaults 查询<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>，虽然可以编译，但在浏览器中是无法运行的，会产生
<code>Uncaught ReferenceError: regeneratorRuntime is not defined</code> 错误，这是为什么呢？</p>
<p>为了统一不同浏览器的 JavaScript 实现差异，使 ES2015+ 代码可以正确运行，babel 会根据 targets 决定是否需要在编译结果中注入 polyfill。
最早这一功能由 <a href="https://babeljs.io/docs/en/babel-polyfill">@babel/polyfill</a> 实现，但它在 babel 7.4.0 之后被废弃，由 <a href="https://github.com/zloirock/core-js">core-js </a> 接替。我们的代码之所以运行报错，就是因为没有指定 preset-env 使用 core-js，导致用于模拟 ES2015+ 运行环境的 <code>regeneratorRuntime</code> 缺失。</p>
<p>修改后的 preset-env 配置如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">[</span><span class="s2">&#34;@babel/preset-env&#34;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">targets</span><span class="o">:</span> <span class="s2">&#34;defaults&#34;</span><span class="p">,</span>
  <span class="nx">corejs</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="nx">useBuiltIns</span><span class="o">:</span> <span class="s1">&#39;usage&#39;</span><span class="p">,</span>
<span class="p">}]</span>
</code></pre></div><p>重新编译，代码即可成功运行。并且通过 webpack-bundle-analyzer 可以发现 bundle 中多出了 core-js 的部分。</p>
<p>如果想在对浏览器的支持上激进一些，可以尝试将 targets 设为 <code>{browsers: '&gt; 5%'}</code>，即仅支持占有率超过 5% 的浏览器，你会发现 bundle 中 core-js 的部分会再次消失，因为这些浏览器不需要 core-js 就有完整的 ES2015 支持。</p>
<h3 id="react-refresh-webpack-plugin">react-refresh-webpack-plugin</h3>
<p>webpack 提供 <a href="https://webpack.js.org/concepts/hot-module-replacement/">HMR</a> 热更新功能，不需要刷新页面即可将改动反映到页面中。在 babel-loader 中，需要通过 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">react-refresh-webpack-plugin</a> 插件来实现 React JSX 的热更新。</p>
<p>首先要在 devServer 中开启 <code>hot</code> 选项:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">devServer</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// Enable hot reloading
</span><span class="c1"></span>    <span class="nx">hot</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后为 webpack 添加 <code>ReactRefreshWebpackPlugin</code> 插件:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">ReactRefreshWebpackPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;@pmmmwh/react-refresh-webpack-plugin&#39;</span><span class="p">);</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nx">ReactRefreshWebpackPlugin</span><span class="p">(),</span>
  <span class="p">],</span>
<span class="p">}</span>
</code></pre></div><p>最后为 babel-loader 添加 <code>react-refresh/babel</code> 插件，通过 <code>isDevelopment</code> 决定是否存在:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">{</span>
  <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
  <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
      <span class="nx">isDevelopment</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;react-refresh/babel&#39;</span>
    <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="summary">Summary</h3>
<p>将以上插件和技巧综合起来，最终我的 babel-loader 配置如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">module</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">rules</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nx">test</span><span class="o">:</span> <span class="sr">/\.tsx?$/</span><span class="p">,</span>
        <span class="nx">exclude</span><span class="o">:</span> <span class="sr">/node_modules/</span><span class="p">,</span>
        <span class="nx">use</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nx">loader</span><span class="o">:</span> <span class="s1">&#39;babel-loader&#39;</span><span class="p">,</span>
            <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
              <span class="nx">presets</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-env&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">targets</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">browsers</span><span class="o">:</span> <span class="s1">&#39;&gt; 5%&#39;</span><span class="p">,</span>
                  <span class="p">},</span>
                  <span class="nx">corejs</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
                  <span class="nx">useBuiltIns</span><span class="o">:</span> <span class="s1">&#39;usage&#39;</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="s1">&#39;@babel/preset-typescript&#39;</span><span class="p">,</span>
                <span class="p">[</span><span class="s1">&#39;@babel/preset-react&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;runtime&#39;</span><span class="o">:</span> <span class="s1">&#39;automatic&#39;</span><span class="p">}]</span>
              <span class="p">],</span>
              <span class="nx">plugins</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;tabler-icons-react&#39;</span><span class="p">,</span>
                  <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;dist/icons&#39;</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="p">[</span><span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">libraryName</span><span class="o">:</span> <span class="s1">&#39;lodash&#39;</span><span class="p">,</span>
                  <span class="nx">libraryDirectory</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                  <span class="nx">camel2DashComponentName</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                <span class="p">}],</span>
                <span class="nx">isDevelopment</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;react-refresh/babel&#39;</span>
              <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">),</span>
            <span class="p">},</span>
          <span class="p">},</span>
        <span class="p">],</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>它实现了：</p>
<ul>
<li>输出支持现代主流浏览器的 JavaScript</li>
<li>按需加载 tabler-icons-react 和 lodash 模块</li>
<li>React JSX 开发热更新</li>
</ul>
<p>如果你想看到一个可运行的例子，请参考我的最小化 React 项目模板 <a href="https://github.com/reorx/minireact">reorx/minireact</a>，其中有完整的 <a href="https://github.com/reorx/minireact/blob/6e5b086e309cdbe7132c268ba8cf1e6e5d5ab32e/webpack.config.js">webpack.config.js</a> 文件。</p>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-05-18: created</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>开始学习时的推文: <a href="https://twitter.com/novoreorx/status/1500385952942157828">学习了俩小时如何开始一个 TypeScript 项目，现在已经不省人事了</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>根据 browerslist 文档，<code>defaults</code> 代表 <code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>，是一个非常宽泛的规则，可覆盖全世界所有浏览器中的 <a href="https://browserslist.dev/?q=ZGVmYXVsdHM%3D">90%</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>Google I/O 2022 Web Platform 新特性展示观看笔记</title><link>https://reorx.com/blog/notes-on-google-io-2022-web-platform-presentation/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/notes-on-google-io-2022-web-platform-presentation/</guid><description>了解 Web 新技术从未如此充满乐趣。</description><content:encoded><![CDATA[<p>几天前临睡时看了 2022 Google IO 的一个 presentation: <a href="https://www.youtube.com/watch?v=5b4YcLB4DVI">What&rsquo;s new for the web platform</a>, 两位 Google 员工的解说让了解 Web 新技术的过程变得充满乐趣，于是做了些笔记在 <a href="https://threadreaderapp.com/thread/1525875286096904192.html">Twitter thread</a> 中。这篇文章对笔记进行了整理，并为每个特性附加详细说明的链接。</p>
<div class="tweet social-quote">
  <div class="title">
    <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>

    
  </div>

  <blockquote class="twitter-tweet" data-dnt="true"><p lang="zh" dir="ltr">开个串记录下观看 Google IO What&#39;s new for the web platform 中发现的有趣的 feature<a href="https://t.co/LZPGGn7NHZ">https://t.co/LZPGGn7NHZ</a></p>&mdash; Reorx (@novoreorx) <a href="https://twitter.com/novoreorx/status/1525875286096904192?ref_src=twsrc%5Etfw">May 15, 2022</a></blockquote>

</div>


<h2 id="html">HTML</h2>
<h3 id="dialog"><code>&lt;dialog&gt;</code></h3>
<p><a href="https://web.dev/building-a-dialog-component/">https://web.dev/building-a-dialog-component/</a></p>
<p><code>&lt;dialog&gt;</code> 和 <code>&lt;selectmenu&gt;</code>，基本上所有 UI Kit 都会在组件库里实现的功能，终于被 HTML 原生实现了。如果 HTML 能多一些这种常用的交互组件，我会很乐意手写 Vanilla JS 来使用它们。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-dialog.png" type="" alt=""  /></p>
<h3 id="selectmenu"><code>&lt;selectmenu&gt;</code></h3>
<p><a href="https://open-ui.org/prototypes/selectmenu">https://open-ui.org/prototypes/selectmenu</a></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-selectmenu.png" type="" alt=""  /></p>
<h3 id="input-typedatetile-local"><code>&lt;input type=datetile-local&gt;</code></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local</a></p>
<p>记得 7 年前在豌豆荚工作时，因为这个标签不被 Firefox 支持，被迫找了一个 JavaScript 库来代替 (Pikaday, I still remember)。如今终于可以在主流浏览器上全面通用，太不容易了😭。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-datetime-local.png" type="" alt=""  /></p>
<h2 id="css">CSS</h2>
<h3 id="has-selector"><code>:has</code> selector</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has">https://developer.mozilla.org/en-US/docs/Web/CSS/:has</a></p>
<p>用于声明父子元素关系的 :has 选择器！这个功能前阵子正好搜索过，现在只能用 JavaScript 实现。</p>
<p>图中的代码可以解释为，在包含 <code>&lt;figcaption&gt;</code> 的 <code>&lt;figure&gt;</code> 元素中，将其 children 中的 <code>&lt;img&gt;</code> 增加 1rem 的 bottom margin。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-has.png" type="" alt=""  /></p>
<h3 id="aspect-ratio">Aspect ratio</h3>
<p><a href="https://web.dev/aspect-ratio/">https://web.dev/aspect-ratio/</a></p>
<p>CSS aspect-radio，使元素保持固定的宽高比。这是曾经在 <code>&lt;img&gt;</code> 标签上的实验特性，如今终于被所有元素支持了。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-aspect-ratio.png" type="" alt=""  /></p>
<h3 id="cascade-layer">Cascade Layer</h3>
<p><a href="https://developer.chrome.com/blog/cascade-layers/">https://developer.chrome.com/blog/cascade-layers/</a></p>
<p>Cascade Layers, 给 CSS 加上了层级的概念，layer 可以自由排列顺序，后面的比前面的有更高的优先级 (specificity)；还展示了下越来越复杂的 CSS 优先级关系图，其实也可以把每一级都当做一个 layer。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-cascade-layer.png" type="" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-cascade-layer-1.png" type="" alt=""  /></p>
<h3 id="container-queries">Container queries</h3>
<p>Container queries，在响应式中能够发挥重要作用，但我基本没听懂，未来应该会影响一些 CSS 框架的 API，到时候再来学习吧。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-container-queries.png" type="" alt=""  /></p>
<h3 id="accent-color">Accent color</h3>
<p><a href="https://web.dev/accent-color/">https://web.dev/accent-color/</a></p>
<p>CSS accent-color，为 HTML 基本元素设定一个统一的色调，主流浏览器在一年内都争先恐后地实现了😂，毕竟这是最能体现自己颜值的功能。不知道能不能和操作系统的 accent-color 互通，这样体验就更一致了。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-accent-color.png" type="" alt=""  /></p>
<h2 id="javascript">JavaScript</h2>
<h3 id="arrayprototypeat">Array.prototype.at</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at</a></p>
<p>Array 增加了 at 方法，JavaScript 终于可以用类似 Python <code>list[-1]</code> 的写法了。这曾经是我刚学习 JavaScript 时觉得它不如 Python 最主要的原因。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-array-at.png" type="" alt=""  /></p>
<h3 id="urlpattern">URLPattern</h3>
<p><a href="https://web.dev/urlpattern/">https://web.dev/urlpattern/</a></p>
<p>新类型 URLPattern，定义 URL 路径中的参数并解析出对应的 object。routing library 不用再写麻烦的正则了</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-urlpattern.png" type="" alt=""  /></p>
<h3 id="structuredclone">structuredClone</h3>
<p><a href="https://web.dev/structured-clone/">https://web.dev/structured-clone/</a></p>
<p>有了 structuredClone, 再也不用写 JSON.parse JSON.stringify 这种扭曲心智的代码了，非常适合在面试官问到 deep clone 的问题时反将一军。还可以用来 clone 其他数据结构如 blobs, bitmaps, typed arrays。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-structuredclone.png" type="" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-structuredclone-1.png" type="" alt=""  /></p>
<h3 id="createimagebitmap">createImageBitmap</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap">https://developer.mozilla.org/en-US/docs/Web/API/createImageBitmap</a></p>
<p>createImageBitmap, 把 blob 直接转化成 Image 对象，改善了一直以来复杂而脆弱的写法。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-blob.png" type="" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-blob-1.png" type="" alt=""  /></p>
<h2 id="miscellaneous">Miscellaneous</h2>
<h3 id="chips">CHIPS</h3>
<p><a href="https://developer.chrome.com/docs/privacy-sandbox/chips/">https://developer.chrome.com/docs/privacy-sandbox/chips/</a></p>
<p>CHIPS 全称 Cookies Having Independent Partitioned State, 是 Cookie 在安全策略上的新特性，为 Set-Cookie 增加了 <code>Partitioned</code> 关键词。可以使特定 cookie 在 iframe 中只用于当前站点。自两年前 <code>SameSite</code> 关键词推广后，third-party cookie 只能选择全有或者全无，这次终于有了一个折中的选择。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-chips.png" type="" alt=""  /></p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-chips-1.png" type="" alt=""  /></p>
<h3 id="window-controls-overlay">Window controls overlay</h3>
<p><a href="https://web.dev/window-controls-overlay/">https://web.dev/window-controls-overlay/</a></p>
<p>Window controls overlay 是一组 <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web app manifests</a>, CSS, JavaScript API 的集合，实现了定制 PWA 窗口在 window bar 部分区域的显示效果，用于获得更有沉浸感的使用体验。</p>
<p><img loading="lazy" src="/blog/notes-on-google-io-2022-web-platform-presentation/images/google-io-2022-web-wco.png" type="" alt=""  /></p>
]]></content:encoded></item><item><title>PyYAML 使用技巧</title><link>https://reorx.com/blog/python-yaml-tips-zh/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/python-yaml-tips-zh/</guid><description>分享我在 Python 下使用 PyYAML 的技巧和代码片段，并介绍几个相关的库。</description><content:encoded><![CDATA[<blockquote>
<p>英文版: <a href="https://reorx.com/blog/python-yaml-tips/">Tips that may save you from the hell of PyYAML</a>
</p>
</blockquote>
<p>YAML 是一个被广泛使用的数据序列化和配置语言，作为一个开发者，总是不免和它打交道。
但处理 YAML 文档，尤其是使用 PyYAML 的过程总是非常痛苦。</p>
<p>这篇文章分享我在 Python 下使用 PyYAML 的技巧和代码片段，并介绍几个相关的库。</p>
<blockquote>
<p>注意：本文中的代码仅保证在 Python 3 下正常工作</p>
</blockquote>
<h2 id="总是使用-safe_loadsafe_dump">总是使用 <code>safe_load/safe_dump</code></h2>
<p>PyYAML 的 <code>load</code> 函数可以构造任意 Python 对象（Pickle 协议），这意味着一次 <code>load</code> 可能导致任意 Python 函数被执行。</p>
<p>为了确保应用程序的安全性，尽量在任何情况下使用 <code>yaml.safe_load</code> 和 <code>yaml.safe_dump</code>。</p>
<h2 id="保留字段顺序">保留字段顺序</h2>
<p>Python 3.7+ 中，<code>dict</code> keys 具备保留插入顺序的特性，所以通过 <code>yaml.safe_load</code> 得到的 <code>dict</code>，其 keys 顺序会与原始文件保持一致。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;---
</span><span class="s2">... c: 1
</span><span class="s2">... b: 1
</span><span class="s2">... d: 1
</span><span class="s2">... a: 1
</span><span class="s2">... &#34;&#34;&#34;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
</code></pre></div><p>当把 <code>dict</code> 导出为 YAML 字符串时，为 <code>yaml.safe_dump</code> 传递 <code>sort_keys=False</code> 来保留 keys 的顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>如果 Python 版本较低，或者你想确保代码能在更广泛的环境下工作，你可以使用 <a href="https://github.com/wimglenn/oyaml">oyaml</a> 库来代替 PyYAML 的 <code>yaml</code> 包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">oyaml</span> <span class="k">as</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><h2 id="优化列表项的缩进">优化列表项的缩进</h2>
<p>默认情况下，PyYAML 输出的列表缩进与其父元素一致。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
<span class="o">-</span> <span class="mi">1</span>
<span class="o">-</span> <span class="mi">2</span>
<span class="o">-</span> <span class="mi">3</span>
</code></pre></div><p>这并不是很好的格式，根据
<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">Ansible</a>
和 <a href="https://developers.home-assistant.io/docs/documenting/yaml-style-guide/#block-style-sequences">HomeAssistant</a>
等 YAML 书写规范，列表项应该缩进 2 空格。</p>
<p>这种格式也会对导致列表项不会被如 VSCode 等编辑器识别，进而无法使用编辑器的折叠功能。</p>
<p>要解决这个问题，使用如下代码片段，在代码中定义 <code>IndentDumper</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">IndentDumper</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">Dumper</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">increase_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indentless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndentDumper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">increase_indent</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>然后将它传递给 <code>yaml.dump</code> 的 <code>Dumper</code> 关键字参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dumper</span><span class="o">=</span><span class="n">IndentDumper</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
  <span class="o">-</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="mi">2</span>
  <span class="o">-</span> <span class="mi">3</span>
</code></pre></div><blockquote>
<p>注意，<code>yaml.safe_dump</code> 由于有自己的 Dumper class，传递此参数会造成冲突。</p>
</blockquote>
<h2 id="输出可读的-utf-8-字符">输出可读的 UTF-8 字符</h2>
<p>默认情况下，PyYAML 假设你希望输出的结果里只有 ASCII 字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;你好&#39;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="s2">&#34;</span><span class="se">\u4F60\u597D</span><span class="s2">&#34;</span>
</code></pre></div><p>这会让输出结果非常难以阅读。</p>
<p>在 UTF-8 足够普及的今天，直接输出 UTF-8 字符是非常安全的。
因此我们可以将 <code>allow_unicode=True</code> 传入 <code>yaml.safe_dump</code> 使 PyYAML 将 Unicode 转换成 UTF-8 字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">allow_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="n">你好</span>
</code></pre></div><h2 id="一些-yaml-相关的库">一些 YAML 相关的库</h2>
<h3 id="oyaml">oyaml</h3>
<p>Link: <a href="https://github.com/wimglenn/oyaml">https://github.com/wimglenn/oyaml</a></p>
<p>正如上文中提到的，oyaml 是 <code>yaml</code> 包的替换品，使 <code>dict</code> keys 的顺序在 dump/load 的时候得以保留。</p>
<p>oyaml 是一个单文件库，只有 <a href="https://github.com/wimglenn/oyaml/blob/d0195070d26bd982f1e4e604bded5510dd035cd7/oyaml.py">53 行代码</a>，因此使用起来非常灵活，你可以直接把它的代码复制到自己的项目中，然后根据自己的需求进行修改。</p>
<h3 id="strictyaml">strictyaml</h3>
<p>Link: <a href="https://github.com/crdoconnor/strictyaml">https://github.com/crdoconnor/strictyaml</a></p>
<p>有的人说 YAML 过于复杂和灵活，不是一个好的配置语言。但我认为这不是 YAML 的问题，而是使用方式的问题。如果我们限制程序只使用 YAML 的部分功能，YAML 其实可以变得像它设计的那般好用。</p>
<p>这就是 StrictYAML 的设计意图，它是一个类型安全的 YAML 解析器，实现了 YAML 规范说明中的一个<a href="https:c//hitchdev.com/strictyaml/features-removed">子集</a> 。</p>
<p>如果你对 YAML 的输入输出有较强的安全考虑，建议使用 StrictYAML 代替 PyYAML。</p>
<p>顺带一提的是，StrictYAML 的<a href="https://hitchdev.com/strictyaml/">文档站</a>有很多关于设计细节和配置语言思考的文章，非常值得一看。</p>
<h3 id="ruamelyaml">ruamel.yaml</h3>
<p>Link: <a href="https://yaml.readthedocs.io/en/latest/overview.html">https://yaml.readthedocs.io/en/latest/overview.html</a></p>
<p>ruamel.yaml 是 PyYAML 的一个分叉，于 2009 年发布并持续维护至今。</p>
<p>ruamel.yaml 的文档里详细说明了它和 PyYAML 的<a href="https://yaml.readthedocs.io/en/latest/pyyaml.html#yaml-1-2-support">差异</a>。
总体来说，ruamel.yaml 专注在 <a href="https://yaml.org/spec/1.2.2/">YAML 1.2</a>  上，对一些语法进行了优化。</p>
<p>ruamel.yaml 最令我感兴趣的特性是输入输出的 “round-trip”，可以最大程度地保留输入源的原始格式。官方文档中的定义是这样的：</p>
<blockquote>
<p>A round-trip is a YAML load-modify-save sequence and ruamel.yaml tries to preserve, among others:</p>
<ul>
<li>comments</li>
<li>block style and key ordering are kept, so you can diff the round-tripped source</li>
<li>flow style sequences ( ‘a: b, c, d’) (based on request and test by Anthony Sottile)</li>
<li>anchor names that are hand-crafted (i.e. not of the form<code>idNNN</code>)</li>
<li>merges in dictionaries are preserved</li>
</ul>
</blockquote>
<p>如果你有尽可能保留原始格式的需求，建议使用 ruamel.yaml 代替 PyYAML。</p>
<blockquote>
<p>在使用中我注意到 ruamel.yaml 的 safe load 方法 (<code>YAML(typ='safe').load</code>) 与 PyYAML 有些不同，它无法解析 flow style 的集合定义 (如 <code>a: {&quot;foo&quot;: &quot;bar&quot;}</code>)，这点没有在文档中提及，使用时须多加注意。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>YAML 有它好的地方和坏的地方。它易于阅读，初期的学习曲线非常平缓。
但 YAML 的规范说明非常复杂，不仅造成了使用中的混乱，也使不同语言的实现在很多细微的地方难以保持一致。</p>
<p>尽管有这些小毛病，YAML 仍然是我心中最好的配置语言。希望这篇文章所介绍的技巧能够帮助你避免问题，获得更好的开发和使用体验。</p>
]]></content:encoded></item><item><title>Tips that may save you from the hell of PyYAML</title><link>https://reorx.com/blog/python-yaml-tips/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/python-yaml-tips/</guid><description>Try to make our life with PyYAML easier.</description><content:encoded><![CDATA[<p>YAML is a data-serialization language that is widely used.
As a developer, I&rsquo;m always dealing with YAML from time to time.
But processing YAML, especially using PyYAML in Python is painful and full of traps.
Here I want to share some tips and snippets that can make your life with PyYAML easier.</p>
<blockquote>
<p>Code in this article is only guaranteed to work in Python 3</p>
</blockquote>
<h2 id="always-use-safe_loadsafe_dump">Always use safe_load/safe_dump</h2>
<p>YAML&rsquo;s ability to construct an arbitrary Python object makes it dangerous to use blindly.
It might be harmful to your application to simply <code>yaml.load</code> a document from an untrusted source such as the Internet and user input.</p>
<p>See from <a href="https://pyyaml.org/wiki/PyYAMLDocumentation#loading-yaml">PyYAML official documentation</a>:</p>
<blockquote>
<p><strong>Warning</strong>: It is not safe to call <code>yaml.load</code> with any data received from an untrusted source! <code>yaml.load</code> is as powerful as <code>pickle.load</code> and so may call any Python function.</p>
</blockquote>
<p>In short, you should always use <code>yaml.safe_load</code> and <code>yaml.safe_dump</code> as the standard I/O methods for YAML.</p>
<h2 id="keep-keys-in-order-loaddump">Keep keys in order (load/dump)</h2>
<p>In Python 3.7+, the order of dict keys is naturally preserved <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, thus the dict you get from <code>yaml.safe_load</code> has the same order of keys as the original file.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;---
</span><span class="s2">... c: 1
</span><span class="s2">... b: 1
</span><span class="s2">... d: 1
</span><span class="s2">... a: 1
</span><span class="s2">... &#34;&#34;&#34;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span>
</code></pre></div><p>When dumping dict into a YAML string, make sure to add keyword argument <code>sort_keys=False</code> to preserve the order of keys.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>If your Python version is lower, or you want to make sure the keys order preserving always works, you can use this library called <a href="https://github.com/wimglenn/oyaml">oyaml</a> as a drop-in replacement for <code>pyyaml</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">oyaml</span> <span class="k">as</span> <span class="nn">yaml</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">b</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">e</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><h2 id="enhance-list-indentation-dump">Enhance list indentation (dump)</h2>
<p>By default, PyYAML indent list items on the same level as their parent.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
<span class="o">-</span> <span class="mi">1</span>
<span class="o">-</span> <span class="mi">2</span>
<span class="o">-</span> <span class="mi">3</span>
</code></pre></div><p>This is not a good format according to style guides like
<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html">Ansible</a>
and <a href="https://developers.home-assistant.io/docs/documenting/yaml-style-guide/#block-style-sequences">HomeAssistant</a>.
It is also not recognized by code editors like VSCode, making the list items unfoldable in the editor.</p>
<p>To solve this problem, you can use the snippet below to define an <code>IndentDumper</code> class:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">IndentDumper</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">Dumper</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">increase_indent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indentless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndentDumper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">increase_indent</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>Then pass it to the <code>Dumper</code> keyword argument in <code>yaml.dump</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dumper</span><span class="o">=</span><span class="n">IndentDumper</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span>
  <span class="o">-</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="mi">2</span>
  <span class="o">-</span> <span class="mi">3</span>
</code></pre></div><blockquote>
<p>Note that <code>Dumper</code> cannot be passed to <code>yaml.safe_dump</code> which has its owner dumper class defined.</p>
</blockquote>
<h2 id="output-readable-utf-8-dump">Output readable UTF-8 (dump)</h2>
<p>By default, PyYAML assumes the user only wants ASCII code in the output,
so it converts UTF-8 characters to Python&rsquo;s Unicode representation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;你好&#39;</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="s2">&#34;</span><span class="se">\u4F60\u597D</span><span class="s2">&#34;</span>
</code></pre></div><p>This makes the output hard to read for humans.</p>
<p>In the modern world, UTF-8 is widely supported, it&rsquo;s safe to write UTF-8 in the output.
Pass <code>allow_unicode=True</code> to <code>yaml.safe_dump</code> to enable that.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">allow_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">a</span><span class="p">:</span> <span class="n">你好</span>
</code></pre></div><h2 id="no-default_flow_style-needed-dump">No <code>default_flow_style</code> needed (dump)</h2>
<p>Most of the time we don&rsquo;t want <a href="https://yaml.org/spec/1.2.2/#chapter-7-flow-style-productions">flow style productions</a> in the output (i.e. no JSON in YAML).
According to <a href="https://pyyaml.org/wiki/PyYAMLDocumentation#dictionaries-without-nested-collections-are-not-dumped-correctly">PyYAML documentation</a>, <code>default_flow_style=False</code> should be passed to <code>yaml.safe_dump</code> to achieve that.</p>
<p>After digging into the source code of the latest PyYaml (6.0), I find it is not needed anymore.
You should remove this keyword argument to keep the code cleaner and less confusing.</p>
<p><img loading="lazy" src="/blog/python-yaml-tips/images/yaml-dump-all.png" type="" alt=""  /></p>
<h2 id="libraries">Libraries</h2>
<h3 id="oyaml">oyaml</h3>
<p>Link: <a href="https://github.com/wimglenn/oyaml">https://github.com/wimglenn/oyaml</a></p>
<p>As mentioned above, oyaml is a drop-in replacement for PyYAML which preserves dict ordering.</p>
<p>I suggest using oyaml if you already use PyYAML in your code.</p>
<p>It&rsquo;s worth mentioning that oyaml is a single-file library with only <a href="https://github.com/wimglenn/oyaml/blob/d0195070d26bd982f1e4e604bded5510dd035cd7/oyaml.py">53 lines of code</a>.
This makes it very flexible to use, you can just copy the code to your library and customize it according to your need.</p>
<h3 id="strictyaml">strictyaml</h3>
<p>Link: <a href="https://github.com/crdoconnor/strictyaml">https://github.com/crdoconnor/strictyaml</a></p>
<p>Some people say YAML is too complex and flexible to be a good configuration language,
but I think this is not the problem of YAML, but the problem of how we use it.
If we restrict our usage to only a subset of its features, it will be as good as it should be.</p>
<p>This is where StrictYAML came up. It is a type-safe YAML parser that parses and validates a <a href="https://hitchdev.com/strictyaml/features-removed">restricted subset</a> of the YAML specification.</p>
<p>I suggest using StrictYAML if you have strong security concerns for your application.</p>
<p>There are tons of great articles on the <a href="https://hitchdev.com/strictyaml/">documentation site</a> of strictyaml, definitely worth having a look at if you have thought about YAML and other configuration languages.</p>
<h3 id="ruamel-yaml">ruamel. yaml</h3>
<p>Link: <a href="https://yaml.readthedocs.io/en/latest/overview.html">https://yaml.readthedocs.io/en/latest/overview.html</a></p>
<p>ruamel.yaml is a fork of PyYAML, it was released in 2009 and continuously maintained in the past decade.</p>
<p>The differences with PyYAML are listed <a href="https://yaml.readthedocs.io/en/latest/pyyaml.html#yaml-1-2-support">here</a>. Generally, ruamel.yaml focuses on <a href="https://yaml.org/spec/1.2.2/">YAML 1.2</a>  with some opinionated enhancements for the syntax.</p>
<p>What interests me most is the ability to round-trip in the loading/dumping process. It works like black magic. Here&rsquo;s the explanation from ruamel.yaml documentation:</p>
<blockquote>
<p>A round-trip is a YAML load-modify-save sequence and ruamel.yaml tries to preserve, among others:</p>
<ul>
<li>comments</li>
<li>block style and key ordering are kept, so you can diff the round-tripped source</li>
<li>flow style sequences ( ‘a: b, c, d’) (based on request and test by Anthony Sottile)</li>
<li>anchor names that are hand-crafted (i.e. not of the form<code>idNNN</code>)</li>
<li>merges in dictionaries are preserved</li>
</ul>
</blockquote>
<p>I suggest using ruamel.yaml if you have the requirement to preserve the original content as much as possible.</p>
<blockquote>
<p>One thing I notice is that ruamel.yaml&rsquo;s <code>safe_load</code> method (<code>YAML(typ='safe').load</code>) cannot parse flow style collection (<code>a: {&quot;foo&quot;: &quot;bar&quot;}</code>), this is a undocumented difference with PyYAML.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>YAML has its good and bad. It&rsquo;s easy to read, the learning curve is mild at the beginning,
but the specification is complex, which not only causes chaos in practice, but also makes implementations in different languages inconsistent with each other in many trivial aspects.</p>
<p>Despite these quirks, YAML is still the best configuration language for me, and as long as we can use it properly, problems will be avoided and the experience will be much better.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>See <a href="https://docs.python.org/3/whatsnew/3.7.html#:~:text=the%20insertion%2Dorder%20preservation%20nature%20of%20dict%20objects%20has%20been%20declared%20to%20be%20an%20official%20part%20of%20the%20Python%20language%20spec.">What’s New In Python 3.7</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>重新开始使用 RSS 阅读器</title><link>https://reorx.com/blog/reinitiate-rss-reader/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/reinitiate-rss-reader/</guid><description>简单明确的尝试，带来意想不到的收获</description><content:encoded><![CDATA[<h2 id="不算成功的开端">不算成功的开端</h2>
<p>我曾经是一个糟糕的 RSS 用户。</p>
<p>早在 Google Reader 流行的时期，我就热衷于将我感兴趣的资讯网站和博客订阅到 Google Reader 中 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，期盼着能从这些信息中获得有价值的东西，却总是因为懒或者忘了而不能及时查看。随着未读数的增多，焦虑感越来越强烈，最后索性不再打开阅读器，安慰自己以后总会去看的，只要订阅了就行，沉浸在虚假的满足感中。</p>
<p>我就像一个喜欢屯书的人，在 RSS 阅读器这个书架上摆满了放上去就再也没动过的书<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>后来我认识到，自己得了信息资源的囤积病，经过长时间的反思后，我下决心清理 RSS 订阅源。</p>
<p>我删除了所有资讯类网站，只留下个人博客；去掉长期未更新的，并重新审视每个博客是否是我真正想要去阅读的。最终留下大约 30 多个 RSS 源，每周的更新量被控制在 10-20 之间。自此以后，我才真正做到阅读每篇更新，也没有再因为未读数量而焦虑了。</p>
<p>再之后，我看到许多人分享自己的 RSS 使用经验<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，将 RSS 作为获取信息的效率工具，聚合和筛选资讯，甚至成为 all-in-one 的信息输入渠道。这些文章偶尔会让我蠢蠢欲动，但因担心摄入压力过大而重蹈覆辙，我总是很快熄灭了尝试的想法。</p>
<p>就这样，我从一个糟糕的 RSS 用户，变成了一个克制但低效的用户，不再每天使用，只在有提醒时打开看看博客的更新。生活继续。</p>
<h2 id="重新发现-rss">重新发现 RSS</h2>
<p>最近我开始经常逛 V2EX 。我最早的活跃时期是 2010~2013，后来因为沉迷工作，和陌生人的交流欲降低，兴趣转移到 Twitter。今年自由工作后，思维又活跃起来，回过头来发现经过 10 年时间，V2EX 依然是国内最好的开发者社区。</p>
<p>V2EX 有着丰富的 RSS 支持，在 <a href="https://v2ex.com/notifications">V2EX  ›  提醒系统</a> 页面可以获得提醒的 RSS 订阅源。为了及时收到消息通知，我开始琢磨如何利用这一功能，于是整理了下需求：</p>
<ul>
<li>直接订阅 RSS，不需要借助第三方服务</li>
<li>支持 macOS 和 iOS，同步未读条目</li>
<li>简洁清爽的界面</li>
</ul>
<p>很快，我锁定了完美满足这三点的 <a href="https://github.com/Ranchero-Software/NetNewsWire">NetNewsWire</a></p>
<p><img loading="lazy" src="/blog/reinitiate-rss-reader/images/netnewswire-1.png" type="" alt=""  /></p>
<p>NetNewsWire 发布于 20 年前，是 macOS 上历史最悠久的 RSS 阅读器。我虽然很早就知道它，却一直没有尝试，使用的是更受追捧的 Reeder，但 Reeder 最近的几次付费更新有些令人失望，没有什么有趣的变更，我也厌倦了它那软绵绵的 UI 风格。</p>
<p>NetNewsWire 让我眼前一亮，它使用 macOS 原生的 UI 组件，适应起来没有任何障碍。打开就算经典的三栏布局，没有多余的选项，让我感觉真正在使用一个信息组织工具，而非另一个漂亮的玩具。</p>
<p>Minimal and no distraction, 这是我对 NetNewsWire 的整体印象。我很快就爱上了它，逐渐把我其他几个正在摄取的信息源也添加了上去。</p>
<p>现在我的 RSS 订阅结构是这样的：</p>
<ul>
<li>
<p>V2EX</p>
<ul>
<li>
<p>节点</p>
<p>我只对一些特定的节点有逐条浏览的兴趣，V2EX 每个节点都可以输出 RSS，只需要将 <code>https://v2ex.com/feed/{node}.xml</code> 的 <code>{node}</code> 替换为节点的英文名即可。</p>
<ul>
<li><a href="https://v2ex.com/feed/create.xml">分享创造</a></li>
<li><a href="https://v2ex.com/feed/share.xml">分享发现</a></li>
<li><a href="https://v2ex.com/feed/programmer.xml">程序员</a></li>
</ul>
</li>
<li>
<p><a href="https://rsshub.app/v2ex/topics/hot">Top Topics</a></p>
<p>V2EX 本身没有最热话题的 RSS，幸运的是，RSSHub 提供了一个公开的源。</p>
</li>
</ul>
</li>
<li>
<p><a href="https://rsshub.app/telegram/channel/hacker_news_feed">Hacker News</a></p>
<p>Hackers News 的信息量太大，不适合直接订阅，好在 <a href="https://t.me/hacker_news_feed">hacker_news_feed</a> 这个 Telegram 频道对内容进行了筛选，只推送分数大于 100 的条目。同样要感谢 RSSHub，用它将 Telegram 频道转换成了 RSS feed。</p>
</li>
<li>
<p>Obsidian</p>
<p>作为 Obsidian 重度使用者和插件维护者，我非常关注社区的动向。Obsidian 社区信息主要来自于<a href="https://forum.obsidian.md/">官方 Discourse 论坛</a>和 <a href="https://www.reddit.com/r/ObsidianMD/">subreddit</a>。两者都是通过在 URL 后面加上 <code>.rss</code> 即可获得订阅源（如 <a href="https://forum.obsidian.md/c/share-showcase/9.rss">Showcase</a> 和 <a href="https://www.reddit.com/r/ObsidianMD.rss">ObsidianMD</a>）</p>
</li>
<li>
<p>提醒</p>
<ul>
<li>V2EX</li>
<li><a href="https://www.reddit.com/prefs/feeds/">Reddit Unread</a></li>
</ul>
</li>
</ul>
<p>经过一段时间的使用，我开心地发现，自己已经能每日有效摄入上百条信息而没有焦虑。我通常是在碎片时间打开手机观看，比如早上蹲马桶时、运动后和睡前。当遇到有趣的信息时，就点击 Star 收藏，如果特别需要关注或后续调研，就在 TickTick 添加一个对应的 TODO 项。要是忙起来积攒了许多未读，我就快速划过快速 Star，然后一次性 Mark All as Read。</p>
<h2 id="进一步优化">进一步优化</h2>
<p>V2EX 的程序员节点中经常出现 Java 相关的话题，但我的技能体系与 Java 无关，因此我想过滤掉这些对我而言无用的信息。</p>
<p>NetNewsWire 有一个相关的 <a href="https://github.com/Ranchero-Software/NetNewsWire/issues/1864">issue</a>，却并没有实现。Inoreader 和 Tiny Tiny RSS 等聚合器虽然支持，但我希望保持目前直接订阅原始 RSS 源的工作流，不想引入另一个工具增加复杂度。怎么办呢？</p>
<p>我决定自己开发一个轻量的 serverless 服务: <a href="https://github.com/reorx/rss-filter">rss-filter</a>。（现在还没有完成，所以读者朋友们可以不急着 star 鼓励。）</p>
<p>rss-filter 的大致设计如下：</p>
<ul>
<li>部署在 serverless 平台</li>
<li>通过 url 参数使用
<ul>
<li><code>rss</code>: rss url</li>
<li><code>exclude_text[]</code>: regex to exclude items from text (title, description, content)</li>
<li><code>exclude_text[]</code>: regex to include items from text
<ul>
<li>if both include and exclude are provided, apply include before exclude.</li>
</ul>
</li>
<li><code>cache_seconds</code>: seconds to cache the result</li>
<li><code>debug</code>: if true, return a json to debug</li>
<li><code>token</code>: prevent abuse by anonymous users</li>
<li><code>full_content</code>: fetch full content of each item</li>
</ul>
</li>
</ul>
<p>我设想  rss-filter 完成后，只需要简单的设定参数即可创造一个过滤后的 RSS 源。比如我想要从程序员节点过滤掉 Java 相关的条目，那么新的 RSS 源应为:</p>
<pre tabindex="0"><code>https://rss-filter.reorx.com/filter?rss=https%3A%2F%2Fv2ex.com%2Ffeed%2Fprogrammer.xml&amp;exclude_text=java%7Cspring+%3Fboot%7Clog4j&amp;cache_seconds=600
</code></pre><p>其中 <code>exclude_text</code> 为 <code>java|spring ?boot|log4j</code>，用正则匹配多种不同的关键词。</p>
<h2 id="一些思考">一些思考</h2>
<p>RSS 的用法因人而异，这篇文章主要目的是分享我个人的探索过程，希望带给读者一些借鉴。选择适合自己的，不要盲目追求别人看起来「高效」「强大」的工作流。</p>
<p>前几天 <a href="https://taoshu.in/">涛叔</a> 向我推荐了他的 <a href="https://taoshu.in/webfeed/web-feed.html">WebFeed</a> 插件 (for Firefox)，它把浏览器变成 RSS 阅读器，并能自动发现网站的 RSS 源。</p>
<p><img loading="lazy" src="/blog/reinitiate-rss-reader/images/webfeed.png" type="" alt=""  /></p>
<p>我很喜欢它的 Web 与 RSS 一体的使用体验，这让我开始思考一个问题，为何近些年来 RSS 逐渐式微，主流浏览器厂商没有做任何相关的支持<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，只有少部分开源爱好者还在坚持使用并为 RSS 社区做出贡献。</p>
<p>我能想到的答案之一是，商业公司在控制和引导互联网生态，将公开流量变成自己的私域流量。而主流浏览器背后正好也都是商业公司。想象一下，如果所有内容都来自于独立博客的 RSS，作者可以直达受众，那内容分发市场的商业价值就没他们什么事了，更不用说将用户绑定在自己的平台上。</p>
<p>另一个原因可能是内容农场的肆虐，独立创作者很难靠自己将原创内容推广，内容农场却通过 SEO 技术将自己洗稿后的文章顶在了搜索结果的前面。关于这个问题，少数派有一篇文章值得一读： <a href="https://sspai.com/post/71637">少数派思考 007：关于 RSS</a>。</p>
<p>这是一场没有硝烟的战争，商业巨头们就像<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%86%E5%A4%A7%E5%8F%91%E7%8E%B0">地理大发现</a>时期的西方文明，在开放互联网的蒙昧之地大肆开拓殖民地。国外近些年来还有 Medium、Newsletter 等多种形式的内容分发模式百花齐放，国内已经被头条、微信、微博、百度完成瓜分和镇压，沦为没有生机的焦土。</p>
<p>但即使在这样的环境下，我还是希望能成为一个纯粹的内容创作者，为别人带来启发和帮助，为自己实现学习和思考的价值。</p>
<p>欢迎你来订阅我的博客:</p>
<p class="standout">
  <a href="https://reorx.com/feed.xml">https://reorx.com/feed.xml</a>
</p>

<p>最后推荐一篇文章 <a href="https://kevincox.ca/2022/05/06/rss-feed-best-practices/">RSS Feed Best Practises</a>， 如果你也是一名维护自己博客的 webmaster，可以了解下如何优化自己网站输出的 RSS。</p>
<p>比如加上 <code>&lt;link&gt;</code> tag 使 RSS URL 可以被主流工具自动发现:</p>
<pre tabindex="0"><code>&lt;link rel=alternate title=&quot;Blog Posts&quot; type=application/atom+xml href=&quot;/feed.atom&quot;&gt;
</code></pre><p>比如最好在 RSS 中附带全文：</p>
<blockquote>
<p>It is generally recommended to provide the full content of your posts in the feed. This is what most readers prefer. Atom has both <code>&lt;summary&gt;</code> element for readers that prefer it. For RSS and the Atom <code>&lt;content&gt;</code> element the full article should be included.</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>当时使用了一款 Chrome 插件，会自动检测当前网页可用的 RSS 源，如果有的话，会在地址栏里显示 RSS 图标，点击图标就能看见 Google Reader 中的目录分类，勾选即是将 RSS 订阅到指定分类中。我非常喜欢这个插件，可惜后来 Chrome 去掉了地址栏图标的 API，再也无法实现相似的功能了。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>亦像一个喜欢在 Steam 屯游戏的人，买了上千个游戏，但每天玩的还是 Dota 2, CS GO, GTA 5&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Chrome 背后的 Google，在手机 app 上实现了自己的 <a href="https://support.google.com/websearch/answer/2819496?hl=en&amp;co=GENIE.Platform%3DAndroid">Discover Feed</a> ; Edge 有一个叫 <a href="https://support.microsoft.com/en-us/microsoft-edge/organize-your-ideas-with-collections-in-microsoft-edge-60fd7bba-6cfd-00b9-3787-b197231b507e">Collections</a> 的功能，可以 “Follow” 一个网站的更新。那为什么我要说没有支持呢？因为这些都不是真正的 RSS，它们背后的技术可能还是 RSS ，但在产品上都刻意忽略 RSS、强调自己的名词。他们各造轮子实现自己的私有功能，仍是为了将用户关在自己的信息茧房中。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>我的 Vim 自动补全配置变迁史</title><link>https://reorx.com/blog/the-history-of-my-vim-completion-config/</link><pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/the-history-of-my-vim-completion-config/</guid><description>记录了从 2017 年至今，我的 Vim 自动补全配置的每次变更，从中窥见 Vim 生态发展的一角，也纪念这些曾经给我带来过便利，最终在技术发展中被轮替的插件</description><content:encoded><![CDATA[<p>Vim 是我系统学习的第一个终端编辑器，从学生时代至今，我几乎每天都会使用到它（长时间写前端代码时除外）。</p>
<p>自动补全（auto completion）大概是每个 Vim 用户在掌握了基本用法后，第一个想要进阶配置的功能。这篇文章记录了从 2017 年至今，我的 Vim 自动补全配置的每次变更，从中窥见 Vim 生态发展的一角，也纪念这些曾经给我带来过便利，最终在技术发展中被轮替的插件。</p>
<h2 id="before-2017">Before 2017</h2>
<p>2017 年我从 Vim 切换到 <a href="https://neovim.io/">Neovim</a>（下文简称 nvim），除了增加 nvim 特殊的 <code>init.vim</code>，基本沿用了以往的配置和插件。</p>
<p>彼时我使用的语言以 Python 为主，自动补全插件为 <a href="https://github.com/davidhalter/jedi-vim">jedi-vim</a>。</p>
<p>我对 jedi-vim 的了解最早可以追溯到 2012 年，那时还没有 LSP 的概念。开发者们针对自己的需求，编写如语法增强、文档查看、自动补全等各类插件，非常零散。jedi-vim 对这些插件的功能进行了重构和集成，提供了开箱即用的统一解决方案，一经推出便广受好评，成为使用 Vim 进行 Python 开发的标配。在后来的十年里，它的初心始终不变，得到持续的维护并沿用至今。</p>
<p>jedi-vim 的流行和长寿或许可以说明一个观点，即易用和功能全面才是软件流行的第一因素，无论它的实现有多么不优雅、效率有多么低，只要是能用的、可接受的就行，用户在使用体验上得到满足后，对于小问题的容忍度是相当高的。</p>
<h2 id="2017">2017</h2>
<p>还是 2017 年，在切换到 nvim 后不久，我发现了 <a href="https://github.com/Shougo/deoplete.nvim">deoplete</a> 插件，经过一番尝试将 jedi-vim 替换成了 deoplete + deoplete-jedi。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/0760ba6f7d11526e38e15b36a0d1db8709834825">0760ba6f7d11526e38e15b36a0d1db8709834825</a></p>
<blockquote>
<p><strong>use deoplete, remove jedi-vim</strong></p>
<p><em>committed on Jun 28, 2017</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;davidhalter/jedi-vim&#39;, { &#39;for&#39;: &#39;python&#39; }
</span><span class="gd"></span><span class="gi">+Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gi">+Plug &#39;zchee/deoplete-jedi&#39;, { &#39;for&#39;: &#39;python&#39; }
</span></code></pre></div><p>deoplete 的目标是提供一个通用的异步自动补全框架，这在设计理念上是一个巨大的进步。jedi-vim 虽然开箱即用，但却是一堆粘合在一起的 spaghetti code，不仅随着项目功能的增加变得越发庞大和迟缓（这是我想要离开 jedi-vim 的主要原因，文件一大各种操作都变得肉眼可见的慢），代码的可读性也非常糟糕，难以维护和参与。而 deoplete 本身并不提供针对任何语言的分析能力，只专注于与 nvim 的整合和 completion source 的调度，并且利用 nvim 的异步功能（后来 vim 8 也推出了自己的 async 接口），大大提升了补全的流畅度。</p>
<p>但 deoplete 也有着自身的局限性。首先配置变得复杂且麻烦，用户得理解其架构和设计，学会如何通过 deoplete 对接编程语言的 completion source。为了使检查结果的提示贴合自己的使用习惯，还要再去学习 completion source 的配置，每个语言的实现不同，配置也不一样。</p>
<blockquote>
<p>当时我却没有料到，配置复杂的问题在 LSP 时代不仅没能得到解决，反而变本加厉，直到本文完成时也依旧是使用者的巨大痛点</p>
</blockquote>
<p>deoplete 的第二个问题是，它只专注在 completion，缺少对于 go to definition 和显示 function siguature 等功能的支持，这对于从 jedi-vim 的 all-in-one 体验切换过来的我，显然是个巨大的落差。好在我找到了其他插件来解决这些问题。</p>
<p>对于 “go to definition”，通过装回 jedi-vim 并打开无补全模式可以解决。这样既可以使用 jedi-vim 提供的 go to definition 等辅助功能，也不会与 deoplete 的补全产生冲突。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">Plug</span> <span class="s1">&#39;davidhalter/jedi-vim&#39;</span><span class="p">,</span> { <span class="s1">&#39;for&#39;</span>: <span class="s1">&#39;python&#39;</span> }<span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; jedi (only for go to definition)</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">jedi</span>#<span class="nx">completions_enabled</span> <span class="p">=</span> <span class="m">0</span><span class="err">
</span></code></pre></div><p>对于 “function signature”，我找到了 deoplete 作者的另一个插件 <a href="https://github.com/Shougo/echodoc.vim">echodoc</a> 来实现。它将函数的签名信息显示在 cmd 区域，规避了 deoplete 占用 <code>completeopt</code> 导致编辑界面无法显示补全菜单以外的其他信息的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="nx">Plug</span> <span class="s1">&#39;Shougo/echodoc.vim&#39;</span><span class="err">
</span><span class="err"></span><span class="c">
</span><span class="c">&#34; echodoc</span><span class="err">
</span><span class="err"></span><span class="nx">set</span> <span class="nx">noshowmode</span><span class="err">
</span><span class="err"></span><span class="k">let</span> <span class="nx">g</span>:<span class="nx">echodoc</span>#<span class="nx">enable_at_startup</span><span class="p">=</span><span class="m">1</span><span class="err">
</span></code></pre></div><h2 id="2018">2018</h2>
<p>2018 年是里程碑式的一年，<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> 的生态逐渐成熟，新的补全工具涌现。我对 LSP 感到相当兴奋和好奇，迫不及待地从 deoplete 更换到了对 LSP 有更好支持的 <a href="https://github.com/ncm2/ncm2">ncm2</a>。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/7a1442c2334673ac17162c101663e220ef43a3c8">7a1442c2334673ac17162c101663e220ef43a3c8</a></p>
<blockquote>
<p><strong>nvim: update completion plugins (a lot!)</strong></p>
<ul>
<li>move and reorg completion plugins definitions and configurations</li>
<li>use LSP completion instead of deoplete</li>
<li>remove eslint from ale_linters</li>
<li>enable virtualenv display for airline</li>
<li>still working on passing settings to pyls through LanguageClient-neovim</li>
</ul>
<p><em>committed on Dec 7, 2018</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gd">-Plug &#39;zchee/deoplete-jedi&#39;, { &#39;for&#39;: &#39;python&#39; }
</span><span class="gd"></span><span class="gi">+Plug &#39;ervandew/supertab&#39;
</span><span class="gi">+Plug &#39;ncm2/ncm2&#39;
</span><span class="gi">+Plug &#39;roxma/nvim-yarp&#39;
</span><span class="gi">+Plug &#39;autozimu/LanguageClient-neovim&#39;, { &#39;branch&#39;: &#39;next&#39;, &#39;do&#39;: &#39;bash install.sh&#39;, }
</span></code></pre></div><p>从设计理念上看，ncm2 与 deoplete 并无差别，都是通用的异步自动补全框架，唯有与<a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a>器的集成方式不同，deoplete 是自己的私有协议，ncm2 则拥抱了更加通用的业界标准 LSP。</p>
<p>我为 deoplete 的作者感到惋惜，他在 LSP 还不够成熟的时期，自己设计了与静态分析器的集成协议，构建了一个完整的补全插件生态<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。还写了很多小巧实用的插件，代码也非常优美，让人感到赏心悦目。但因为 LSP 的发展和新一代更加 LSP native 的补全插件的涌现，它已不再是当下的第一选择，势必因为历史包袱而逐渐被淘汰。</p>
<p>说回 ncm2，其实它也有许多瑕疵，印象中配置过程比 deoplete 还要痛苦，但当时已经是让 nvim 用上 LSP 的最好插件了。之后我对 JetBrains 和 VSCode 的使用频率变高，疏于对 nvim 插件的持续跟进，ncm2 于是一直服役到 2021 年。</p>
<p>ncm2 出现后没过多久，<a href="https://github.com/neoclide/coc.nvim">coc</a> 也诞生了，在 2019 年成为最受人关注的 vim 补全插件，国内也看到很多文章（似乎作者就是国内开发者）。由于长期受 Webpack 和 Nodejs 技术栈的折磨，当我了解到 coc 是 Nodejs 实现的，就放弃了尝试的念头 <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。一想到 jedi-vim 的缓慢，我实在没办法对同样大而全的 coc 抱有足够的信心<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<p>P.S. 从当年的笔记中找到了所参考的项目和文章：</p>
<ul>
<li><a href="https://www.reddit.com/r/neovim/comments/8ejfg0/state_of_lsp_servers/">https://www.reddit.com/r/neovim/comments/8ejfg0/state_of_lsp_servers/</a></li>
<li><a href="https://github.com/autozimu/LanguageClient-neovim">https://github.com/autozimu/LanguageClient-neovim</a></li>
<li><a href="https://github.com/prabirshrestha/vim-lsp">https://github.com/prabirshrestha/vim-lsp</a></li>
<li><a href="https://github.com/ncm2/ncm2">https://github.com/ncm2/ncm2</a></li>
<li><a href="https://github.com/palantir/python-language-server">https://github.com/palantir/python-language-server</a></li>
</ul>
<h2 id="2021">2021</h2>
<p>2021 年的某一天，因为 ncm2 长期存在的一个小问题（现在已经忘了），我一气之下再次打开了 deoplete 的项目页面，惊喜地发现它已经完善了对 LSP 的支持，于是立刻就开始迁移，换回了我更欣赏且代码品质更胜一筹的 deoplete。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/cd044fcda603ad5b9ee16bd4d7d7873c9ade9a31">cd044fcda603ad5b9ee16bd4d7d7873c9ade9a31</a></p>
<blockquote>
<p><strong>nvim: rework on languageserver &amp; python completion</strong></p>
<p><em>committed on Mar 26, 2021</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;ervandew/supertab&#39;
</span><span class="gd">-Plug &#39;ncm2/ncm2&#39;
</span><span class="gd">-Plug &#39;roxma/nvim-yarp&#39;
</span><span class="gd">-Plug &#39;autozimu/LanguageClient-neovim&#39;, { &#39;branch&#39;: &#39;next&#39;, &#39;do&#39;: &#39;bash install.sh&#39;,
</span><span class="gd"></span><span class="gi">+Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gi">+Plug &#39;prabirshrestha/vim-lsp&#39;
</span><span class="gi">+Plug &#39;mattn/vim-lsp-settings&#39;
</span><span class="gi">+Plug &#39;lighttiger2505/deoplete-vim-lsp&#39;
</span></code></pre></div><p>这次变更除了换回 deoplete ，还去掉了陪伴多年的 supertab，在抄了一段看不懂的配置后，实现了我更为习惯的 tab 键触发补全的方式。</p>
<h2 id="2022">2022</h2>
<p>在咖啡馆结束了一天的主要工作后，看着好友 <a href="https://github.com/xwjdsh">@iwendellsun</a> 流畅的 vim 操作，我问起了他的 nvim 自动补全配置，果然有许多我从未听过的东西。于是趁此机会赶紧向他请教，在他的指导下完成了 2022 年的配置升级。</p>
<p>Commit: <a href="https://github.com/reorx/dotfiles/commit/3de43d030ca40b498911c6752a7396af38202fe6">3de43d030ca40b498911c6752a7396af38202fe6</a></p>
<blockquote>
<p><strong>nvim: use nvim-cmp for completion</strong></p>
<p><em>committed on May 08, 2022</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
</span><span class="gd">-Plug &#39;prabirshrestha/vim-lsp&#39;
</span><span class="gd">-Plug &#39;mattn/vim-lsp-settings&#39;
</span><span class="gd">-Plug &#39;lighttiger2505/deoplete-vim-lsp&#39;
</span><span class="gd">-Plug &#39;w0rp/ale&#39;
</span><span class="gd">-Plug &#39;rhysd/vim-lsp-ale&#39;
</span><span class="gd"></span><span class="gi">+Plug &#39;williamboman/nvim-lsp-installer&#39;
</span><span class="gi">+Plug &#39;neovim/nvim-lspconfig&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-nvim-lsp&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-buffer&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-path&#39;
</span><span class="gi">+Plug &#39;hrsh7th/cmp-cmdline&#39;
</span><span class="gi">+Plug &#39;hrsh7th/nvim-cmp&#39;
</span></code></pre></div><p>这次变更分以下几个方面：</p>
<ol>
<li>补全框架从 deoplete 变为 <a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a>，我还没细看，不过据说它就是现在的 meta &amp; state of the art.</li>
<li>LSP 集成从 vim-lsp 换成了 nvim-lspconfig。迟来的官方出品。</li>
<li>去掉了 ale 和 vim-lsp-ale。nvim-cmp 可以将 LSP client 返回的错误提示直接在行内显示，不需要再依赖 ALE 这个 linter 框架了。</li>
<li>Last but not least, 这些插件的配置语法几乎都是用 Lua 写的，这让用了 10 年 Vimscript 的我感到极度陌生和恐慌。</li>
</ol>
<p>相比之前的变更，这是唯一一次生搬硬套而非全部理解的，我想快速上车，免得被社区发展抛在了后面，现在实在没有太多精力可以悠闲地慢慢尝试。虽然有人指导免去了初次上手的痛苦，但可以预见的是，想要让这套插件和我的编程习惯完美契合，还有许多坑等着我去折腾呢。</p>
<p><strong>参考链接</strong>:</p>
<ul>
<li><a href="https://github.com/hrsh7th/nvim-cmp#setup">Setup | nvim-cmp</a>
<ul>
<li><a href="https://github.com/hrsh7th/nvim-cmp/wiki/List-of-sources">List of sources · hrsh7th/nvim-cmp Wiki</a></li>
<li><a href="https://github.com/hrsh7th/nvim-cmp/wiki/Example-mappings">Example mappings · hrsh7th/nvim-cmp Wiki</a></li>
</ul>
</li>
<li><a href="https://github.com/williamboman/nvim-lsp-installer#default-configuration">Default configuration | nvim-lsp-installer</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md">Server Configurations | nvim-lspconfig</a>
<ul>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#pylsp">pylsp</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#pyright">pyright</a></li>
<li><a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#gopls">gopls</a></li>
</ul>
</li>
<li><a href="https://github.com/ray-x/lsp_signature.nvim">ray-x/lsp_signature.nvim: LSP signature hint as you type</a></li>
</ul>
<p><strong>参考配置</strong>:</p>
<ul>
<li><a href="https://github.com/xwjdsh/dotfiles/blob/master/nvim1/lua/plugins.lua">https://github.com/xwjdsh/dotfiles/blob/master/nvim1/lua/plugins.lua</a></li>
<li><a href="https://github.com/Avimitin/nvim/blob/master/lua/plugins/load.lua">https://github.com/Avimitin/nvim/blob/master/lua/plugins/load.lua</a></li>
</ul>
<h2 id="结语">结语</h2>
<p>Vim 的 LSP 插件生态还有许多有待优化的空间，开发者们对生产力的追求是永无止境的，下一个 5 年编辑器的体验会有着怎样激动人心的变化，我对此充满期待。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://github.com/Shougo/deoplete.nvim/wiki/Completion-Sources">https://github.com/Shougo/deoplete.nvim/wiki/Completion-Sources</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>其实 Nodejs 在服务端的性能不差，但 Webpack 和 Electron 给我造成的印象已经根深蒂固，使我看到 Nodejs 就会立刻联想到 slow and bloated.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>2022-05-09: 本文发布后，许多朋友向我推荐了 coc，并告知它的速度很快，修正了我在没有使用过的情况下产生的偏见认知。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>使用 Sonarr 搭建自动化追番系统</title><link>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</link><pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/track-and-download-shows-automatically-with-sonarr/</guid><description>A complete guide to deploy and configure Sonarr + Jackett + FlareSolverr + qBittorrent to track and download anime shows automatically.</description><content:encoded><![CDATA[<p>作为一个懒人，我很少折腾 self-hosted 服务，对于追番这种娱乐化的需求，更是有什么用什么将就度日。所以许多年来一直是用 Bilibili 观看新番，中途也尝试过 ebb.io 这类小众服务，但最后都因为连接不畅或数据滞后等原因放弃了。</p>
<p>去年为了实现 Home Assistant 家电自动化 (<a href="https://twitter.com/novoreorx/status/1450334462177263618">tweet</a>)，我购买了一台 QNAP NAS，使家里有了 24 小时常驻的 Linux server 和 Docker host。年初由于 Bilibili 迟迟不上架《鬼滅之刃遊郭篇》，我又在 NAS 上安装了 Plex，将从 <a href="https://share.dmhy.org/">dmhy</a> 手动下载的影片串流到电视上观看。最近又逢 4 月新番播出，想到家里的基础设施逐渐完备，便动起了搭建自动追番系统的心思。以下便是对这次尝试的记录和总结，希望能帮助有同样需求的人解决问题、节省时间。</p>
<h2 id="使用-qnap-download-station">使用 QNAP Download Station</h2>
<p>本着尽量不增加新的系统来解决问题的思想，我首先研究了 QNAP 的下载器 Download Station，发现它自带 RSS 订阅功能，在进行一些手动配置后，即可完成自动追番和下载。</p>
<p>如果对这一章节不感兴趣，你也可以直接跳到 <a href="#%E4%BD%BF%E7%94%A8-sonarr-%E5%92%8C%E5%AE%83%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC">使用 Sonarr 和它的朋友们</a>。</p>
<h3 id="1-找到番剧的-rss-url">1. 找到番剧的 RSS URL</h3>
<p><a href="https://bangumi.moe/">Bangume Moe</a> 是我经常使用的资源站，它提供基于 tag 的 RSS 搜索功能，可以非常精确地定位到番剧在特定字幕组、语言、分辨率瞎的视频发布链接。</p>
<ul>
<li>首先在右上角的搜索框中输入想看的番剧名称，这里我使用「夏日重现」作为例子，可以看到下方自动匹配了 <code>Summertime Render</code> 这个 tag。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-2.png" type="" alt=""  /></li>
<li>点击这个 tag，搜索结果中会出现许多不同字幕组发布的资源，我们选择其中一个字幕组「喵萌奶茶屋」的资源，在 Torrent Details 中，可以看到其标注的 tags，有 <code>喵萌奶茶屋</code>, <code>720p</code>, <code>chs-jpn</code> 等，妥善使用这些 tags 能够帮助我们缩小搜索结果范围
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-1.png" type="" alt=""  /></li>
<li>将 <code>喵萌奶茶屋</code>, <code>chs-jpn</code> 添加到 Selected tags 中，现在我们一共有 3 个 tags，搜索结果缩短到了 2 条，已经非常清晰了，点击右上角的 RSS 图标即可得到用于订阅的链接。（美中不足的是，喵萌奶茶屋将 1080p 的资源错标为了 <code>720p</code>，不过这点我们可以在后面的下载管理器中解决）
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime.png" type="" alt=""  /></li>
</ul>
<h3 id="2-将-rss-url-添加到下载器">2. 将 RSS URL 添加到下载器</h3>
<p>RSS 订阅是许多下载管理器的通用功能，如 Synology、qBittorrent 也都具有，使用方式与 Download Station 大同小异。</p>
<ul>
<li>打开 RSS Download Manager，将上一步得到的订阅链接复制到 Feed URL 中。Label 填写番剧名称，两个 Location 根据自己 NAS 的目录结构选择。点击 Apply 添加。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter.png" type="" alt=""  /></li>
<li>添加完成后，打开 Filter Settings，它可以用于进一步过滤 RSS 返回的结果，避免下载不需要的资源。之前在进行资源搜索时，我们没能通过 tag 过滤掉 720p 的结果，在 Filter Settings 中，我们选择 1080p，这样 720p 就被忽略了。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-rss-anime-filter-1.png" type="" alt=""  /></li>
<li>回到主界面，刷新添加的 RSS，可以看到两条结果中只有 1080p 被加入到下载列表。Status 为 Finished 代表下载完成，New 代表新添加到 RSS，但不在下载列表中。</li>
</ul>
<h3 id="小结">小结</h3>
<p><strong>Pros</strong></p>
<ul>
<li>无需配置和增加新系统</li>
<li>操作过程透明清晰，可控性强</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>步骤较为繁琐，需要在多个服务之间切换</li>
<li>下载的文件因为不符合 Plex 的格式需求，需要手动重命名才能在 Plex 上观看。但如果你使用 DLNA 这类基于文件系统定位视频的方式，倒是可以忽略这个缺点。</li>
</ul>
<h2 id="使用-sonarr-和它的朋友们">使用 Sonarr 和它的朋友们</h2>
<p>Download Station RSS 虽然解决了基本的温饱问题，但与真正的自动化之间显然还有很大差距，如果你想充分利用 NAS 的功能，在家庭多媒体设施上更进一步，请继续向下阅读，走进 Sonarr 和它的朋友们的世界。</p>
<h3 id="sonarr">Sonarr</h3>
<blockquote>
<p>Sonarr is a PVR (Personal Video Recorder) for Usenet and BitTorrent users. It can monitor multiple RSS feeds for new episodes of your favorite shows and will grab, sort and rename them.</p>
</blockquote>
<p><a href="https://wiki.servarr.com/sonarr">Sonarr</a> 是一个 PVR 系统，它可以监控多种信息源的剧集发布信息，对剧集进行自动下载、刮削和重命名。</p>
<p>Sonarr 是 Sick Beard 的继任者，Sick Beard 基于 Python 开发，曾经是最著名的 PVR 系统，但后来逐渐式微，后续虽然有 Sick Gear 等 fork，但最终都没能满足人们日益增长的看片需求，最后被一群 C# 爱好者们开发出 Sonarr 给替代了。经过多年发展，Sonarr 的软件质量趋于成熟和稳定，成为构架自动化的家庭多媒体中心不可缺少的组件。</p>
<p>Sonarr 一开始就以多系统低耦合的方式进行设计，这大大降低了代码的复杂度，使其更易于维护，也为其繁盛的社区发展提供了基石。为了满足不同的用户需求，Sonarr 的作者们开发一系列以 <code>rr</code> 或其他双字母结尾的工具，以至于这种命名方式成为了 Sonarr 生态圈的一个标识和事实标准。</p>
<h3 id="jackett">Jackett</h3>
<blockquote>
<p>Jackett works as a proxy server: it translates queries from apps into tracker-site-specific http queries, parses the html or json response, and then sends results back to the requesting software.</p>
</blockquote>
<p><a href="https://github.com/Jackett/Jackett">Jackett</a> 是一个代理，用于将 Sonarr 等系统对剧集信息的查询请求转译成各种 torrent tracker/indexer （即资源发布站）所支持的请求。Jackett 的产生是 Sonarr 社区架构合理性的一个体现，它接管了适配不同 indexer 接口的脏活累活，使 Sonarr 可以专注在任务调度和剧集管理上。</p>
<p>Jackett 既然被用作资源查询的网关，实现缓存功能就顺理成章了，这样一方面可以应对 Sonarr 频繁的查询需求，另一方面也减少了 indexer 站点的负载量，实现了双赢。因此虽然它不是一个必须的组件，但我强烈建议每个使用 Sonarr 的用户都安装它。</p>
<h3 id="flaresolverr">FlareSolverr</h3>
<blockquote>
<p>FlareSolverr is a proxy server to bypass Cloudflare and DDoS-GUARD protection.</p>
</blockquote>
<p><a href="https://github.com/FlareSolverr/FlareSolverr">FlareSolverr</a> 也是一个代理，它帮助 Jackett 解决向 indexer 的请求能否成功的问题。一些 indexer 为了保护自己免于 DDoS 攻击或减少爬虫请求，会使用 Cloudflare 或一些其他的安全防护服务，如果不做处理，直接请求很可能因触发人机验证而失败。FlareSolverr 就是为解决这类问题诞生的。</p>
<p>在 Jackett 中添加新的 indexer 时，会根据站点情况提示是否需要接入 FlareSolverr 以绕过站点的保护措施。</p>
<h3 id="qbittorrent">qBittorrent</h3>
<p>大部分影视资源都使用 BT 协议进行点对点传输，因此我们也需要一个 BT 下载器，qBittorrent 就是一个很好的选择，它的功能非常全面，且与 Sonarr 有很好的接入支持。如果你已经运行了其他下载器如 Aria2，甚至 QNAP/Synology 自带的 Download Station，那么你也可以参考 <a href="https://wiki.servarr.com/sonarr/supported#downloadclient">Sonarr 支持的下载器列表</a>，尝试进行配置。（我并没有成功使 Sonarr 和 QNAP Download Station 协同工作起来）</p>
<h3 id="部署说明">部署说明</h3>
<p>各个组件介绍完毕，现在让我们进入正题，了解如何配置和部署整个 Sonarr 服务组。</p>
<p>Sonarr 现代化地提供 Docker 镜像的部署方式，因此这个章节将会围绕 Docker 相关的技术进行说明。虽然 <a href="https://www.qnapclub.eu/en/qpkg/652">Qnapclub</a> 也有 Sonarr 的安装包，但经过一番糟心的尝试，最终我只得出一个结论，那就是以后部署任何服务，能 Docker 就尽量 Docker 吧。</p>
<p><details >
  <summary markdown="span">A failed attempt to install Sonarr by qpkg</summary>
  <ul>
<li>error after install: <code>MediaInfo Library could not be loaded libmediainfo.so.0 assembly:&lt;unknown assembly&gt; type:&lt;unknown type&gt; member:(null)</code></li>
<li>dependencies
<ul>
<li><a href="https://www.qnapclub.eu/en/qpkg/193">Qmono</a>: the package is crazily 3GB in size</li>
<li><a href="https://www.qnapclub.eu/en/qpkg/712">MediaInfoCLI</a>
<ul>
<li><a href="https://forum.qnap.com/viewtopic.php?t=147702">https://forum.qnap.com/viewtopic.php?t=147702</a></li>
<li>this is not useful at all</li>
</ul>
</li>
</ul>
</li>
</ul>

</details></p>

<p>我们的部署方案的基本原理是在自己的电脑上通过 Docker 和 Docker compose CLI 对远端 NAS 上的 Docker host 进行操作。这要求读者具备基础的 Docker 相关的知识。</p>
<p>QNAP/Synology 等 NAS 系统提供的 Docker host 与标准实现基本没有差异，因此我们可以直接使用 Docker 官方软件包提供的命令行工具。你也可以使用 NAS 提供的图形化界面，但一则那样在部署多个服务时非常不便，二则如果你了解了如何使用 Docker compose 部署，自然也可以反推到图形化界面的操作方式上。</p>
<h4 id="docker-context">Docker context</h4>
<p>为了与本地的 Docker host 区分开，我们要为 NAS 上的 Docker host 创建一个新的 <a href="https://docs.docker.com/engine/context/working-with-contexts/">context</a>。</p>
<blockquote>
<p><code>harrogath</code> 是我的 NAS 的 hostname，可以使用 IP 代替</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 创建 context</span>
docker context create harrogath

<span class="c1"># 更新 context 的配置信息</span>
docker context update harrogath --docker <span class="s2">&#34;host=tcp://harrogath:2376,ca=</span><span class="nv">$HOME</span><span class="s2">/.docker/ca.pem,cert=</span><span class="nv">$HOME</span><span class="s2">/.docker/cert.pem,key=</span><span class="nv">$HOME</span><span class="s2">/.docker/key.pem&#34;</span>
</code></pre></div><p>QNAP 的 Docker 需要通过证书来访问，因此要在 Container Station 的设置中下载证书。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qnap-docker-certs.png" type="" alt=""  /></p>
<p>完成 context 创建后，通过 <code>use</code> 命令切换到 context，之后所有的 Docker 命令都是与 NAS Docker 进行通讯</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="l">docker context use harrogath</span><span class="w">
</span><span class="w"></span><span class="l">docker context ls</span><span class="w">
</span><span class="w"></span><span class="l">NAME                TYPE                DESCRIPTION                               DOCKER ENDPOINT                               KUBERNETES ENDPOINT   ORCHESTRATOR</span><span class="w">
</span><span class="w"></span><span class="l">default             moby                Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                                         swarm</span><span class="w">
</span><span class="w"></span><span class="l">harrogath *         moby</span><span class="w">
</span></code></pre></div><h4 id="images">Images</h4>
<p>目前主要有两个组织在维护 Sonarr 及相关服务的 Docker 镜像，<a href="https://www.linuxserver.io/">linuxserver.io</a> 和 <a href="https://hotio.dev/">hotio.dev</a>, 我选择前者作为本次部署的镜像源。下面是使用到的镜像列表，可以在其页面上查看镜像的使用说明。</p>
<ul>
<li><a href="https://hub.docker.com/r/linuxserver/sonarr">linuxserver/sonarr - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/jackett">linuxserver/jackett - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/linuxserver/qbittorrent">linuxserver/qbittorrent - Docker Image | Docker Hub</a></li>
<li><a href="https://hub.docker.com/r/flaresolverr/flaresolverr">flaresolverr/flaresolverr - Docker Image | Docker Hub</a></li>
</ul>
<h4 id="hierarchy">Hierarchy</h4>
<p>Sonarr 和它的朋友们需要对 NAS 的存储进行读写，因此在运行服务之前，首先要理解并设计一个好用的目录结构。</p>
<p>我们需要在 NAS 上创建一个 AppData 目录，作为容纳所有服务产生的文件的根目录。AppData 所在的 Volume 建议选择适合存放大量媒体数据的精简卷 (Thin Volume)。</p>
<pre tabindex="0"><code>AppData
├── jackett
│   ├── config
│   └── downloads
├── qbittorrent
│   └── config
└── sonarr
    ├── config
    ├── downloads
    ├── media
    ├── torrents
    └── usenet
</code></pre><p>在 AppData 之下，依次为 sonarr, jackett, qbittorrent 创建目录，每个目录下必须有 <code>config</code> 子目录，用于存放配置文件。flaresolverr 由于是纯网络代理服务不需要对应目录存在。</p>
<p>下面对各个服务的 NAS 目录与容器内目录的映射关系进行说明</p>
<blockquote>
<p>表示为 <code>NAS Directory -&gt; Container Directory</code></p>
</blockquote>
<ul>
<li><strong>sonarr</strong>
<ul>
<li><code>sonarr/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，可在 Sonarr 管理界面向下创建子目录</li>
</ul>
</li>
<li><strong>qbittorrent</strong>
<ul>
<li><code>qbittorrent/config -&gt; /config</code>: 配置文件</li>
<li><code>sonarr -&gt; /data</code>: 数据文件，与 sonarr 保持一致，以便 sonarr 在重命名或移动文件时可以直接使用 qbittorrent 返回的文件路径</li>
</ul>
</li>
<li><strong>jackett</strong>
<ul>
<li><code>jackett/config -&gt; /config</code>: 配置文件</li>
<li><code>jackett/downloads -&gt; /downloads</code>: 默认种子文件下载路径</li>
</ul>
</li>
</ul>
<h4 id="compose-file">Compose file</h4>
<p>以我正在使用的 <code>docker-compose.yml</code> 文件作为示例，你可以复制下来修改自己的版本，只需要将 <code>/share/CACHEDEV2_DATA/Misc/AppData</code> 替换为自己在 NAS 上创建的 <code>AppData</code> 路径即可。</p>
<p>端口的配置需要额外注意，这份配置中我尽量保持各服务默认配置端口不变，若与已有服务冲突，修改到未被占用的端口即可。例如 QNAP 自带的 Download Station 已占用 6881 端口，因此我将 qbittorrent 修改到了 16881 端口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">sonarr</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/sonarr</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8989</span><span class="p">:</span><span class="m">8989</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span><span class="w">      </span>- <span class="l">/etc/localtime:/etc/localtime:ro</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">jackett</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/jackett</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">9117</span><span class="p">:</span><span class="m">9117</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/jackett/downloads:/downloads</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">qbittorrent</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">linuxserver/qbittorrent</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">      </span>- <span class="l">WEBUI_PORT=8080</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/qbittorrent/config:/config</span><span class="w">
</span><span class="w">      </span>- <span class="l">/share/CACHEDEV2_DATA/Misc/AppData/sonarr:/data</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8080</span><span class="p">:</span><span class="m">8080</span><span class="w">
</span><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="w">
</span><span class="w">      </span>- <span class="m">16881</span><span class="p">:</span><span class="m">6881</span><span class="l">/udp</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span><span class="w">  </span><span class="nt">flaresolverr</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">flaresolverr/flaresolverr</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">LOG_LEVEL=info</span><span class="w">
</span><span class="w">      </span>- <span class="l">LOG_HTML=false</span><span class="w">
</span><span class="w">      </span>- <span class="l">CAPTCHA_SOLVER=${CAPTCHA_SOLVER:-none}</span><span class="w">
</span><span class="w">      </span>- <span class="l">TZ=Asia/Shanghai</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="m">8191</span><span class="p">:</span><span class="m">8191</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></code></pre></div><h4 id="run">Run</h4>
<p>一切准备就绪，执行以下命令:</p>
<pre tabindex="0"><code>docker compose up
</code></pre><p>这会启动所有服务并 attach 到终端输出日志，方便查看服务的运行日志。等确认所有服务稳定运行后，加上 <code>-d</code> 参数使其运行在后台。</p>
<pre tabindex="0"><code>docker compose up -d
</code></pre><h3 id="使用说明">使用说明</h3>
<p>下面对各个服务的 Web UI 的使用方法进行说明，以我的 NAS hostname  <code>harrogath</code> 为例展示服务的访问地址。</p>
<h4 id="jackett-1">Jackett</h4>
<p>打开 <code>http://harrogath:9117</code>, Jackett 的界面展示如下:</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett.png" type="" alt=""  /></p>
<p>使用方式非常简单，Jackett 已经将这个世界上绝大部分 indexer 都内置了，只需要点击 Add indexer 搜索并添加即可。除了部分有访问限制的 indexer 需要配置外，基本上都可以一路点击确认完成添加。之后在 Sonarr 中对接时，需要复制订阅 URL 和 API key，参照截图中所示即可。</p>
<p>我目前使用了 4 个 indexer，其中 Bangumi Moe 和 dmhy 用于下载动画番剧，EZTV 和 RARBG 用于下载美剧。</p>
<p>为了使 FlareSolverr 发挥作用，我们还需要将它的 URL 填在最下方的配置中，然后点击 Apply server settings 保存生效。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-1.png" type="" alt=""  /></p>
<h4 id="qbittorrent-1">qBittorrent</h4>
<p>打开 <code>http://harrogath:8080</code>，使用默认用户名密码 <code>admin:adminadmin</code> 登录。</p>
<p>打开 Tools » Options，将 Default Save Path 修改为 <code>/data/downloads</code>。这样做的目的是为了使 qBittorrnet 所记录的文件路径与 Sonarr 保持一致，以便不需要额外配置就能使 Sonarr 的重命名功能正常工作。若你不希望修改下载路径，或使用的是其他下载器，可以参考 <a href="https://trash-guides.info/Sonarr/Sonarr-remote-path-mapping/">Remote Path Mappings</a> 来解决路径不一致的问题。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent.png" type="" alt=""  /></p>
<p>在 Options 中切换到 BitTorrent 选项卡，将 Seeding Limits 下的 &ldquo;then&rdquo; 修改为 &ldquo;Pause torrent&rdquo;，这是为了避免 Sonarr 在删除种子时产生冲突。&ldquo;When ratio reaches&rdquo; 代表做种分享资源的比率。BT 协议提倡共享精神，既然从别人那里获取到自己想要的资源，理应做出回馈。推荐将分享率设置为 2.0，即上传量为下载量的两倍之后停止分享。如果你担心硬盘过度损耗，可以将比率降低。(<em>也可以修改为 0 关闭做种功能，如果克服了道德感的约束</em>)
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/qbittorrent-3.png" type="" alt=""  /></p>
<h4 id="sonarr-1">Sonarr</h4>
<p>终于到了追番大计最核心的组件——Sonarr，但先不要急，在添加番剧前，还有一些设置要做。</p>
<ol>
<li>
<p>Indexers</p>
<ul>
<li>将先前在 Jackett 中添加的 indexers 逐个对接到 Sonarr，使用 Torznab 协议。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-1.png" type="" alt=""  /></li>
<li>Bangumi.moe 的配置展示，URL 和 API Key 都是从 Jackett 中复制过来。需要注意的是， Categories 是影视剧的分类，应该留空，而在 Anime Categories 中勾选所有与番剧相关的分类项。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-2.png" type="" alt=""  />
<ul>
<li>若不确定自己要搜索在资源属于哪个分类项，可在 Jackett 中使用 Manual Search 来确认
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/jackett-2.png" type="" alt=""  /></li>
</ul>
</li>
<li>rarbg 的配置展示，由于 rarbg 是影视剧 indexer，我们需要在 Categories 中勾选分类项而将 Anime Categories 留空
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-3.png" type="" alt=""  /></li>
</ul>
</li>
<li>
<p>Download Clients</p>
<ul>
<li>qBittorrent 配置展示。Host 最好填写 IP，使用 hostname 可能会失败。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-qbittorrent.png" type="" alt=""  /></li>
</ul>
</li>
<li>
<p>Profiles</p>
<p>默认只有 English，需要添加一个中文的 Profile 以在添加番剧时设定语言。<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-profile.png" type="" alt=""  /></p>
</li>
<li>
<p>Media Management</p>
<p>这个设置关系到下载的文件能否被 Plex 或其他 media server 识别，但别被眼花缭乱的设置项吓到， 我们只需要关心下图红框圈起的部分。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-mediamanagement.png" type="" alt=""  /></p>
<ul>
<li>首先打开 Rename Episodes 功能</li>
<li>然后配置 Anime Episode Format 和 Season Folder Format，这代表番剧被重命名后的文件名格式和上级目录格式。你不用关心源文件的名称如何被 Sonarr 解析，你只用知道它自信并出色地完成了这项脏活，让我们可以使用变量定义想要的文件和目录名称。这里我使用的是 Plex 的 <a href="https://support.plex.tv/articles/naming-and-organizing-your-tv-show-files/">TV Show Files</a> 格式，实现的结果如下: <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/finder.png" type="" alt=""  /></li>
<li>最后配置 Root Folders，它们在添加番剧的时候会用到，作为放置番剧的目录。你可以根据自己的需求设置多个，一般来说设置两个将影视剧和动画番剧分开存放即可。还记得我们在 <code>docker-compose.yaml</code> 中配置的目录映射吗？这里的目录 <code>/data/media/anime tv</code> 在 NAS 中对应的是 <code>AppData/sonarr/data/media/anime tv</code>，在 Plex 添加媒体库时不要忘了如何找到它。</li>
<li>Optional: 文件重命名时，Sonarr 默认采取移动策略，这样会导致 BT 下载器无法继续对资源做种，为了避免这种情况，在 Media Management 页面打开 Advanced Settings，找到并打开 &ldquo;Use Hardlinks instead of Copy&rdquo;，这样既保留了下载资源的原始路径，又不会额外占用硬盘空间。</li>
</ul>
</li>
<li>
<p>Connect</p>
<p>实现自动化追剧的目的是为了不需要人工检查剧集的更新情况，因此通知是必不可少的。Connect 可以连接许多通知服务，让你第一时间知道剧集何时上线，资源何时发布，何时完成下载、可以观看。下面说明如何对接 Telegram 获取通知信息。</p>
<ul>
<li>
<p>在 Telegram 搜索机器人 <code>@BotFather</code>，按照提示创建一个新的机器人，获取 API Token。我的机器人名为 <code>@reorx_notify_bot</code>。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-2.png" type="" alt=""  /></p>
</li>
<li>
<p>创建一个群组，将 bot 加入到群组中，请求接口 <code>https://api.telegram.org/bot&lt;TOKEN&gt;/getUpdates</code>, 取出返回结果中的 <code>result[0].channel_post.chat.id</code> 作为 chat id</p>
<blockquote>
<p>方法来自 <a href="https://stackoverflow.com/a/61215414/596206">How to obtain Telegram chat_id for a specific user?</a></p>
</blockquote>
<ul>
<li>2022-08-11 updated: 也可以通过将 <code>@getidsbot</code> 邀请到群组中来获得 chat id，这个方法更加简单便捷</li>
</ul>
</li>
<li>
<p>在 Sonarr 中添加 Telegram connection，勾选自己关心的通知类型，一般至少会选择 On Download，代表新剧集下载完成的时间。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram.png" type="" alt=""  /></p>
</li>
<li>
<p>配置好后，就可以通过 Telegram 第一时间掌握番剧的更新情况了。 <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-telegram-1.png" type="" alt=""  /></p>
</li>
</ul>
</li>
</ol>
<h4 id="开始追剧">开始追剧</h4>
<p>配置完成，现在可以开始追剧了。下面以「盾之勇者成名录 第二季」为例说明在 Sonarr 添加番剧的过程。</p>
<p>打开 <a href="https://thetvdb.com/">TheTVDB.com</a>, 搜索到你想要追踪的番剧的页面 <a href="https://thetvdb.com/series/the-rising-of-the-shield-hero">The Rising of the Shield Hero</a>，获取 URL 中的最后一段 <code>the-rising-of-the-shield-hero</code> 作为在 Sonarr 搜索关键词。</p>
<p>打开 Sonarr，在左上角的 Search 框中输入 <code>the-rising-of-the-shield-hero</code>，点击搜索结果，进入添加番剧的界面。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-6.png" type="" alt=""  /></p>
<ol>
<li>Root Folder: 选择先前在 Media Management 中设置的 <code>anime tv</code></li>
<li>Monitor: 由于我们只想看最近的第二季，因此选择 Only Latest Season</li>
<li>Quality Profile: 选择 HD-1080p 或其他你需要的格式/分辨率</li>
<li>Language Profile: 选择 Chinese</li>
<li>Series Type: 选择 Anime，这里对应的是添加 Indexer 时的 Anime Categories 选项，告诉 Sonarr 从 Indexer 的 Anime Categories 中搜索资源。如果使用默认的 Standard（对应 Indexer 的 Categories），将会导致无法搜索到资源。</li>
<li>Season Folder: 勾选，为了对应 Plex 要求的目录结构</li>
<li>Start search for missing episodes: 勾选，这会使 Sonarr 在添加番剧后立刻根据 Monitor 所设置的条件开始搜索资源。也可以在添加完成后在详情页手动点击触发。</li>
</ol>
<p>完成添加后，点击番剧进入详情页。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-7.png" type="" alt=""  /></p>
<ol>
<li>点击放大镜图标对其所在的 Season 进行剧集搜索。</li>
<li>Status 列的图标说明
<ul>
<li>🕓: 尚未播出，不会进行监控</li>
<li>⚠️: 已播出，硬盘中还没有资源，正在进行监控</li>
<li>☁️ 或进度条: 已开始下载</li>
</ul>
</li>
<li>书签符号有填充代表该季处于正在监控状态，无填充代表未监控，可以点击手动设置为监控</li>
</ol>
<p>在 Sonarr 首页可以看到各个番剧的追踪状态，蓝色代表标记追踪的剧集都已下载完成，红色代表有缺失，正在持续监控中。
<img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/sonarr-5.png" type="" alt=""  /></p>
<p>下载了一些资源后，我们打开 Plex，将 <code>anime tv</code> 对应的路径添加到「动画」Library 中，Plex 就会开始自动扫描文件、刮削元数据、下载中文字幕了。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex.png" type="" alt=""  /></p>
<p>大功告成，在 Plex 上愉快看番吧☺️。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/plex-1.png" type="" alt=""  /></p>
<h2 id="番外">番外</h2>
<h3 id="sonarr-的其他朋友们">Sonarr 的其他朋友们</h3>
<ul>
<li><a href="https://radarr.video/">Radarr</a>
Radarr 是 Sonarr 的兄弟项目，Sonarr 专精于追剧，Radarr 专精于追踪电影</li>
<li><a href="https://www.bazarr.media/">Bazarr</a>
Bazarr 用于自动下载字幕文件，由于 Plex 本身具有这个功能，以及大部分动漫资源都有内置字幕，因此不是特别有必要部署</li>
<li><a href="https://lidarr.audio/">Lidarr</a>
Lidarr 是音乐专辑的追踪和下载器，适用于喜欢收藏本地音乐文件的用户</li>
<li><a href="https://readarr.com/">Readarr</a>
Readarr 是电子书的追踪和下载器。我看书不多，偶尔需要看的书一般从 zlibrary 下载，Calibre 足够满足我的管理需求。</li>
</ul>
<h3 id="lunasea">LunaSea</h3>
<p><a href="https://www.lunasea.app/">LunaSea</a> 是一个 Sonarr 和 Usenet 生态圈的远程控制器，能让你在手机上查看 Sonarr / Radarr / Lidarr 的资源和放送时间表。</p>

<figure class="center align-center">
  <div class="image-size-control" style="height: 600px;">
    <img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/lunasea.jpeg" type="" alt=""  />
  </div>

  <figcaption><p>LunaSea iOS app screenshot</p></figcaption>
</figure>

<h3 id="seedboxio">Seedbox.io</h3>
<p>在得知我最近的折腾经过后，我的好朋友 <a href="https://wzyboy.im/">wzyboy</a> 向我科普了一种名为 <a href="https://en.wikipedia.org/wiki/Seedbox">Seedbox</a> 的 hosted service，提供开箱即用的 BT 下载和家庭媒体服务器，并能带来以下几点好处：</p>
<ul>
<li>免于折腾和维护诸多服务/服务器</li>
<li>发扬 BT 分享精神的同时无需损耗自己的硬盘</li>
<li>规避 P2P 下载资源的版权问题</li>
</ul>
<p>其中有一家服务商叫 seedbox.io, 它们的服务器包含本篇介绍的所有组件。如果你有兴趣的话，可以通过这个 <a href="https://panel.seedbox.io/aff.php?aff=1061">affiliate link</a> 注册和购买他们的服务。</p>
<p><img loading="lazy" src="/blog/track-and-download-shows-automatically-with-sonarr/images/seedbox-apps.png" type="" alt=""  /></p>
<h2 id="结语">结语</h2>
<p>Sonarr 和它的朋友们还有许多功能，本篇旨在引导用户完成最基本的自动化追番配置，就不一一介绍了，有兴趣的读者可以自行探索，欢迎在评论区留言分享。</p>
<p>近两年来，在家办公越来越融入到我们的生活，家庭网络和服务的搭建也逐渐从以往对 Geek 的刻板印象，变成或许没被意识到，但人人都有的需求。照片存储、数据备份、远程控制、环境监控、智能家居、多媒体娱乐…这些无一不是我们的日常所需。往后我会写更多这方面的文章，将我使用 NAS 改变生活方式的过程记录下来。The digital life has just begun.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://wiki.servarr.com/">WikiArr</a></li>
<li><a href="https://trash-guides.info/">TRaSH Guides</a></li>
</ul>
<h2 id="revision">Revision</h2>
<ul>
<li>2022-04-19: created with &ldquo;使用 QNAP Download Station&rdquo;</li>
<li>2022-05-02: added &ldquo;使用 Sonarr 和它的朋友们&rdquo;, finished &ldquo;部署说明&rdquo;</li>
<li>2022-05-04: finished &ldquo;使用说明&rdquo; and the whole article</li>
<li>2022-08-11: added using <code>@getidsbot</code> to find Chat ID in Telegram</li>
</ul>
]]></content:encoded></item><item><title>Switch open files quickly in Obsidian</title><link>https://reorx.com/blog/obsidian-switching-open-files-quickly/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/obsidian-switching-open-files-quickly/</guid><description>Imagine a quick switcher with open files at the top.</description><content:encoded><![CDATA[<h2 id="the-problem">The problem</h2>
<p>since I use the “Sliding Panes” plugin, there’s always a bunch of files open in my Obsidian. Sometimes I switch to Obsidian with a very clear goal of opening a specific file, so I press Command+O and type in the file name to find it. Because I don’t want to check whether the file is open or not (rather say there’s no way to check open files quickly), I always press Command+Enter to open the file in a new pane. As this process repeats, some files will have redundant panes, the panes are bloated and the workspace ends up being a mess.</p>
<p><a href="https://github.com/darlal/obsidian-switcher-plus">Quick Switcher++</a> is a very helpful tool, it allows me to search for open editors by typing a special prefix (<code>edt</code> by default) in the quick switcher. But after using it a while, I still feel it’s not very intuitive, I want the “search any file and open it” action and “search for existing open file and activate it” to be combined into one thing to use.</p>
<h2 id="the-solution">The solution</h2>
<p>I forked Quicker Switcher ++ and added a new setting item called “Include open files”. When it’s enabled, the switcher modal shows all the open files at the top with a different color style. If the open file is chosen, make that pane active; Other suggestions behave the same as the original, opening the file in the active pane.</p>
<figure>
<video class="video-shortcode" preload="" controls>
  <source src="https://i.imgur.com/bGLcQKl.mp4" type="">
  There should have been a video here but your browser does not seem to support it.
</video>
</figure>

<p>I’ll test this new feature in my workflow for a while to see if it’s actually useful. Meanwhile, I’d love to hear from the Obsidian community. What do you think about it? Do you have a better idea for my problem? Feel free to leave a message to me.</p>
]]></content:encoded></item><item><title>A look into Heptabase's split writing experience</title><link>https://reorx.com/blog/heptabase-split-writing/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://reorx.com/blog/heptabase-split-writing/</guid><description>The amazing UX Heptabase creates to help reading, thinking, and writing with heavy context efficiently</description><content:encoded><![CDATA[<p>Yesterday I found Heptabase&rsquo;s new introduction video: <a href="https://www.youtube.com/watch?v=oVXQx9sz_Wk">The 3-step knowledge workflow in Heptabase</a>.</p>
<p>Heptabase is the most promising note-taking app for me in recent years. The idea of combining bi-directional links, cards, and whiteboards together is mind-blowing. The word note-taking or knowledge base is not accurate to define it, in fact, it&rsquo;s more like a tool that aims for boosting the process of thinking.</p>
<p>Traditional note-taking tools are keen on providing more than enough ways for dumping your thoughts into notes, but lack methodologies on how to retrieve and use notes. The way Heptabase organizes and interacts with the data is what really empowers the user to think and write more efficiently.</p>
<p>Back to the video at the beginning, after watching it I noticed a very interesting feature. I can&rsquo;t stop thinking of it and really wish to have something similar in other note-taking or PMK tools like Obsidian (yeah, I&rsquo;m an Obsidian fan).</p>
<h2 id="the-feature">The feature</h2>
<p>Here&rsquo;s the walk though of that amazing feature:</p>
<ul>
<li>On a whiteboard, select several cards you would like to refer to <img loading="lazy" src="/blog/heptabase-split-writing/images/heptabase.png" type="" alt=""  /></li>
<li>Right-click on them and choose &ldquo;Open in new tab&rdquo;, a new page with a left-right split layout appears. The first card selected shows on the left; others show on the right as a folded list. <img loading="lazy" src="/blog/heptabase-split-writing/images/heptabase-1.png" type="" alt=""  /></li>
<li>Click on the <code>+</code> sign button on the top menu bar; a new card is created on the left side, and the card that previously shows on the left is automatically moved to the card list on the right.  <img loading="lazy" src="/blog/heptabase-split-writing/images/heptabase-2.png" type="" alt=""  /></li>
<li>You can fold/unfold notes while browsing the right side, and drag&rsquo;n drop blocks to copy them to the left side. <img loading="lazy" src="/blog/heptabase-split-writing/images/heptabase-3.png" type="" alt=""  /></li>
</ul>
<p>This is the best way I&rsquo;ve ever seen to think and write a note while referring to many other notes. In other note-taking tools, take Obsidian for example, I can split the panes, but it is not convenient to organize the workspace well for more than 3 notes. As new panes are growing, it will become more and more interruptive to switch back and forth.</p>
<p>Even if I managed to build up a tidy workspace, it&rsquo;s still very frustrating to switch to another context. Obsidian has the functionality to manage workspaces, but you have to manually save before switching, otherwise, the context will be missing. In Heptabase, all the workspaces are clearly shown in the sidebar, switching around is fast and easy as a breath.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It&rsquo;s a shock to me how easy and intuitive it could be in Heptabase to create a workspace and focus on writing. I believe anybody with note-taking experience could learn something from Heptabase&rsquo;s design.</p>
<p>Obsidian is still the best PKM tool for me. I&rsquo;m going to create a plugin to achieve a similar workflow in Obsidian, possibly by creating a special pane that can add and show notes in an accordion. Stay tuned for the updates.</p>
]]></content:encoded></item></channel></rss>